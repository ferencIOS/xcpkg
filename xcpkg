#!/bin/sh

# Copyright (c) 2021-2023 åˆ˜å¯Œé¢‘
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# https://github.com/leleliu008/xcpkg

######################################################################################
####################################  convention  ####################################
# 1. The variable/function name starts with underscore "_" means that it is a private variable/function.
######################################################################################

# If IFS is not set, the deault value will be <space><tab><newline>
# https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_05_03
unset IFS

_0=$0

unset CURRENT_SCRIPT_DIR
unset CURRENT_SCRIPT_FILENAME
unset CURRENT_SCRIPT_FILEPATH

CURRENT_SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd) || exit 1
CURRENT_SCRIPT_FILENAME=$(basename "$0")
CURRENT_SCRIPT_FILEPATH="$CURRENT_SCRIPT_DIR/$CURRENT_SCRIPT_FILENAME"


# }}}
##############################################################################
# {{{ utils

COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;94m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

print() {
    printf '%b' "$*"
}

echo() {
    printf '%b\n' "$*"
}

info() {
    printf '%b\n' "ðŸ’   $*"
}

note() {
    printf '%b\n' "${COLOR_YELLOW}ðŸ””  $*${COLOR_OFF}" >&2
}

warn() {
    printf '%b\n' "${COLOR_YELLOW}ðŸ”¥  $*${COLOR_OFF}" >&2
}

success() {
    printf '%b\n' "${COLOR_GREEN}[âœ”] $*${COLOR_OFF}"
}

error() {
    printf '%b\n' "${COLOR_RED}ðŸ’”  $*${COLOR_OFF}" >&2
}

abort() {
    EXIT_STATUS_CODE="$1"
    shift
    printf '%b\n' "${COLOR_RED}ðŸ’”  $*${COLOR_OFF}" >&2
    exit "$EXIT_STATUS_CODE"
}

step() {
    STEP_NUM=$(expr ${STEP_NUM-0} + 1)
    STEP_MESSAGE="$*"
    printf '\n%b\n' "${COLOR_PURPLE}=>> STEP ${STEP_NUM} : ${STEP_MESSAGE} ${COLOR_OFF}"
}

run() {
    if [ "$RUN_SILENT" != yes ] ; then
        echo "${COLOR_PURPLE}==>${COLOR_OFF} ${COLOR_GREEN}$@${COLOR_OFF}"
    fi

    eval "$@"
}

list_size() {
    printf '%s\n' "$#"
}

is_integer() {
    case "${1#[+-]}" in
        (*[!0123456789]*) return 1 ;;
        ('')              return 1 ;;
        (*)               return 0 ;;
    esac
}

# format_unix_timestamp <TIMESTAMP-UNIX> <TO-FORMAT> [-u]
  format_unix_timestamp() {
   date $3 -jf "%s" "$1" "$2" 2> /dev/null ||
   date $3 -d      "@$1" "$2"
}

bppend_to_PATH() {
    case ":${PATH}:" in
        *:"$1":*) ;;
        *) export PATH="$1:$PATH" ;;
    esac
}

bppend_to_ACLOCAL_PATH() {
    case ":${ACLOCAL_PATH}:" in
        *:"$1":*) ;;
        *) export ACLOCAL_PATH="$1:$ACLOCAL_PATH" ;;
    esac
}

sed_in_place() {
    if command -v gsed > /dev/null ; then
        unset SED_IN_PLACE_ACTION
        SED_IN_PLACE_ACTION="$1"
        shift
        # contains ' but not contains \'
        if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
            run gsed -i "\"$SED_IN_PLACE_ACTION\"" "$@"
        else
            run gsed -i "'$SED_IN_PLACE_ACTION'" "$@"
        fi
    elif command -v sed  > /dev/null ; then
        if sed -i 's/a/b/g' $(mktemp) 2> /dev/null ; then
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i "\"$SED_IN_PLACE_ACTION\"" "$@"
            else
                run sed -i "'$SED_IN_PLACE_ACTION'" "$@"
            fi
        else
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i '""' "\"$SED_IN_PLACE_ACTION\"" "$@"
            else
                run sed -i '""' "'$SED_IN_PLACE_ACTION'" "$@"
            fi
        fi
    else
        abort 1 "please install sed utility."
    fi
}

# }}}
##############################################################################
# {{{ lolcat_implemented_in_awk

# https://equa.space/sh/lolcat/
lolcat_implemented_in_awk() {
    awk -v angle=45 -v angle_phase=40 -v reverse=0 -v offset=195 -v offset_phase=0 -v width=100 -v width_phase=8 "$@" '
    function put_rgb(color) {
        printf "\033[%s38;2;%d;%d;%dm", reverse ? "7;" : "", int(color[1] * 255), int(color[2] * 255), int(color[3] * 255);
    }

    function hsv_to_rgb(hsv, rgb, c, h2, x) {
        c = hsv[2] * hsv[3];
        h2 = hsv[1] * 6;
        x = c * (1 - ((h2 % 2) - 1 > 0 ? (h2 % 2) - 1 : 1 - (h2 % 2)));
        if (int(h2) % 6 == 0) {
            rgb[1] = c; rgb[2] = x; rgb[3] = 0;
        } else if (int(h2) % 6 == 1) {
            rgb[1] = x; rgb[2] = c; rgb[3] = 0;
        } else if (int(h2) % 6 == 2) {
            rgb[1] = 0; rgb[2] = c; rgb[3] = x;
        } else if (int(h2) % 6 == 3) {
            rgb[1] = 0; rgb[2] = x; rgb[3] = c;
        } else if (int(h2) % 6 == 4) {
            rgb[1] = x; rgb[2] = 0; rgb[3] = c;
        } else if (int(h2) % 6 == 5) {
            rgb[1] = c; rgb[2] = 0; rgb[3] = x;
        }

        rgb[1] += hsv[2] - c;
        rgb[2] += hsv[2] - c;
        rgb[3] += hsv[2] - c;
    }

    BEGIN {
        srand();
        if (offset == "") offset = rand() * 360;
    }

    {
        y = NR - 1;
        for (x = 0; x < length($0); x++) {
            for (i = 0; i < 3; i++) {
                mult_x = cos((angle + i * angle_phase) / 57.2976);
                mult_y = sin((angle + i * angle_phase) / 57.2976);
                hsv[1] = (((x * mult_x + y * mult_y) / (width + width_phase * i)) % 1 + 1 + (offset + offset_phase * i) / 360) % 1;
                hsv[2] = 0.8;
                hsv[3] = 0.9;

                hsv_to_rgb(hsv, trgb);
                rgb[i + 1] = trgb[i + 1];
            }

            put_rgb(rgb);
            printf("%s", substr($0, x + 1, 1));
        }
        print "\033[0m";
    }
    '
}

# }}}
##############################################################################
# {{{ wfetch

# wfetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] <--output-path=PATH>
# wfetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
# wfetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
# wfetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>

# influential environment variable:
# XCPKG_URL_TRANSFORM
wfetch() {
    unset FETCH_URL
    unset FETCH_URI
    unset FETCH_SHA256
    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_NAME
    unset FETCH_OUTPUT_PATH
    unset FETCH_SILENT

    if [ -z "$1" ] ; then
        error "wfetch <URL> [OPTION]... , <URL> must be non-empty."
        return 1
    fi

    if [ -z "$XCPKG_URL_TRANSFORM" ] ; then
        FETCH_URL="$1"
    else
        FETCH_URL="$("$XCPKG_URL_TRANSFORM" "$1")" || return 1
    fi

    shift

    while [ -n "$1" ]
    do
        case $1 in
            --silent)
                FETCH_SILENT=yes
                RUN_SILENT=yes
                ;;
            --sha256=*)
                FETCH_SHA256="${1#*=}"
                ;;
            --uri=*)
                FETCH_URI="${1#*=}"
                if [ -z "$FETCH_URI" ] ; then
                    error "wfetch <URL> --uri=<URL-MIRROR> , <URL-MIRROR> must be non-empty."
                    return 1
                fi
                if [ -n "$XCPKG_URL_TRANSFORM" ] ; then
                    FETCH_URI="$("$XCPKG_URL_TRANSFORM" "$FETCH_URI")" || return 1
                fi
                ;;
            --output-dir=*)
                FETCH_OUTPUT_DIR="${1#*=}"
                if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                    error "wfetch <URL> --output-dir=<DIR> , <DIR> must be non-empty."
                    return 1
                fi
                ;;
            --output-name=*)
                FETCH_OUTPUT_NAME="${1#*=}"
                if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                    error "wfetch <URL> --output-name=<NAME> , <NAME> must be non-empty."
                    return 1
                fi
                ;;
            --output-path=*)
                FETCH_OUTPUT_PATH="${1#*=}"
                if [ -z "$FETCH_OUTPUT_PATH" ] ; then
                    error "wfetch <URL> --output-path=<FILEPATH> , <FILEPATH> must be non-empty."
                    return 1
                fi
                ;;
            *)  error "wfetch <URL> [OPTION]..., unrecognized option: $1

    wfetch command usage:

    wfetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] <--output-path=PATH>
    wfetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
    wfetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
    wfetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>"
                return 1
        esac
        shift
    done

    if [ -z "$FETCH_URI" ] ; then
        FETCH_URI="$FETCH_URL"
    fi

    if [ -z "$FETCH_OUTPUT_PATH" ] ; then
        if [ -z "$FETCH_OUTPUT_DIR" ] && [ -z "$FETCH_OUTPUT_NAME" ] ; then
            FETCH_OUTPUT_PATH='-'
        else
            if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                FETCH_OUTPUT_DIR="$PWD"
            fi

            if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                FETCH_OUTPUT_NAME=$(basename "$FETCH_URL")
            fi

            FETCH_OUTPUT_PATH="$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME"

            if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
                run install -d "$FETCH_OUTPUT_DIR" || return 1
            fi
        fi
    elif [ "$FETCH_OUTPUT_PATH" = '-' ] ; then
        unset FETCH_OUTPUT_DIR
        unset FETCH_OUTPUT_NAME
    else
        FETCH_OUTPUT_DIR="$(dirname "$FETCH_OUTPUT_PATH")"
        FETCH_OUTPUT_NAME="$(basename "$FETCH_OUTPUT_PATH")"
        if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
            run install -d "$FETCH_OUTPUT_DIR" || return 1
        fi
    fi

    case $FETCH_URL in
        *.git)
            if [    -d "$FETCH_OUTPUT_PATH" ] ; then
                run cd "$FETCH_OUTPUT_PATH" || return 1
                if      git rev-parse HEAD > /dev/null 2>&1 ; then
                    run git pull || return 1
                    run git submodule update --recursive || return 1
                else
                    run cd .. || return 1
                    run rm -rf "$FETCH_OUTPUT_NAME" || return 1
                    run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME" || return 1
                fi
            else
                if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
                    run install -d "$FETCH_OUTPUT_DIR" || return 1
                fi
                run cd "$FETCH_OUTPUT_DIR" || return 1
                run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME" || return 1
            fi
            ;;
        *)
            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -f "$FETCH_OUTPUT_PATH" ] ; then
                if [ -n "$FETCH_SHA256" ] ; then
                    if [ "$(sha256sum "$FETCH_OUTPUT_PATH" | cut -d ' ' -f1)" = "$FETCH_SHA256" ] ; then
                        success "$FETCH_OUTPUT_PATH already have been fetched."
                        return 0
                    fi
                fi
                rm -f "$FETCH_OUTPUT_PATH" || return 1
            fi

            for FETCH_TOOL in curl wget http lynx aria2c axel
            do
                if command -v "$FETCH_TOOL" > /dev/null ; then
                    break
                else
                    unset FETCH_TOOL
                fi
            done

            if [ -z "$FETCH_TOOL" ] ; then
                error "no fetch tool found, please install one of curl|wget|http|lynx|aria2c|axel, then try again."
                return 1
            fi

            case $FETCH_TOOL in
                curl)
                    unset FETCH_TOOL_CURL_EXTRA_OPTIONS

                    if [ "$FETCH_SILENT" = yes ] ; then
                        FETCH_TOOL_CURL_OPTIONS='--no-progress-meter'
                    fi

                    if [ -f "$XCPKG_CORE_DIR/etc/ssl/certs/cacert.pem" ] ; then
                        FETCH_TOOL_CURL_OPTIONS="--cacert $XCPKG_CORE_DIR/etc/ssl/certs/cacert.pem"
                    fi

                    run "curl $FETCH_TOOL_CURL_OPTIONS --fail --retry 20 --retry-delay 30 --location -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "curl $FETCH_TOOL_CURL_OPTIONS --fail --retry 20 --retry-delay 30 --location -o '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                wget)
                    run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                http)
                    run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                lynx)
                    run "lynx -source '$FETCH_URL' > '$FETCH_OUTPUT_PATH'" ||
                    run "lynx -source '$FETCH_URI' > '$FETCH_OUTPUT_PATH'"
                    ;;
                aria2c)
                    run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URL'" ||
                    run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URI'"
                    ;;
                axel)
                    run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                *)  error "wfetch() unimplementation: $FETCH_TOOL"
                    return 1
                    ;;
            esac

            [ $? -eq 0 ] || return 1

            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -n "$FETCH_SHA256" ] ; then
                [ "$(sha256sum "$FETCH_OUTPUT_PATH" | cut -d ' ' -f1)" = "$FETCH_SHA256" ] || {
                    error "sha256sum mismatch.\n    expect : $FETCH_SHA256\n    actual : $(sha256sum "$FETCH_OUTPUT_PATH" | cut -d ' ' -f1)"
                    return 1
                }
            fi
    esac
}

# }}}
##############################################################################
# {{{ version

version_sort() {
    printf '%s\n' "$@" | sort -V
}

# check if match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# version_match 1.15.3 eq 1.16.0
# version_match 1.15.3 lt 1.16.0
# version_match 1.15.3 gt 1.16.0
# version_match 1.15.3 le 1.16.0
# version_match 1.15.3 ge 1.16.0
version_match() {
    case $2 in
        eq)  [ "$1"  = "$3" ] ;;
        ne)  [ "$1" != "$3" ] ;;
        le)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        ge)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        lt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        gt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        *)  abort 1 "version_match: unsupported operator: $2"
    esac
}

# }}}
##############################################################################
# {{{ __load_formula_repository_config

# __load_formula_repository_config <REPO-NAME> [REPO-PATH]
  __load_formula_repository_config() {
    XCPKG_FORMULA_REPO_NAME="$1"
    XCPKG_FORMULA_REPO_PATH="$XCPKG_HOME/repos.d/$1"
    XCPKG_FORMULA_REPO_CONFIG_FILEPATH="$XCPKG_FORMULA_REPO_PATH/.xcpkg-formula-repo.yml"

    [ -d "$XCPKG_FORMULA_REPO_PATH" ] || abort 1 "'$1' formula repository does not exist."
    [ -f "$XCPKG_FORMULA_REPO_CONFIG_FILEPATH" ] || abort 1 "$1 formula repository is broken."

    XCPKG_FORMULA_REPO_URL=
    XCPKG_FORMULA_REPO_BRANCH=
    XCPKG_FORMULA_REPO_PINNED=
    XCPKG_FORMULA_REPO_ENABLED=
    XCPKG_FORMULA_REPO_TIMESTAMP_CREATED=
    XCPKG_FORMULA_REPO_TIMESTAMP_UPDATED=

    XCPKG_FORMULA_REPO_URL="$(yq .url "$XCPKG_FORMULA_REPO_CONFIG_FILEPATH")"

    [ "$XCPKG_FORMULA_REPO_URL" = null ] && abort 1 "$1 formula repository is broken."

    XCPKG_FORMULA_REPO_BRANCH="$(yq .branch "$XCPKG_FORMULA_REPO_CONFIG_FILEPATH")"

    [ "$XCPKG_FORMULA_REPO_BRANCH" = null ] && abort 1 "$1 formula repository is broken."

    XCPKG_FORMULA_REPO_PINNED="$(yq .pinned "$XCPKG_FORMULA_REPO_CONFIG_FILEPATH")"

    case $XCPKG_FORMULA_REPO_PINNED in
        0|1) ;;
        *)   abort 1 "$1 formula repository is broken."
    esac

    XCPKG_FORMULA_REPO_ENABLED="$(yq .enabled "$XCPKG_FORMULA_REPO_CONFIG_FILEPATH")"

    case $XCPKG_FORMULA_REPO_ENABLED in
        0|1) ;;
        *)   abort 1 "$1 formula repository is broken."
    esac

    XCPKG_FORMULA_REPO_TIMESTAMP_CREATED="$(yq .timestamp-created "$XCPKG_FORMULA_REPO_CONFIG_FILEPATH")"

    [ "${#XCPKG_FORMULA_REPO_TIMESTAMP_CREATED}" -eq 10 ] || abort 1 "$1 formula repository is broken."

    XCPKG_FORMULA_REPO_TIMESTAMP_UPDATED="$(yq .timestamp-updated "$XCPKG_FORMULA_REPO_CONFIG_FILEPATH")"

    if [ "$XCPKG_FORMULA_REPO_TIMESTAMP_UPDATED" = null ] ; then
           XCPKG_FORMULA_REPO_TIMESTAMP_UPDATED=
    else
        [ "${#XCPKG_FORMULA_REPO_TIMESTAMP_UPDATED}" -eq 10 ] || abort 1 "$1 formula repository is broken."
    fi
}

# }}}
##############################################################################
# {{{ xcpkg formula-repo-add

# __create_a_formula_repository_then_sync_it <REPO-NAME> <REPO-URL> [--branch=VALUE --pin/--unpin --enable/--disable]
  __create_a_formula_repository_then_sync_it() {
    [ -z "$1" ] && abort 1 "please specify a repository name."
    [ -z "$2" ] && abort 1 "please specify a repository url."

    XCPKG_FORMULA_REPO_NAME="$1"
    XCPKG_FORMULA_REPO_URL="$2"

    if [ -z "$XCPKG_URL_TRANSFORM" ] ; then
        GIT_FETCH_URL="$XCPKG_FORMULA_REPO_URL"
    else
        GIT_FETCH_URL="$("$XCPKG_URL_TRANSFORM" "$XCPKG_FORMULA_REPO_URL")"
    fi

    shift 2

    XCPKG_FORMULA_REPO_BRANCH=
    XCPKG_FORMULA_REPO_PINNED=
    XCPKG_FORMULA_REPO_ENABLED=

    while [ -n "$1" ]
    do
        case $1 in
            --branch=*)
                XCPKG_FORMULA_REPO_BRANCH="${1#*=}"
                ;;
            --pin)
                XCPKG_FORMULA_REPO_PINNED=1
                ;;
            --unpin)
                XCPKG_FORMULA_REPO_PINNED=0
                ;;
            --enable)
                XCPKG_FORMULA_REPO_ENABLED=1
                ;;
            --disable)
                XCPKG_FORMULA_REPO_ENABLED=0
                ;;
            *)  abort 1 "unrecognized argument: $1"
        esac
        shift
    done

    XCPKG_FORMULA_REPO_BRANCH="${XCPKG_FORMULA_REPO_BRANCH:-master}"
    XCPKG_FORMULA_REPO_PINNED="${XCPKG_FORMULA_REPO_PINNED:-0}"
    XCPKG_FORMULA_REPO_ENABLED="${XCPKG_FORMULA_REPO_ENABLED:-1}"

    XCPKG_FORMULA_REPO_PATH="$XCPKG_HOME/repos.d/$XCPKG_FORMULA_REPO_NAME"

    [ -d "$XCPKG_FORMULA_REPO_PATH" ] && abort 1 "'$XCPKG_FORMULA_REPO_NAME' formula repository already exists."

    printf '%b\n' "${COLOR_PURPLE}==> Adding formula repository${COLOR_OFF} ${COLOR_GREEN}$XCPKG_FORMULA_REPO_NAME${COLOR_OFF}"

    run install -d "$XCPKG_FORMULA_REPO_PATH"

    __create_a_formula_repository_then_sync_it_onexit() {
        if [ ! -f  "$XCPKG_FORMULA_REPO_PATH/.xcpkg-formula-repo.yml" ] ; then
            rm -rf "$XCPKG_FORMULA_REPO_PATH/"
        fi
    }

    trap __create_a_formula_repository_then_sync_it_onexit EXIT

    run cd "$XCPKG_FORMULA_REPO_PATH"

    run git -c init.defaultBranch=master init
    run git remote add origin "$GIT_FETCH_URL"
    run git -c protocol.version=2 fetch --progress origin "+refs/heads/$XCPKG_FORMULA_REPO_BRANCH:refs/remotes/origin/$XCPKG_FORMULA_REPO_BRANCH"
    run git checkout --progress --force -B "$XCPKG_FORMULA_REPO_BRANCH" "refs/remotes/origin/$XCPKG_FORMULA_REPO_BRANCH"

    cat > .xcpkg-formula-repo.yml <<EOF
url: $XCPKG_FORMULA_REPO_URL
branch: $XCPKG_FORMULA_REPO_BRANCH
pinned: $XCPKG_FORMULA_REPO_PINNED
enabled: $XCPKG_FORMULA_REPO_ENABLED
timestamp-created: $TIMESTAMP_UNIX
EOF
}

# }}}
##############################################################################
# {{{ xcpkg formula-repo-init

# __create_a_formula_repository <REPO-NAME> <REPO-URL> [--branch=VALUE --pin/--unpin --enable/--disable]
  __create_a_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."
    [ -z "$2" ] && abort 1 "please specify a repository url."

    XCPKG_FORMULA_REPO_NAME="$1"

    if [ -z "$XCPKG_URL_TRANSFORM" ] ; then
        XCPKG_FORMULA_REPO_URL="$2"
    else
        XCPKG_FORMULA_REPO_URL="$("$XCPKG_URL_TRANSFORM" "$2")"
    fi

    shift 2

    XCPKG_FORMULA_REPO_BRANCH=
    XCPKG_FORMULA_REPO_PINNED=
    XCPKG_FORMULA_REPO_ENABLED=

    while [ -n "$1" ]
    do
        case $1 in
            --branch=*)
                XCPKG_FORMULA_REPO_BRANCH="${1#*=}"
                ;;
            --pin)
                XCPKG_FORMULA_REPO_PINNED=1
                ;;
            --unpin)
                XCPKG_FORMULA_REPO_PINNED=0
                ;;
            --enable)
                XCPKG_FORMULA_REPO_ENABLED=1
                ;;
            --disable)
                XCPKG_FORMULA_REPO_ENABLED=0
                ;;
            *)  abort 1 "unrecognized argument: $1"
        esac
        shift
    done

    XCPKG_FORMULA_REPO_BRANCH="${XCPKG_FORMULA_REPO_BRANCH:-master}"
    XCPKG_FORMULA_REPO_PINNED="${XCPKG_FORMULA_REPO_PINNED:-1}"
    XCPKG_FORMULA_REPO_ENABLED="${XCPKG_FORMULA_REPO_ENABLED:-1}"

    XCPKG_FORMULA_REPO_PATH="$XCPKG_HOME/repos.d/$XCPKG_FORMULA_REPO_NAME"

    [ -d "$XCPKG_FORMULA_REPO_PATH" ] && abort 1 "'$XCPKG_FORMULA_REPO_NAME' formula repository already exists."

    printf '%b\n' "${COLOR_PURPLE}==> Creating formula repository${COLOR_OFF} ${COLOR_GREEN}$XCPKG_FORMULA_REPO_NAME${COLOR_OFF}"

    run install -d "$XCPKG_FORMULA_REPO_PATH"

    run cd "$XCPKG_FORMULA_REPO_PATH"

    run git -c init.defaultBranch=master init
    run git remote add origin "$XCPKG_FORMULA_REPO_URL"

    cat > .xcpkg-formula-repo.yml <<EOF
url: $XCPKG_FORMULA_REPO_URL
branch: $XCPKG_FORMULA_REPO_BRANCH
pinned: $XCPKG_FORMULA_REPO_PINNED
enabled: $XCPKG_FORMULA_REPO_ENABLED
timestamp-created: $TIMESTAMP_UNIX
EOF
}

# }}}
##############################################################################
# {{{ xcpkg formula-repo-del

# __delete_a_formula_repository <REPO-NAME>
  __delete_a_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."

    [ "$1" = 'offical-core' ] && abort 1 "'offical-core' formula repository is not allowed to delete."

    if [ -d    "$XCPKG_HOME/repos.d/$1" ] ; then
        rm -rf "$XCPKG_HOME/repos.d/$1"
    else
        abort 1 "'$1' formula repository does not exist."
    fi
}

# }}}
##############################################################################
# {{{ xcpkg formula-repo-sync

# __sync_the_given_formula_repository <REPO-NAME>
  __sync_the_given_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."

    __load_formula_repository_config "$1"

    [ "$XCPKG_FORMULA_REPO_PINNED" = 1 ] && abort 1 "'$XCPKG_FORMULA_REPO_NAME' formula repository is pinned."

    if [ -z "$XCPKG_URL_TRANSFORM" ] ; then
        GIT_FETCH_URL="$XCPKG_FORMULA_REPO_URL"
    else
        GIT_FETCH_URL="$("$XCPKG_URL_TRANSFORM" "$XCPKG_FORMULA_REPO_URL")"
    fi

    printf '%b\n' "${COLOR_PURPLE}==> Updating formula repository${COLOR_OFF} ${COLOR_GREEN}$XCPKG_FORMULA_REPO_NAME${COLOR_OFF}"

    run cd "$XCPKG_FORMULA_REPO_PATH"
    run git remote set-url origin "$GIT_FETCH_URL"
    run git -c protocol.version=2 fetch --progress origin "+refs/heads/$XCPKG_FORMULA_REPO_BRANCH:refs/remotes/origin/$XCPKG_FORMULA_REPO_BRANCH"
    run git checkout --progress --force -B "$XCPKG_FORMULA_REPO_BRANCH" "refs/remotes/origin/$XCPKG_FORMULA_REPO_BRANCH"

    cat > .xcpkg-formula-repo.yml <<EOF
url: $XCPKG_FORMULA_REPO_URL
branch: $XCPKG_FORMULA_REPO_BRANCH
pinned: $XCPKG_FORMULA_REPO_PINNED
enabled: $XCPKG_FORMULA_REPO_ENABLED
timestamp-created: $XCPKG_FORMULA_REPO_TIMESTAMP_CREATED
timestamp-updated: $TIMESTAMP_UNIX
EOF
}

# }}}
##############################################################################
# {{{ xcpkg formula-repo-conf

# __conf_the_given_formula_repository <REPO-NAME> [--url=VALUE --branch=VALUE --pin/--unpin --enable/--disable]
  __conf_the_given_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."
    [ -z "$2" ] && abort 1 "at least one option should be given. supported options are: --url=VALUE --branch=VALUE --pin/--unpin --enable/--disable"

    __load_formula_repository_config "$1"

    shift

    while [ -n "$1" ]
    do
        case $1 in
            --url=*)
                FORMULA_REPO_URL="${1#*=}"

                if [ -z "$FORMULA_REPO_URL" ] ; then
                    abort 1 "--url=<VALUE> , <VALUE> should be non-empty."
                else
                    XCPKG_FORMULA_REPO_URL="$FORMULA_REPO_URL"
                fi
                ;;
            --branch=*)
                FORMULA_REPO_BRANCH="${1#*=}"

                if [ -z "$FORMULA_REPO_BRANCH" ] ; then
                    abort 1 "--branch=<VALUE> , <VALUE> should be non-empty."
                else
                    XCPKG_FORMULA_REPO_BRANCH="$FORMULA_REPO_BRANCH"
                fi
                ;;
            --pin)
                XCPKG_FORMULA_REPO_PINNED=1
                ;;
            --unpin)
                XCPKG_FORMULA_REPO_PINNED=0
                ;;
            --enable)
                XCPKG_FORMULA_REPO_ENABLED=1
                ;;
            --disable)
                XCPKG_FORMULA_REPO_ENABLED=0
                ;;
            *)  abort 1 "unrecognized argument: $1"
        esac
        shift
    done

    if [ -z "$XCPKG_FORMULA_REPO_TIMESTAMP_UPDATED" ] ; then
        cat > "$XCPKG_FORMULA_REPO_PATH/.xcpkg-formula-repo.yml" <<EOF
url:  $XCPKG_FORMULA_REPO_URL
branch: $XCPKG_FORMULA_REPO_BRANCH
pinned: $XCPKG_FORMULA_REPO_PINNED
enabled: $XCPKG_FORMULA_REPO_ENABLED
timestamp-created: $XCPKG_FORMULA_REPO_TIMESTAMP_CREATED
EOF
    else
        cat > "$XCPKG_FORMULA_REPO_PATH/.xcpkg-formula-repo.yml" <<EOF
url:  $XCPKG_FORMULA_REPO_URL
branch: $XCPKG_FORMULA_REPO_BRANCH
pinned: $XCPKG_FORMULA_REPO_PINNED
enabled: $XCPKG_FORMULA_REPO_ENABLED
timestamp-created: $XCPKG_FORMULA_REPO_TIMESTAMP_CREATED
timestamp-updated: $XCPKG_FORMULA_REPO_TIMESTAMP_UPDATED
EOF
fi
}

# }}}
##############################################################################
# {{{ xcpkg formula-repo-info

# __info_the_given_formula_repository <REPO-NAME>
  __info_the_given_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."

    __load_formula_repository_config "$1"

    case $XCPKG_FORMULA_REPO_PINNED in
        0)  XCPKG_FORMULA_REPO_PINNED=no  ;;
        1)  XCPKG_FORMULA_REPO_PINNED=yes ;;
    esac

    case $XCPKG_FORMULA_REPO_ENABLED in
        0)  XCPKG_FORMULA_REPO_ENABLED=no  ;;
        1)  XCPKG_FORMULA_REPO_ENABLED=yes ;;
    esac

    cat <<EOF
name: $XCPKG_FORMULA_REPO_NAME
path: $XCPKG_FORMULA_REPO_PATH
url:  $XCPKG_FORMULA_REPO_URL
branch: $XCPKG_FORMULA_REPO_BRANCH
pinned: $XCPKG_FORMULA_REPO_PINNED
enabled: $XCPKG_FORMULA_REPO_ENABLED
timestamp-created: $(format_unix_timestamp "$XCPKG_FORMULA_REPO_TIMESTAMP_CREATED" '+%Y-%m-%d %H:%M:%S%:z')
EOF

    if [ -n "$XCPKG_FORMULA_REPO_TIMESTAMP_UPDATED" ] ; then
        printf 'timestamp-updated: %s\n' "$(format_unix_timestamp "$XCPKG_FORMULA_REPO_TIMESTAMP_UPDATED" '+%Y-%m-%d %H:%M:%S%:z')"
    fi
}

# }}}
##############################################################################
# {{{ xcpkg update

__sync_available_formula_repositories() {
    [ -d "$XCPKG_FORMULA_REPO_ROOT" ] && {
        for item in $(cd "$XCPKG_FORMULA_REPO_ROOT" && ls)
        do
            if [ -f "$XCPKG_FORMULA_REPO_ROOT/$item/.xcpkg-formula-repo.yml" ] ; then
                __sync_the_given_formula_repository "$item"
            fi
        done
    }

    [ -d "$XCPKG_FORMULA_REPO_ROOT/offical-core" ] || {
        __create_a_formula_repository_then_sync_it offical-core "$XCPKG_OFFICAL_FORMULA_REPO_URL"
    }
}

# }}}
##############################################################################
# {{{ xcpkg formula-repo-list

__list_available_formula_repositories() {
    [ -d "$XCPKG_FORMULA_REPO_ROOT" ] || return 0

    for item in $(cd "$XCPKG_FORMULA_REPO_ROOT" && ls)
    do
        if [ -f "$XCPKG_FORMULA_REPO_ROOT/$item/.xcpkg-formula-repo.yml" ] ; then
            __info_the_given_formula_repository "$item"
        fi
    done
}

# __path_of_formula_of_the_given_package <PACKAGE-NAME>
  __path_of_formula_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__path_of_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."

    [ -d "$XCPKG_FORMULA_REPO_ROOT" ] || return 0

    AVAILABLE_FORMULA_REPOSITORY_NAMES=

    for item in $(cd "$XCPKG_FORMULA_REPO_ROOT" && ls)
    do
        if [ -f "$XCPKG_FORMULA_REPO_ROOT/$item/.xcpkg-formula-repo.yml" ] ; then
            AVAILABLE_FORMULA_REPOSITORY_NAMES="$AVAILABLE_FORMULA_REPOSITORY_NAMES $item"
        fi
    done

    for FORMULA_REPOSITORY_NAME in $AVAILABLE_FORMULA_REPOSITORY_NAMES
    do
        if [ -e           "$XCPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$NATIVE_OS_TYPE/$1.yml" ] ; then
            printf '%s\n' "$XCPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$NATIVE_OS_TYPE/$1.yml"
            return 0
        fi

        if [ -e           "$XCPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$1.yml" ] ; then
            printf '%s\n' "$XCPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$1.yml"
            return 0
        fi
    done
}


# }}}
##############################################################################
# {{{ operations of formula

get_file_extension_from_url() {
    unset URL
    URL="$(printf '%s\n' "$1" | sed 's|\?.*||')"

    unset EXT
    EXT="$(printf '%s\n' "$URL" | sed 's|.*\(\.[^.]\+$\)|\1|g')"

    case $EXT in
        .gz)  printf '%s\n' '.tgz' ;;
        .lz)  printf '%s\n' '.tlz' ;;
        .xz)  printf '%s\n' '.txz' ;;
        .bz2) printf '%s\n' '.tbz2' ;;
        *)    printf '%s\n' "$EXT" ;;
    esac
}

# __load_formula_of_the_given_package <PACKAGE-NAME> [FORMULA-FILEPATH]
  __load_formula_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__load_formula_of_the_given_package <PACKAGE-NAME> [FORMULA-FILEPATH], <PACKAGE-NAME> is unspecified."

    unset PACKAGE_FORMULA_FILEPATH

    unset PACKAGE_FORMULA_LOADED

    unset PACKAGE_NAME
    unset PACKAGE_NAME_UPPERCASE_UNDERSCORE

    unset PACKAGE_SUMMARY
    unset PACKAGE_WEB_URL

    unset PACKAGE_GIT_URL
    unset PACKAGE_GIT_SHA
    unset PACKAGE_GIT_REF
    unset PACKAGE_SHALLOW

    unset PACKAGE_SVN_URL

    unset PACKAGE_SRC_URL
    unset PACKAGE_SRC_URI
    unset PACKAGE_SRC_SHA
    unset PACKAGE_SRC_FILENAME
    unset PACKAGE_SRC_FILETYPE
    unset PACKAGE_SRC_FILEPATH

    unset PACKAGE_FIX_URL
    unset PACKAGE_FIX_SHA
    unset PACKAGE_FIX_FILENAME
    unset PACKAGE_FIX_FILETYPE
    unset PACKAGE_FIX_FILEPATH

    unset PACKAGE_RES_URL
    unset PACKAGE_RES_SHA
    unset PACKAGE_RES_FILENAME
    unset PACKAGE_RES_FILETYPE
    unset PACKAGE_RES_FILEPATH

    unset PACKAGE_VERSION
    unset PACKAGE_VERSION_MAJOR
    unset PACKAGE_VERSION_MINOR
    unset PACKAGE_VERSION_PATCH
    unset PACKAGE_VERSION_TWEAK

    unset PACKAGE_DEVELOPER

    unset PACKAGE_LICENSE

    unset PACKAGE_BSYSTEM

    unset PACKAGE_SYMLINK

    unset PACKAGE_BUILD_SYSTEM
    unset PACKAGE_BUILD_SYSTEM_GO
    unset PACKAGE_BUILD_SYSTEM_RAKE
    unset PACKAGE_BUILD_SYSTEM_NINJA
    unset PACKAGE_BUILD_SYSTEM_GMAKE
    unset PACKAGE_BUILD_SYSTEM_CMAKE
    unset PACKAGE_BUILD_SYSTEM_XMAKE
    unset PACKAGE_BUILD_SYSTEM_MESON
    unset PACKAGE_BUILD_SYSTEM_CARGO
    unset PACKAGE_BUILD_SYSTEM_AUTOGENSH
    unset PACKAGE_BUILD_SYSTEM_AUTOTOOLS
    unset PACKAGE_BUILD_SYSTEM_CONFIGURE
    unset PACKAGE_BUILD_SYSTEM_NDK_BUILD

    # dir relative to $PACKAGE_WORKING_DIR, which contains build script such as autogen.sh, configure, Makefile, CMakeLists.txt, meson.build, Cargo.toml, xmake.lua, etc.
    unset PACKAGE_BSCRIPT

    # if build in build script dir, otherwise build in build dir
    unset PACKAGE_BINBSTD
    unset PACKAGE_BUILD_IN_BSCRIPT_DIR

    # if build in parallel
    unset PACKAGE_BUILD_IN_PARALLEL
    unset PACKAGE_PARALLEL

    # space-separated    perl modules that are depended by this package when installing and/or runtime, which will be installed via cpan
    unset PACKAGE_DEP_PLM

    # space-separated python packages that are depended by this package when installing and/or runtime, which will be installed via pip3
    unset PACKAGE_DEP_PYM

    # space-separated   xcpkg packages that are depended by this package when installing and/or runtime, which will be installed via uppm
    unset PACKAGE_DEP_UPP

    # space-separated   xcpkg packages that are depended by this package when installing and/or runtime, which will be installed via xcpkg
    unset PACKAGE_DEP_PKG

    unset PACKAGE_CCFLAGS
    unset PACKAGE_XXFLAGS
    unset PACKAGE_PPFLAGS
    unset PACKAGE_LDFLAGS

    unset PACKAGE_FORMULA_FILEPATH

    unset -f dopatch
    unset -f dobuild

    #########################################################################################

    if [ -z "$2" ] ; then
        PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package "$1")" || abort 1 "package [$1] is not available."
    else
        PACKAGE_FORMULA_FILEPATH="$2"
    fi

    #########################################################################################

    for key in summary web-url git-url git-sha git-ref shallow src-url src-uri src-sha fix-url fix-sha res-url res-sha dep-pkg dep-upp dep-pym dep-plm license version bsystem bscript binbstd ccflags xxflags ppflags ldflags parallel toolset cstdlib exetype symlink
    do
        unset __KEY_UPPERCASE_UNDERSCORE__
        unset __VALUE__

        __KEY_UPPERCASE_UNDERSCORE__="$(printf '%s\n' "$key" | tr '-' '_' | tr a-z A-Z)"
        __VALUE__="$(yq ".$key" "$PACKAGE_FORMULA_FILEPATH")"

        if [ "$__VALUE__" = null ] ; then
               __VALUE__=
        fi

        eval "PACKAGE_$__KEY_UPPERCASE_UNDERSCORE__='$__VALUE__'"
    done

    #########################################################################################

    PACKAGE_BUILD0_ACTIONS=
    PACKAGE_BUILD0_ACTIONS="$(yq '.build0   | select(. != null)'  "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_DOPATCH_ACTIONS=
    PACKAGE_DOPATCH_ACTIONS="$(yq '.dopatch | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_DOBUILD_ACTIONS=
    PACKAGE_DOBUILD_ACTIONS="$(yq '.install | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    if [ -z "$PACKAGE_BSYSTEM" ] && [ -n "$PACKAGE_DOBUILD_ACTIONS" ] ; then
        for FirstWordOfLineInInstallActions in $(printf '%s\n' "$PACKAGE_DOBUILD_ACTIONS" | sed 's|^[ ]*||' | cut -d ' ' -f1)
        do
            case "$FirstWordOfLineInInstallActions" in
                configure)    PACKAGE_BSYSTEM=configure ; break ;;
                cmakew)       PACKAGE_BSYSTEM=cmake ; break ;;
                xmakew)       PACKAGE_BSYSTEM=xmake ; break ;;
                mesonw)       PACKAGE_BSYSTEM=meson ; break ;;
                gmakew)       PACKAGE_BSYSTEM=gmake ; break ;;
                cargow)       PACKAGE_BSYSTEM=cargo ; break ;;
                go|gow)       PACKAGE_BSYSTEM=go    ; break ;;
            esac
        done
    fi

    #########################################################################################

    PACKAGE_NAME="$1"
    PACKAGE_NAME_UPPERCASE_UNDERSCORE="$(printf '%s\n' "$PACKAGE_NAME" | tr a-z A-Z | tr '@+-.' '_')"

    PACKAGE_BUILD_SYSTEM=$PACKAGE_BSYSTEM

    if [ -z "$PACKAGE_SYMLINK" ] ; then
        PACKAGE_SYMLINK=yes
    fi

    if [ -z "$PACKAGE_BINBSTD" ] ; then
        PACKAGE_BINBSTD=no
        PACKAGE_BUILD_IN_BSCRIPT_DIR=no
    else
        PACKAGE_BUILD_IN_BSCRIPT_DIR=$PACKAGE_BINBSTD
    fi

    if [ -z "$PACKAGE_PARALLEL" ] ; then
        PACKAGE_PARALLEL=yes
        PACKAGE_BUILD_IN_PARALLEL=yes
    else
        PACKAGE_BUILD_IN_PARALLEL="$PACKAGE_PARALLEL"
    fi

    if [ -z "$PACKAGE_SUMMARY" ] ; then
        abort 1 "summary mapping was not found in $PACKAGE_FORMULA_FILEPATH"
    fi

    if [ -z "$PACKAGE_WEB_URL" ] && [ -z "$PACKAGE_GIT_URL" ] ; then
        abort 1 "web-url or git-url mapping was not found in $PACKAGE_FORMULA_FILEPATH"
    fi

    if [ -z "$PACKAGE_SRC_URL" ] ; then
        if [ -z "$PACKAGE_GIT_URL" ] ; then
            abort 1 "src-url or git-url mapping was not found in $PACKAGE_FORMULA_FILEPATH"
        else
            PACKAGE_SRC_FILETYPE=.git
            PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP git"
        fi
    else
        case $PACKAGE_SRC_URL in
            dir://*)
                PACKAGE_SRC_FILETYPE=.dir ;;
            *)  PACKAGE_SRC_FILETYPE="$(get_file_extension_from_url "$PACKAGE_SRC_URL")"

                case $PACKAGE_SRC_FILETYPE in
                    .zip)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl unzip"      ;;
                    .txz)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar xz"    ;;
                    .tgz)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar gzip"  ;;
                    .tlz)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar lzip"  ;;
                    .tbz2)    PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar bzip2" ;;
                    *)        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl"            ;;
                esac
        esac
    fi

    case $PACKAGE_SRC_FILETYPE in
        .dir)
            PACKAGE_SRC_FILEPATH=$(printf '%s\n' "$PACKAGE_SRC_URL" | cut -c7-)

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(format_unix_timestamp "$TIMESTAMP_UNIX" '+%Y.%m.%d')"
            fi
            ;;
        .git)
            PACKAGE_SRC_FILENAME="$PACKAGE_NAME.git"
            PACKAGE_SRC_FILEPATH="$XCPKG_DOWNLOADS_DIR/$PACKAGE_SRC_FILENAME"

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(format_unix_timestamp "$TIMESTAMP_UNIX" '+%Y.%m.%d')"
            fi
            ;;
        *)
            if [ -z "$PACKAGE_SRC_SHA" ] ; then
                abort 1 "src-sha mapping was not found in $PACKAGE_FORMULA_FILEPATH"
            fi

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(basename "$PACKAGE_SRC_URL" | tr '_@' - | sed -e 's|\.tar\.[glx]z$||' -e 's|\.tar\.bz2$||' -e 's|\.t[glx]z$||' -e 's|\.zip$||' -e 's|-stable||' -e 's|-source||' -e 's|[-.]src$||' -e 's|\.orig||' | awk -F- '{print $NF}')"
                case $PACKAGE_VERSION in
                    '') abort 1 "version mapping was not found in $PACKAGE_FORMULA_FILEPATH" ;;
                    v*) PACKAGE_VERSION=$(printf '%s\n' "$PACKAGE_VERSION" | cut -c2-)
                esac
            fi

            PACKAGE_SRC_FILENAME="$PACKAGE_SRC_SHA$PACKAGE_SRC_FILETYPE"
            PACKAGE_SRC_FILEPATH="$XCPKG_DOWNLOADS_DIR/$PACKAGE_SRC_FILENAME"
    esac

    [ -n "$PACKAGE_FIX_URL" ] && {
        [ -z "$PACKAGE_FIX_SHA" ] && abort 1 "fix-sha mapping was not found in $PACKAGE_FORMULA_FILEPATH"

        PACKAGE_FIX_FILETYPE="$(get_file_extension_from_url "$PACKAGE_FIX_URL")"

        case $PACKAGE_FIX_FILETYPE in
            .diff)  PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"            ;;
            .patch) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"            ;;
            .zip)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch unzip"      ;;
            .txz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar xz"    ;;
            .tgz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar gzip"  ;;
            .tlz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar lzip"  ;;
            .tbz2)  PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar bzip2" ;;
        esac

        PACKAGE_FIX_FILENAME="$PACKAGE_FIX_SHA$PACKAGE_FIX_FILETYPE"
        PACKAGE_FIX_FILEPATH="$XCPKG_DOWNLOADS_DIR/$PACKAGE_FIX_FILENAME"
    }

    [ -n "$PACKAGE_RES_URL" ] && {
        [ -z "$PACKAGE_RES_SHA" ] && abort 1 "res-sha mapping was not found in $PACKAGE_FORMULA_FILEPATH"

        PACKAGE_RES_FILETYPE="$(get_file_extension_from_url "$PACKAGE_RES_URL")"

        case $PACKAGE_RES_FILETYPE in
            .diff)  PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"            ;;
            .patch) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"            ;;
            .zip)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch unzip"      ;;
            .txz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar xz"    ;;
            .tgz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar gzip"  ;;
            .tlz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar lzip"  ;;
            .tbz2)  PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar bzip2" ;;
        esac

        PACKAGE_RES_FILENAME="$PACKAGE_RES_SHA$PACKAGE_RES_FILETYPE"
        PACKAGE_RES_FILEPATH="$XCPKG_DOWNLOADS_DIR/$PACKAGE_RES_FILENAME"
    }

    #########################################################################################

    [ -n "$PACKAGE_VERSION" ] && {
        PACKAGE_VERSION_MAJOR="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f1)"
        PACKAGE_VERSION_MINOR="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f2)"
        PACKAGE_VERSION_PATCH="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f3)"
        PACKAGE_VERSION_TWEAK="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f4)"
    }

    #########################################################################################

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            autogen)     PACKAGE_BUILD_SYSTEM_AUTOGENSH=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            autotools)   PACKAGE_BUILD_SYSTEM_AUTOTOOLS=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            configure)   PACKAGE_BUILD_SYSTEM_CONFIGURE=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            cmake-gmake) PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            cmake-ninja) PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            cmake)       PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            xmake)       PACKAGE_BUILD_SYSTEM_XMAKE=yes     ;;
            meson)       PACKAGE_BUILD_SYSTEM_MESON=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            ninja)       PACKAGE_BUILD_SYSTEM_NINJA=yes     ;;
            gmake)       PACKAGE_BUILD_SYSTEM_GMAKE=yes     ;;
            rake)        PACKAGE_BUILD_SYSTEM_RAKE=yes      ;;
            cargo)       PACKAGE_BUILD_SYSTEM_CARGO=yes     ;;
            go)          PACKAGE_BUILD_SYSTEM_GO=yes        ;;
        esac
    done

    #########################################################################################

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            autogen)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP automake autoconf perl gm4 gmake" ;;
            autotools)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP automake autoconf perl gm4 gmake" ;;
            configure)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP gmake"  ;;
            cmake-gmake) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake gmake"  ;;
            cmake-ninja) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake ninja"  ;;
            cmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake ninja"  ;;
            xmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP xmake"  ;;
            meson)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ninja"  ;;
            ninja)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ninja"  ;;
            gmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP gmake"  ;;
            rake)        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ruby"   ;;
            go)          PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP golang" ;;
        esac
    done

    #########################################################################################

    [ -z "$PACKAGE_DOBUILD_ACTIONS" ] && {
        case $PACKAGE_BUILD_SYSTEM in
            autogen)   PACKAGE_DOBUILD_ACTIONS='configure' ;;
            autotools) PACKAGE_DOBUILD_ACTIONS='configure' ;;
            configure) PACKAGE_DOBUILD_ACTIONS='configure' ;;
            cmake*)    PACKAGE_DOBUILD_ACTIONS='cmakew' ;;
            xmake)     PACKAGE_DOBUILD_ACTIONS='xmakew' ;;
            meson)     PACKAGE_DOBUILD_ACTIONS='mesonw' ;;
            ninja)     PACKAGE_DOBUILD_ACTIONS='ninjaw clean && ninjaw && ninjaw install' ;;
            gmake)     PACKAGE_DOBUILD_ACTIONS='gmakew clean && gmakew && gmakew install' ;;
            cargo)     PACKAGE_DOBUILD_ACTIONS='cargow install' ;;
            go)        PACKAGE_DOBUILD_ACTIONS='gow' ;;
            *)         abort 1 "install mapping not found in $PACKAGE_FORMULA_FILEPATH"
        esac
    }

    #########################################################################################

    [ "$PACKAGE_BUILD_SYSTEM_MESON" = yes ] && {
        PACKAGE_DEP_PYM="$PACKAGE_DEP_PYM meson"
    }

    [ -n "$PACKAGE_DEP_PYM" ] && {
        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP python3"
    }

    [ -n "$PACKAGE_DEP_PLM" ] && {
        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP perl"
    }

    [ "$PACKAGE_BUILD_SYSTEM_GO" = yes ] && {
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    }

    [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] && {
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    }

    [ "$PACKAGE_BUILD_SYSTEM_XMAKE" = yes ] && {
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    }

    PACKAGE_DEP_UPP="${PACKAGE_DEP_UPP#' '}"

    PACKAGE_FORMULA_LOADED=yes
}

# }}}
##############################################################################
# {{{ xcpkg formula

# __show_formula_of_the_given_package <PACKAGE-NAME> [--json] [--yaml] [--path] [<KEY>]
  __show_formula_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__show_formula_of_the_given_package <PACKAGE-NAME> [--json] [--yaml] [--path] [<KEY>], <PACKAGE-NAME> is unspecified."

    PACKAGE_FORMULA_FILEPATH=
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package "$1")"

    [ -z "$PACKAGE_FORMULA_FILEPATH" ] && abort 1 "package '$1' is not available."

    case $2 in
        --yaml|'')
            if [ -t 1 ] ; then
                yq  "$PACKAGE_FORMULA_FILEPATH"
            else
                cat "$PACKAGE_FORMULA_FILEPATH"
            fi
            ;;
        --json)
            yq -o=json "$PACKAGE_FORMULA_FILEPATH"
            ;;
        --path)
            printf '%s\n' "$PACKAGE_FORMULA_FILEPATH"
            ;;
        *)  yq ".$2 | select(. != null)" "$PACKAGE_FORMULA_FILEPATH"
    esac
}

# }}}
##############################################################################
# {{{ xcpkg formula-edit

# __edit_formula_of_the_given_package <PACKAGE-NAME> [--editor=<EDITOR>]
  __edit_formula_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__edit_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."

    unset  PACKAGE_FORMULA_FILEPATH; PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package "$1")"

    [ -z "$PACKAGE_FORMULA_FILEPATH" ] && abort 1 "package '$1' is not available."

    shift

    EDITOR=

    while [ -n "$1" ]
    do
        case $1 in
            --editor=*)
                EDITOR="${1#*=}"
                ;;
            *)  abort 1 "unrecognized option: $1"
        esac
        shift
    done

    [ -z "$EDITOR" ] && {
        EDITOR=$(command -v nvim || command -v vim || command -v vi || command -v open) || abort 1 "please sepecify editor via [--editor=<EDITOR> option."
    }

    "$EDITOR" "$PACKAGE_FORMULA_FILEPATH"
}

# }}}
##############################################################################
# {{{ operations of receipt

# __generate_receipt_of_the_given_package <PACKAGE-NAME>
  __generate_receipt_of_the_given_package() {
    [ -z "$1" ] && {
        error "__generate_receipt_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."
        return 1
    }

    run cp "$PACKAGE_FORMULA_FILEPATH" "$PACKAGE_RECEIPT_FILEPATH"

    sed_in_place '/^#src-url: dir:/d' "$PACKAGE_RECEIPT_FILEPATH"

    sed_in_place "1i pkgname: $PACKAGE_NAME" "$PACKAGE_RECEIPT_FILEPATH"

    grep -q '^version: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "2i version: $PACKAGE_VERSION" "$PACKAGE_RECEIPT_FILEPATH"
    }

    grep -q '^web-url: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "/^git-url:/i web-url: $PACKAGE_GIT_URL" "$PACKAGE_RECEIPT_FILEPATH"
    }

    grep -q '^bsystem: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "/^install:/i bsystem: $PACKAGE_BSYSTEM" "$PACKAGE_RECEIPT_FILEPATH"
    }

    grep -q '^binbstd: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "/^bsystem:/a binbstd: $PACKAGE_BINBSTD" "$PACKAGE_RECEIPT_FILEPATH"
    }

    grep -q '^parallel: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "\$a parallel: $PACKAGE_PARALLEL" "$PACKAGE_RECEIPT_FILEPATH"
    }

    [ -n "$PACKAGE_GIT_SHA" ] && {
        grep -q '^git-sha: ' "$PACKAGE_RECEIPT_FILEPATH" || {
            sed_in_place "/^git-url:/a git-sha: $PACKAGE_GIT_SHA" "$PACKAGE_RECEIPT_FILEPATH"
        }

        grep -q '^git-sha: ' "$PACKAGE_RECEIPT_FILEPATH" || {
            sed_in_place "3i git-sha: $PACKAGE_GIT_SHA" "$PACKAGE_RECEIPT_FILEPATH"
        }
    }

    [ -n "$PACKAGE_DEP_UPP" ] && {
        if grep -q '^dep-upp: ' "$PACKAGE_RECEIPT_FILEPATH" ; then
            sed_in_place "/^dep-upp: /c dep-upp: $PACKAGE_DEP_UPP" "$PACKAGE_RECEIPT_FILEPATH"
        else
            sed_in_place "/^bsystem: /i dep-upp: $PACKAGE_DEP_UPP" "$PACKAGE_RECEIPT_FILEPATH"
        fi
    }

    cat >> "$PACKAGE_RECEIPT_FILEPATH" <<EOF
build-on:
    os-arch: $NATIVE_OS_ARCH
    os-kind: $NATIVE_OS_KIND
    os-type: $NATIVE_OS_TYPE
    os-name: $NATIVE_OS_NAME
    os-vers: $NATIVE_OS_VERS
    os-ncpu: $NATIVE_OS_NCPU
    os-euid: $NATIVE_OS_EUID
    os-egid: $NATIVE_OS_EGID
built-for: $TARGET_PLATFORM_NAME/$TARGET_PLATFORM_VERS/$TARGET_PLATFORM_ARCH
signature: xcpkg-$PPKG_VERSION
timestamp: $TIMESTAMP_UNIX
EOF
}

# __load_receipt_of_the_given_package <PACKAGE-SPEC>
  __load_receipt_of_the_given_package() {
    [ -z "$1" ] && {
        error "__load_receipt_of_the_given_package <PACKAGE-SPEC>, <PACKAGE-SPEC> is unspecified."
        return 1
    }

    is_package_installed "$1" || {
        error "package [$1] is not installed."
        return 1
    }

    unset RECEIPT_PACKAGE_SUMMARY
    unset RECEIPT_PACKAGE_VERSION
    unset RECEIPT_PACKAGE_LICENSE

    unset RECEIPT_PACKAGE_WEB_URL

    unset RECEIPT_PACKAGE_GIT_URL
    unset RECEIPT_PACKAGE_GIT_SHA
    unset RECEIPT_PACKAGE_GIT_REF

    unset RECEIPT_PACKAGE_SVN_URL

    unset RECEIPT_PACKAGE_SRC_URL
    unset RECEIPT_PACKAGE_SRC_URI
    unset RECEIPT_PACKAGE_SRC_SHA

    unset RECEIPT_PACKAGE_FIX_URL
    unset RECEIPT_PACKAGE_FIX_SHA

    unset RECEIPT_PACKAGE_RES_URL
    unset RECEIPT_PACKAGE_RES_SHA

    unset RECEIPT_PACKAGE_DEP_PKG
    unset RECEIPT_PACKAGE_DEP_UPP
    unset RECEIPT_PACKAGE_DEP_PYM
    unset RECEIPT_PACKAGE_DEP_PLM

    unset RECEIPT_PACKAGE_BSYSTEM
    unset RECEIPT_PACKAGE_BSCRIPT
    unset RECEIPT_PACKAGE_DOPATCH
    unset RECEIPT_PACKAGE_INSTALL
    unset RECEIPT_PACKAGE_SYMLINK

    unset RECEIPT_PACKAGE_PARALLEL

    #######################################################################################################

    PACKAGE_INSTALLED_DIR="$XCPKG_PACKAGE_INSTALLED_ROOT/$1"
    PACKAGE_RECEIPT_FILEPATH="$PACKAGE_INSTALLED_DIR/.xcpkg/receipt.yml"

    unset PACKAGE_RECEIPT_SIGNATURE
    unset PACKAGE_RECEIPT_TIMESTAMP

    PACKAGE_RECEIPT_SIGNATURE="$(yq .signature "$PACKAGE_RECEIPT_FILEPATH")"
    PACKAGE_RECEIPT_TIMESTAMP="$(yq .timestamp "$PACKAGE_RECEIPT_FILEPATH")"

    if [ -z "$PACKAGE_RECEIPT_SIGNATURE" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of PACKAGE_RECEIPT_SIGNATURE must be non-empty."
        return 1
    fi

    if [ -z "$PACKAGE_RECEIPT_TIMESTAMP" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of PACKAGE_RECEIPT_TIMESTAMP must be non-empty."
        return 1
    fi

    #######################################################################################################

    for key in summary web-url git-url git-sha git-ref shallow src-url src-uri src-sha fix-url fix-sha res-url res-sha dep-pkg dep-upp dep-pym dep-plm license version bsystem bscript binbstd ccflags xxflags ppflags ldflags parallel exetype symlink
    do
        unset __KEY_UPPERCASE_UNDERSCORE__
        unset __VALUE__

        __KEY_UPPERCASE_UNDERSCORE__="$(printf '%s\n' "$key" | tr '-' '_' | tr a-z A-Z)"
        __VALUE__="$(yq ".$key" "$PACKAGE_RECEIPT_FILEPATH")"

        if [ "$__VALUE__" = null ] ; then
                __VALUE__=
        fi

        eval "RECEIPT_PACKAGE_$__KEY_UPPERCASE_UNDERSCORE__='$__VALUE__'"
    done

    if [ -z "$RECEIPT_PACKAGE_VERSION" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of RECEIPT_PACKAGE_VERSION must be non-empty."
        return 1
    fi

    if [ -z "$RECEIPT_PACKAGE_SUMMARY" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of RECEIPT_PACKAGE_SUMMARY must be non-empty."
        return 1
    fi

    if [ -z "$RECEIPT_PACKAGE_WEB_URL" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of RECEIPT_PACKAGE_WEB_URL must be non-empty."
        return 1
    fi

    if [ "${#PACKAGE_RECEIPT_TIMESTAMP}" -ne 10 ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. length of \$PACKAGE_RECEIPT_TIMESTAMP must be 10."
        return 1
    fi
}

# }}}
##############################################################################
# {{{ xcpkg receipt

# __show_receipt_of_the_given_package <PACKAGE-SPEC> [--json] [--yaml] [--path] [<KEY>]
  __show_receipt_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__show_receipt_of_the_given_package <PACKAGE-SPEC> [--json] [--yaml] [--path] [<KEY>], <PACKAGE-NAME> is unspecified."

    XCODE_SUPPORT_PLATFORM_NAMES='MacOSX DriverKit WatchOS WatchSimulator iPhoneOS iPhoneSimulator AppleTVOS AppleTVSimulator'

    PACKAGE_SPEC=
    PACKAGE_SPEC="$(inspect_package_spec "$1")"

    __load_receipt_of_the_given_package "$PACKAGE_SPEC"

    case $2 in
        --yaml|'')
            if [ -t 1 ] ; then
                yq  "$PACKAGE_RECEIPT_FILEPATH"
            else
                cat "$PACKAGE_RECEIPT_FILEPATH"
            fi
            ;;
        --json)
            yq -o=json "$PACKAGE_RECEIPT_FILEPATH"
            ;;
        --path)
            printf '%s\n' "$PACKAGE_RECEIPT_FILEPATH"
            ;;
        *)  yq ".$2 | select(. != null)" "$PACKAGE_RECEIPT_FILEPATH"
    esac
}

# }}}
##############################################################################
# {{{ operations of manifest

# __generate_manifest_of_the_given_package <PACKAGE-NAME>
  __generate_manifest_of_the_given_package() {
    # fuck, some package's filename has space
    export IFS='
'

    exec 7> "$PACKAGE_MANIFEST_FILEPATH"

    for dirname in $(find -mindepth 1 -maxdepth 1 -type d -not -name .xcpkg -printf '%P\n')
    do
        for item in $(find "$dirname" -printf '%y:%p\n')
        do
            X=$(printf '%s\n' "$item" | cut -c1)
            Y=${item#$X:}

            case $X in
                l)  if [ -d "$Y" ] ; then
                        printf 'D|0000000000000000000000000000000000000000000000000000000000000000|%s/\n' "$Y" >&7
                    else
                        printf 'l|%s|%s\n' "$(sha256sum "$Y" | cut -d ' ' -f1)"                           "$Y" >&7
                    fi
                    ;;
                d)  printf 'd|0000000000000000000000000000000000000000000000000000000000000000|%s/\n' "$Y" >&7 ;;
                *)  printf '%s|%s|%s\n' "$X" "$(sha256sum "$Y" | cut -d ' ' -f1)"                     "$Y" >&7 ;;
            esac
        done
    done

    exec 7>&-

    unset IFS
}

# }}}
##############################################################################
# {{{ xcpkg is-available

# check if the given package is available
# if the version condition is given, check if the condition is matched
#
# condition operator:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# is_package_available automake eq 1.16.0
# is_package_available automake lt 1.16.0
# is_package_available automake gt 1.16.0
# is_package_available automake le 1.16.0
# is_package_available automake ge 1.16.0
# is_package_available automake
is_package_available() {
    case $# in
        0)  abort 1 "package name is unspecified." ;;
        1)  [ -n "$(__path_of_formula_of_the_given_package "$1")" ] ;;
        3)  __load_formula_of_the_given_package "$1"
            shift
            version_match "$PACKAGE_VERSION" "$@"
            ;;
        *)  abort 1 "is available command only accept 1 or 3 argument."
    esac
}

# }}}
##############################################################################
# {{{ xcpkg is-installed

# is_package_installed <PACKAGE-SPEC>
  is_package_installed() {
    [ -z "$1" ] && {
        error "is_package_installed <PACKAGE-SPEC>, <PACKAGE-SPEC> is unspecified."
        return 1
    }

    [ -f "$XCPKG_PACKAGE_INSTALLED_ROOT/$1/.xcpkg/manifest.txt" ] || return 13
    [ -f "$XCPKG_PACKAGE_INSTALLED_ROOT/$1/.xcpkg/receipt.yml" ]  || return 14
}

# }}}
##############################################################################
# {{{ xcpkg is-outdated

# is_package__outdated <PACKAGE-SPEC>
  is_package__outdated() {
    __load_formula_of_the_given_package "$(basename "$1")"
    __load_receipt_of_the_given_package "$1"

    version_match "$PACKAGE_VERSION" gt "$INSTALLED_PACKAGE_VERSION"
}

# }}}
##############################################################################
# {{{ xcpkg ls-available

__list_available_packages() {
    [ -d "$XCPKG_FORMULA_REPO_ROOT" ] || return 0

    {
        AVAILABLE_FORMULA_REPOSITORY_NAMES=

        for item in $(cd "$XCPKG_FORMULA_REPO_ROOT" && ls)
        do
            if [ -f "$XCPKG_FORMULA_REPO_ROOT/$item/.xcpkg-formula-repo.yml" ] ; then
                AVAILABLE_FORMULA_REPOSITORY_NAMES="$AVAILABLE_FORMULA_REPOSITORY_NAMES $item"
            fi
        done

        for FORMULA_REPOSITORY_NAME in $AVAILABLE_FORMULA_REPOSITORY_NAMES
        do
            FORMULA_SEARCH_DIR="$XCPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$NATIVE_OS_TYPE"

            if [ -d  "$FORMULA_SEARCH_DIR" ] ; then
                find "$FORMULA_SEARCH_DIR" -maxdepth 1 -type f -name '*.yml' -exec basename {} .yml \; || return 1
            fi

            FORMULA_SEARCH_DIR="$XCPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula"

            if [ -d  "$FORMULA_SEARCH_DIR" ] ; then
                find "$FORMULA_SEARCH_DIR" -maxdepth 1 -type f -name '*.yml' -exec basename {} .yml \; || return 1
            fi
        done
    } | sort | uniq
}

# }}}
##############################################################################
# {{{ xcpkg ls-installed

__list_installed_packages() {
    if [ -d "$XCPKG_PACKAGE_INSTALLED_ROOT" ] ; then
         cd "$XCPKG_PACKAGE_INSTALLED_ROOT" 2>/dev/null || return 1
    else
        return 0
    fi

    for packageName in $(find . -maxdepth 1 -mindepth 1 -type d -printf '%P\n')
    do
        if is_package_installed "$packageName" ; then
            printf '%s\n' "$packageName"
        fi
    done
}

# }}}
##############################################################################
# {{{ xcpkg ls-outdated

__list__outdated_packages() {
    if [ -d "$XCPKG_PACKAGE_INSTALLED_ROOT" ] ; then
         cd "$XCPKG_PACKAGE_INSTALLED_ROOT" 2>/dev/null || return 1
    else
        return 0
    fi

    for packageName in $(find . -maxdepth 1 -mindepth 1 -type d -printf '%P\n')
    do
        is_package_available "$packageName" || continue
        is_package_installed "$packageName" || continue
        is_package__outdated "$packageName" || continue
        printf '%s\n' "$packageName"
    done
}

# }}}
##############################################################################
# {{{ xcpkg search

__search_packages() {
    [ -z "$1" ] && abort 1 "please specify a regular expression pattern."

    __list_available_packages | grep "$*"
}

# }}}
##############################################################################
# {{{ xcpkg info

# __show_information_of_all_available_packages [--json|--yaml|--shell]
  __show_information_of_all_available_packages() {
    case $1 in
        --json) __show_information_as_json__of_all_available_packages ;;
        --yaml) __show_information_as_yaml__of_all_available_packages ;;
        --shell)__show_information_as_shell_of_all_available_packages ;;
        '')     __show_information_as_mixed_of_all_available_packages ;;
        *)    abort 1 "__show_information_of_all_available_packages [--json|--yaml|--shell], unrecognized option: $1"
    esac
}

__show_information_as_mixed_of_all_available_packages() {
    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' '---'
        fi
        __show_information_of_the_given_package "$PACKAGE"
    done
}

__show_information_as_json__of_all_available_packages() {
    printf '%s\n' '['

    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' ','
        fi
        __show_information_as_json__of_the_given_package "$PACKAGE"
    done

    printf '%s\n' ']'
}

__show_information_as_yaml__of_all_available_packages() {
    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' '---'
        fi
        __show_information_as_yaml__of_the_given_package "$PACKAGE"
    done
}

__show_information_as_shell_of_all_available_packages() {
    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' '#---'
        fi
        __show_information_as_shell_of_the_given_package "$PACKAGE"
    done
}

# __show_information_as_json__of_the_given_package <PACKAGE-NAME>
  __show_information_as_json__of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    if [ -z "$PACKAGE_WEB_URL" ] ; then
        PACKAGE_WEB_URL="$PACKAGE_GIT_URL"
    fi

    jq  --null-input \
        --arg pkgname "$PACKAGE_NAME" \
        --arg version "$PACKAGE_VERSION" \
        --arg summary "$PACKAGE_SUMMARY" \
        --arg license "$PACKAGE_LICENSE" \
        --arg web_url "$PACKAGE_WEB_URL" \
        --arg git_url "$PACKAGE_GIT_URL" \
        --arg git_sha "$PACKAGE_GIT_SHA" \
        --arg git_ref "$PACKAGE_GIT_REF" \
        --arg src_url "$PACKAGE_SRC_URL" \
        --arg src_sha "$PACKAGE_SRC_SHA" \
        --arg fix_url "$PACKAGE_FIX_URL" \
        --arg fix_sha "$PACKAGE_FIX_SHA" \
        --arg res_url "$PACKAGE_RES_URL" \
        --arg res_sha "$PACKAGE_RES_SHA" \
        --arg dep_pkg "$PACKAGE_DEP_PKG" \
        --arg dep_upp "$PACKAGE_DEP_UPP" \
        --arg dep_pym "$PACKAGE_DEP_PYM" \
        --arg dep_plm "$PACKAGE_DEP_PLM" \
        --arg dopatch "$PACKAGE_DOPATCH_ACTIONS" \
        --arg install "$PACKAGE_DOBUILD_ACTIONS" \
        --arg bsystem "$PACKAGE_BSYSTEM" \
        --arg binbstd "$PACKAGE_BINBSTD" \
        --arg ccflags "$PACKAGE_CCFLAGS" \
        --arg xxflags "$PACKAGE_XXFLAGS" \
        --arg ppflags "$PACKAGE_PPFLAGS" \
        --arg ldflags "$PACKAGE_LDFLAGS" \
        --arg parallel $PACKAGE_BUILD_IN_PARALLEL \
'{
    "pkgname":$pkgname,
    "version":$version,
    "license":$license,
    "summary":$summary,
    "web-url":$web_url,
    "git-url":$git_url,
    "git-sha":$git_sha,
    "git-ref":$git_ref,
    "src-url":$src_url,
    "src-sha":$src_sha,
    "fix-url":$fix_url,
    "fix-sha":$fix_sha,
    "res-url":$res_url,
    "res-sha":$res_sha,
    "dep-pkg":$dep_pkg,
    "dep-upp":$dep_upp,
    "dep-pym":$dep_pym,
    "dep-plm":$dep_plm,
    "bsystem":$bsystem,
    "binbstd":$binbstd,
    "ccflags":$ccflags,
    "xxflags":$xxflags,
    "ppflags":$ppflags,
    "ldflags":$ldflags,
    "parallel":$parallel,
    "dopatch":$dopatch,
    "install":$install
}' | jq 'with_entries(select(.value != ""))'
}

# __show_information_as_yaml__of_the_given_package <PACKAGE-NAME>
  __show_information_as_yaml__of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    if [ -z "$PACKAGE_WEB_URL" ] ; then
        PACKAGE_WEB_URL="$PACKAGE_GIT_URL"
    fi

    {
    cat <<EOF
pkgname: $PACKAGE_NAME
version: $PACKAGE_VERSION
license: $PACKAGE_LICENSE
summary: $PACKAGE_SUMMARY
web-url: $PACKAGE_WEB_URL
git-url: $PACKAGE_GIT_URL
git-sha: $PACKAGE_GIT_SHA
git-ref: $PACKAGE_GIT_REF
src-url: $PACKAGE_SRC_URL
src-sha: $PACKAGE_SRC_SHA
fix-url: $PACKAGE_FIX_URL
fix-sha: $PACKAGE_FIX_SHA
res-url: $PACKAGE_RES_URL
res-sha: $PACKAGE_RES_SHA
dep-pkg: $PACKAGE_DEP_PKG
dep-upp: $PACKAGE_DEP_UPP
dep-pym: $PACKAGE_DEP_PYM
dep-plm: $PACKAGE_DEP_PLM
bsystem: $PACKAGE_BSYSTEM
binbstd: $PACKAGE_BINBSTD
ppflags: $PACKAGE_PPFLAGS
ccflags: $PACKAGE_CCFLAGS
xxflags: $PACKAGE_XXFLAGS
ldflags: $PACKAGE_LDFLAGS
parallel: $PACKAGE_BUILD_IN_PARALLEL
EOF
    } | yq eval '. | with_entries(select(.value != null))'

    if is_package_installed "$1" ; then
        yq eval --null-input '.installed = "yes"'
    else
        yq eval --null-input '.installed = "no"'
    fi
}

# __show_information_as_shell_of_the_given_package <PACKAGE-NAME>
  __show_information_as_shell_of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    while read KEY
    do
        printf "%s='%s'\n" "${PACKAGE_NAME_UPPERCASE_UNDERSCORE}_${KEY}" "$(eval echo \$$KEY)"
    done <<EOF
PACKAGE_NAME
PACKAGE_SUMMARY
PACKAGE_WEB_URL
PACKAGE_GIT_URL
PACKAGE_GIT_SHA
PACKAGE_GIT_REF
PACKAGE_SVN_URL
PACKAGE_SRC_URL
PACKAGE_SRC_SHA
PACKAGE_SRC_FILETYPE
PACKAGE_SRC_FILENAME
PACKAGE_SRC_FILEPATH
PACKAGE_FIX_URL
PACKAGE_FIX_SHA
PACKAGE_FIX_FILETYPE
PACKAGE_FIX_FILENAME
PACKAGE_FIX_FILEPATH
PACKAGE_VERSION
PACKAGE_VERSION_MAJOR
PACKAGE_VERSION_MINOR
PACKAGE_VERSION_PATCH
PACKAGE_VERSION_TWEAK
PACKAGE_DEVELOPER
PACKAGE_LICENSE
PACKAGE_BSCRIPT
PACKAGE_BSYSTEM
PACKAGE_BINBSTD
PACKAGE_BUILD_SYSTEM
PACKAGE_BUILD_SYSTEM_GO
PACKAGE_BUILD_SYSTEM_RAKE
PACKAGE_BUILD_SYSTEM_NINJA
PACKAGE_BUILD_SYSTEM_GMAKE
PACKAGE_BUILD_SYSTEM_CMAKE
PACKAGE_BUILD_SYSTEM_XMAKE
PACKAGE_BUILD_SYSTEM_MESON
PACKAGE_BUILD_SYSTEM_CARGO
PACKAGE_BUILD_SYSTEM_AUTOGENSH
PACKAGE_BUILD_SYSTEM_AUTOTOOLS
PACKAGE_BUILD_SYSTEM_CONFIGURE
PACKAGE_BUILD_IN_BSCRIPT_DIR
PACKAGE_BUILD_IN_PARALLEL
PACKAGE_DEP_PKG
PACKAGE_CCFLAGS
PACKAGE_XXFLAGS
PACKAGE_PPFLAGS
PACKAGE_LDFLAGS
PACKAGE_FORMULA_FILEPATH
EOF
}

# __show_information_of_the_given_package <PACKAGE-NAME> [--yaml] [--json] [<KEY>]
#
# __show_information_of_the_given_package curl
#
# __show_information_of_the_given_package curl version
# __show_information_of_the_given_package curl web-url
  __show_information_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__show_information_of_the_given_package <PACKAGE-NAME> [--yaml] [--json] [<KEY>], <PACKAGE-NAME> is unspecified."

    case $1 in
        @all) shift ; __show_information_of_all_available_packages "$@" ; return 0
    esac

    case $2 in
        --yaml|'')
            __show_information_as_yaml__of_the_given_package "$1"
            ;;
        --json)
            __show_information_as_json__of_the_given_package "$1"
            ;;
        symlinked-files)
            if [ -f "$XCPKG_PACKAGE_SYMLINKED_ROOT/.registry/$1" ] ; then
                cat "$XCPKG_PACKAGE_SYMLINKED_ROOT/.registry/$1"
            fi
            ;;
        installed-dir)
            if is_package_installed "$1" ; then
                printf '%s\n' "$XCPKG_PACKAGE_INSTALLED_ROOT/$1"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        installed-files)
            if is_package_installed "$1" ; then
                cut -d '|' -f3 "$XCPKG_PACKAGE_INSTALLED_ROOT/$1/.xcpkg/manifest.txt"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        installed-timestamp-unix)
            __load_receipt_of_the_given_package "$1"
            printf '%s\n' "$PACKAGE_RECEIPT_TIMESTAMP"
            ;;
        installed-timestamp-rfc-3339)
            __load_receipt_of_the_given_package "$1"
            format_unix_timestamp "$PACKAGE_RECEIPT_TIMESTAMP" '+%Y-%m-%d %H:%M:%S%:z'
            ;;
        installed-timestamp-iso-8601)
            __load_receipt_of_the_given_package "$1"
            format_unix_timestamp "$PACKAGE_RECEIPT_TIMESTAMP" '+%Y-%m-%dT%H:%M:%S%:z'
            ;;
        installed-timestamp-rfc-3339-utc)
            __load_receipt_of_the_given_package "$1"
            format_unix_timestamp "$PACKAGE_RECEIPT_TIMESTAMP" '+%Y-%m-%d %H:%M:%S%:z' -u
            ;;
        installed-timestamp-iso-8601-utc)
            __load_receipt_of_the_given_package "$1"
            format_unix_timestamp "$PACKAGE_RECEIPT_TIMESTAMP" '+%Y-%m-%dT%H:%M:%SZ' -u
            ;;
        installed-version)
            __load_receipt_of_the_given_package "$1"
            printf '%s\n' "$RECEIPT_PACKAGE_VERSION"
            ;;
        dopatch)
            __load_formula_of_the_given_package "$1"
            printf '%s\n' "$PACKAGE_DOPATCH_ACTIONS"
            ;;
        install)
            __load_formula_of_the_given_package "$1"
            printf '%s\n' "$PACKAGE_DOBUILD_ACTIONS"
            ;;
        *)  __load_formula_of_the_given_package "$1"
            __PACKAGE_GET__KEY__="$(printf '%s\n' "$2" | tr '+-.' '_' | tr a-z A-Z)"
            eval echo \$PACKAGE_$__PACKAGE_GET__KEY__
    esac
}

# }}}
##############################################################################
# {{{ xcpkg depends

# __show_packages_depended_by_the_given_package <PACKAGE-NAME> [-t <dot|box|svg|png>] [-o <OUTPUT-PATH>]
__show_packages_depended_by_the_given_package() {
    [ -z "$1" ] && abort 1 "_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], <PACKAGE-NAME> is unspecified."

    PACKAGE_NAME="$1"

    shift

    ###########################################################################################

    unset OUTPUT_FILETYPE
    unset OUTPUT_FILEPATH

    while [ -n "$1" ]
    do
        case $1 in
            -t) shift
                case $1 in
                    dot|box|svg|png)
                        OUTPUT_FILETYPE="$1" ;;
                    '') abort 1 "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], -t option is given but <OUTPUT-TYPE> is unspecified." ;;
                    *)  abort 1 "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>], unsupported <OUTPUT-TYPE>: $1, <OUTPUT-TYPE> should be one of dot|box|svg|png"
                esac
                ;;
            -o) shift
                if [ -z "$1" ] ; then
                    abort 1 "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], -o option is given but <OUTPUT-PATH> is unspecified."
                else
                    OUTPUT_FILEPATH="$1"
                fi
                ;;
            *)  abort 1 "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>] [--keep-packing-dir], unrecognized option: $1"
        esac
        shift
    done

    ###########################################################################################

    if [ -z "$OUTPUT_FILEPATH" ] ; then
        if [ -z "$OUTPUT_FILETYPE" ] ; then
            OUTPUT_FILETYPE='box'
        fi
    else
        if [ -d "$OUTPUT_FILEPATH" ] ; then
            if [ -z "$OUTPUT_FILETYPE" ] ; then
                OUTPUT_FILETYPE='box'
            fi

            unset OUTPUT_DIR
            OUTPUT_DIR="$(realpath -s "$OUTPUT_FILEPATH")"


            OUTPUT_FILEPATH="$OUTPUT_DIR/$PACKAGE_NAME-dependencies.$OUTPUT_FILETYPE"
        else
            case $OUTPUT_FILEPATH in
                */)
                    if [ -z "$OUTPUT_FILETYPE" ] ; then
                        OUTPUT_FILETYPE='box'
                    fi

                    unset OUTPUT_DIR
                    OUTPUT_DIR="$(realpath -s "$OUTPUT_FILEPATH")"

                    OUTPUT_FILEPATH="$OUTPUT_DIR/$PACKAGE_NAME-dependencies.$OUTPUT_FILETYPE"

                    [ -d "$OUTPUT_DIR" ] || install -d "$OUTPUT_DIR"
                    ;;
                *)
                    OUTPUT_FILEPATH="$(realpath -s "$OUTPUT_FILEPATH")"

                    unset OUTPUT_DIR
                    OUTPUT_DIR="$(dirname "$OUTPUT_FILEPATH")"

                    [ -d "$OUTPUT_DIR" ] || install -d "$OUTPUT_DIR"

                    if [ -z "$OUTPUT_FILETYPE" ] ; then
                        case $OUTPUT_FILEPATH in
                            *.box)
                                OUTPUT_FILETYPE='box'
                                ;;
                            *.dot)
                                OUTPUT_FILETYPE='dot'
                                ;;
                            *.svg)
                                OUTPUT_FILETYPE='svg'
                                ;;
                            *.png)
                                OUTPUT_FILETYPE='png'
                                ;;
                            *)  OUTPUT_FILETYPE='box'
                        esac
                    fi
            esac
        fi
    fi

    ###########################################################################################

    unset DOT_CONTENT

    unset DIRECTED_PATH_LIST

    STACK="$PACKAGE_NAME"

    while [ -n "$STACK" ]
    do
        case $STACK in
            *\;*) PACKAGE_NAME="${STACK##*;}" ; STACK="${STACK%;*}" ;;
            *)    PACKAGE_NAME="${STACK}"     ; STACK=
        esac

        ################################################################

        __load_formula_of_the_given_package "$PACKAGE_NAME"

        ################################################################

        [ -z "$PACKAGE_DEP_PKG" ] && continue

        ################################################################

        unset X; X="$(printf '"%s" ' $PACKAGE_DEP_PKG)"
        unset Y; Y="$(printf '    "%s" -> { %s}\n' "$PACKAGE_NAME" "$X")"

        if [ -z "$DOT_CONTENT" ] ; then
            DOT_CONTENT="$Y"
        else
            DOT_CONTENT="$(printf '%s\n%s\n' "$DOT_CONTENT" "$Y")"
        fi

        ################################################################

        DIRECTED_PATH_LIST_PART1=
        DIRECTED_PATH_LIST_PART2=

        for DIRECTED_PATH in $DIRECTED_PATH_LIST
        do
            case $DIRECTED_PATH in
                *\>"$PACKAGE_NAME")
                    DIRECTED_PATH_LIST_PART1="$DIRECTED_PATH_LIST_PART1 $DIRECTED_PATH" ;;
                *)  DIRECTED_PATH_LIST_PART2="$DIRECTED_PATH_LIST_PART2 $DIRECTED_PATH" ;;
            esac
        done

        ################################################################

        # it will be recalculated
        DIRECTED_PATH_LIST=

        ################################################################

        for DEPENDENT_PACKAGE_NAME in $PACKAGE_DEP_PKG
        do
            if [ "$DEPENDENT_PACKAGE_NAME" = "$PACKAGE_NAME" ] ; then
                abort 1 "package [$PACKAGE_NAME] depends itself."
            fi

            ############################################################

            if [ -z "$DIRECTED_PATH_LIST_PART1" ] ; then
                DIRECTED_PATH_LIST="$DIRECTED_PATH_LIST $PACKAGE_NAME>$DEPENDENT_PACKAGE_NAME"
            else
                for DIRECTED_PATH in $DIRECTED_PATH_LIST_PART1
                do
                    export IFS='>'

                    # check if have duplicate nodes in every directed path
                    for node in $DIRECTED_PATH
                    do
                        if [ "$node" = "$DEPENDENT_PACKAGE_NAME" ] ; then
                            abort 1 "depends has circle: $DIRECTED_PATH>$DEPENDENT_PACKAGE_NAME"
                        fi
                    done

                    unset IFS

                    DIRECTED_PATH_LIST="$DIRECTED_PATH_LIST $DIRECTED_PATH>$DEPENDENT_PACKAGE_NAME"
                done
            fi

            ############################################################

            if [ -z "$STACK" ] ; then
                STACK="$DEPENDENT_PACKAGE_NAME"
            else
                STACK="$STACK;$DEPENDENT_PACKAGE_NAME"
            fi
        done

        DIRECTED_PATH_LIST="$DIRECTED_PATH_LIST $DIRECTED_PATH_LIST_PART2"
    done


    ###########################################################################################

    [ -z "$DOT_CONTENT" ] && return 0

    DOT_CONTENT="digraph G {
$DOT_CONTENT
}"

    ###########################################################################################

    case $OUTPUT_FILETYPE in
        dot)
            if [ -z "$OUTPUT_FILEPATH" ] ; then
                printf '%s\n' "$DOT_CONTENT"
            else
                printf '%s\n' "$DOT_CONTENT" > "$OUTPUT_FILEPATH"
            fi
            ;;
        box)
            if [ -z "$OUTPUT_FILEPATH" ] ; then
                CURL_OPTS=
            else
                CURL_OPTS="-o $OUTPUT_FILEPATH"
            fi

            # https://github.com/ggerganov/dot-to-ascii
            curl $CURL_OPTS \
                -s \
                -G \
                --data-urlencode "boxart=1" \
                --data-urlencode "src=$DOT_CONTENT" \
                "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php"
            ;;
        svg)
            command -v dot > /dev/null || "$CURRENT_SCRIPT_FILEPATH" install graphviz || return 1

            if command -v fc-match > /dev/null ; then
                # Error: fontconfig: Couldn't find font.
                if [ -z "$(fc-match)" ] ; then
                    wfetch 'https://github.com/ryanoasis/nerd-fonts/blob/master/patched-fonts/Meslo/M/Regular/complete/Meslo%20LG%20M%20Regular%20Nerd%20Font%20Complete%20Mono%20Windows%20Compatible.ttf?raw=true' --output-dir="$HOME/.fonts" --output-name='Meslo LG M DZ Regular Nerd Font Complete Mono.ttf' || return 1
                fi
            fi

            unset TMP_DIR; TMP_DIR=$(mktemp -d)

            DOT_CONTENT_FILEPATH="$TMP_DIR/dependencies.dot"

            printf '%s\n' "$DOT_CONTENT" > "$DOT_CONTENT_FILEPATH"

            if [ -z "$OUTPUT_FILEPATH" ] ; then
                DOT_OPTS="-Tsvg"
            else
                DOT_OPTS="-Tsvg -o $OUTPUT_FILEPATH"
            fi

            run dot "$DOT_OPTS" "$DOT_CONTENT_FILEPATH"
            ;;
        png)
            command -v dot > /dev/null || "$CURRENT_SCRIPT_FILEPATH" install graphviz || return 1

            if command -v fc-match > /dev/null ; then
                # Error: fontconfig: Couldn't find font.
                if [ -z "$(fc-match)" ] ; then
                    wfetch 'https://github.com/ryanoasis/nerd-fonts/blob/master/patched-fonts/Meslo/M/Regular/complete/Meslo%20LG%20M%20Regular%20Nerd%20Font%20Complete%20Mono%20Windows%20Compatible.ttf?raw=true' --output-dir="$HOME/.fonts" --output-name='Meslo LG M DZ Regular Nerd Font Complete Mono.ttf' || return 1
                fi
            fi

            unset TMP_DIR; TMP_DIR=$(mktemp -d)

            DOT_CONTENT_FILEPATH="$TMP_DIR/dependencies.dot"

            printf '%s\n' "$DOT_CONTENT" > "$DOT_CONTENT_FILEPATH"

            if [ -z "$OUTPUT_FILEPATH" ] ; then
                DOT_OPTS="-Tpng"
            else
                DOT_OPTS="-Tpng -o $OUTPUT_FILEPATH"
            fi

            run dot "$DOT_OPTS" "$DOT_CONTENT_FILEPATH"
            ;;
    esac
}


# }}}
##############################################################################
# {{{ xcpkg fetch

# fetch source code if needed
__fetch_sources_of_the_given_package() {
    case $PACKAGE_SRC_FILETYPE in
        .dir) note "$PACKAGE_SRC_URL is local path, no need to fetch." ;;
        .git)
            unset GIT_FETCH_URL

            if [ -z "$XCPKG_URL_TRANSFORM" ] ; then
                GIT_FETCH_URL="$PACKAGE_GIT_URL"
            else
                GIT_FETCH_URL="$("$XCPKG_URL_TRANSFORM" "$PACKAGE_GIT_URL")" || return 1
            fi

            if [ -z "$PACKAGE_GIT_SHA" ] ; then
                if [ -z "$PACKAGE_GIT_REF" ] ; then
                    GIT_BRANCH_NAME=master
                    GIT_REF_SPEC="+HEAD:refs/remotes/origin/master"
                else
                    GIT_BRANCH_NAME="$(basename "$PACKAGE_GIT_REF")"
                    GIT_REF_SPEC="+$PACKAGE_GIT_REF:refs/remotes/origin/$GIT_BRANCH_NAME"
                fi
            else
                GIT_BRANCH_NAME=master
                GIT_REF_SPEC="+$PACKAGE_GIT_SHA:refs/remotes/origin/master"
            fi

            if [ "$PACKAGE_SHALLOW" = yes ] ; then
                GIT_FETCH_EXTRA_OPTIONS='--depth=1'
            else
                if [ -f "$PACKAGE_SRC_FILEPATH/.git/shallow" ] ; then
                    GIT_FETCH_EXTRA_OPTIONS='--unshallow'
                else
                    GIT_FETCH_EXTRA_OPTIONS=
                fi
            fi

            if [ -d "$PACKAGE_SRC_FILEPATH" ] ; then
                if git -C "$PACKAGE_SRC_FILEPATH" rev-parse HEAD > /dev/null 2>&1 ; then
                    if [ -n "$PACKAGE_GIT_SHA" ] && [ "$PACKAGE_GIT_SHA" = "$(git -C "$PACKAGE_SRC_FILEPATH" rev-parse HEAD)" ] ; then
                        success "$PACKAGE_SRC_FILEPATH already have been fetched."
                        return 0
                    fi
                else
                    run rm -rf     "$PACKAGE_SRC_FILEPATH" || return 1
                    run install -d "$PACKAGE_SRC_FILEPATH" || return 1
                    run git -C     "$PACKAGE_SRC_FILEPATH" -c init.defaultBranch=master init || return 1
                    run git -C     "$PACKAGE_SRC_FILEPATH" remote add origin "$GIT_FETCH_URL" || return 1
                fi
            else
                run install -d "$PACKAGE_SRC_FILEPATH" || return 1
                run git -C     "$PACKAGE_SRC_FILEPATH" -c init.defaultBranch=master init || return 1
                run git -C     "$PACKAGE_SRC_FILEPATH" remote add origin "$GIT_FETCH_URL" || return 1
            fi

            run git -C "$PACKAGE_SRC_FILEPATH" -c protocol.version=2 fetch --progress $GIT_FETCH_EXTRA_OPTIONS origin "$GIT_REF_SPEC" || return 1
            run git -C "$PACKAGE_SRC_FILEPATH" checkout --progress --force -B "$GIT_BRANCH_NAME" "refs/remotes/origin/$GIT_BRANCH_NAME" || return 1
            run git -C "$PACKAGE_SRC_FILEPATH" submodule update --init || return 1
            ;;
        *)  if [ -z    "$PACKAGE_SRC_URI" ] ; then
                wfetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SHA" --output-path="$PACKAGE_SRC_FILEPATH"
            else
                wfetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SHA" --output-path="$PACKAGE_SRC_FILEPATH" --uri="$PACKAGE_SRC_URI"
            fi
    esac
}

__fetch_patches_of_the_given_package() {
    if [ -n    "$PACKAGE_FIX_URL" ] ; then
        wfetch "$PACKAGE_FIX_URL" --sha256="$PACKAGE_FIX_SHA" --output-path="$PACKAGE_FIX_FILEPATH"
    fi
    if [ -n    "$PACKAGE_RES_URL" ] ; then
        wfetch "$PACKAGE_RES_URL" --sha256="$PACKAGE_RES_SHA" --output-path="$PACKAGE_RES_FILEPATH"
    fi
}

__fetch_resources_of_the_given_package() {
    [ -z "$1" ] && {
        error "__fetch_resources_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."
        return 1
    }

    case $1 in
        @all)
            shift
            unset STEP_NUM
            for PKG in $(__list_available_packages)
            do
                step "$PKG"
                 __load_formula_of_the_given_package "$PKG" "$@"
                __fetch_sources_of_the_given_package "$PKG" "$@"
                __fetch_patches_of_the_given_package "$PKG" "$@"
            done
            ;;
        *)
             __load_formula_of_the_given_package "$@"
            __fetch_sources_of_the_given_package "$@"
            __fetch_patches_of_the_given_package "$@"
    esac
}

# }}}
##############################################################################
# {{{ xcpkg tree

# __tree_the_given_installed_package <PACKAGE-SPEC>
  __tree_the_given_installed_package() {
    is_package_installed "$1" || abort 1 "package '$1' is not installed."
    PACKAGE_SPEC="$1"
    shift
    run tree "$@" "$XCPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC"
}

# }}}
##############################################################################
# {{{ xcpkg logs

# __logs_the_given_installed_package <PACKAGE-SPEC>
  __logs_the_given_installed_package() {
    [ -z "$1" ] && abort 1 "$_0 logs <PACKAGE-SPEC>, <PACKAGE-SPEC> is unspecified."

    is_package_installed "$1" || abort 1 "package '$1' is not installed."

    FILEPATHS=
    FILEPATHS="$(find "$XCPKG_PACKAGE_INSTALLED_ROOT/$1/.xcpkg" -type f)"

    for filepath in $FILEPATHS
    do
        [ -d "$filepath" ] && continue

        case $filepath in
            *.png)  ;;
            *.yml)  run yq . "$filepath" ;;
            *.json) run jq . "$filepath" ;;
            *)  if command -v bat > /dev/null ; then
                    bat  "$filepath"
                else
                    less "$filepath"
                fi
        esac
    done
}

# }}}
##############################################################################
# {{{ xcpkg pack

# examples:
# __pack_the_given_installed_package <PACKAGE-NAME|PACKAGE-SPEC> [-t <zip|tar.gz|tar.xz|tar.lz|tar.bz2>] [-o <OUTPUT-PATH>] [--keep-packing-dir]
# __pack_the_given_installed_package    autoconf     -t tar.xz
  __pack_the_given_installed_package() {
    XCODE_SUPPORT_PLATFORM_NAMES='MacOSX DriverKit WatchOS WatchSimulator iPhoneOS iPhoneSimulator AppleTVOS AppleTVSimulator'

    PACKAGE_SPEC=
    PACKAGE_SPEC="$(inspect_package_spec "$1")"

    __load_receipt_of_the_given_package "$PACKAGE_SPEC"

    unset TARGET_PLATFORM_NAME
    unset TARGET_PLATFORM_VERS
    unset TARGET_PLATFORM_ARCH

    unset RECEIPT_PACKAGE_NAME

    TARGET_PLATFORM_NAME="$(printf '%s\n' "$PACKAGE_SPEC" | cut -d/ -f1)"
    TARGET_PLATFORM_VERS="$(printf '%s\n' "$PACKAGE_SPEC" | cut -d/ -f2)"
    TARGET_PLATFORM_ARCH="$(printf '%s\n' "$PACKAGE_SPEC" | cut -d/ -f3)"
    RECEIPT_PACKAGE_NAME="$(printf '%s\n' "$PACKAGE_SPEC" | cut -d/ -f4)"

    shift

    ###########################################################################################

    unset OUTPUT_DIR
    unset OUTPUT_FILETYPE
    unset OUTPUT_FILEPATH

    while [ -n "$1" ]
    do
        case $1 in
            --keep-packing-dir)
                KEEP_PACKING_DIR=yes
                ;;
            -t) shift

                if [ -z "$1" ] ; then
                    abort 1 "$_0 pack <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], -t option is given but <OUTPUT-TYPE> is unspecified."
                else
                    OUTPUT_FILETYPE="$1"
                fi

                case $OUTPUT_FILETYPE in
                    zip|tar.gz|tar.xz|tar.lz|tar.bz2) ;;
                    *) abort 1 "$_0 pack <PACKAGE-NAME> [-t <OUTPUT-TYPE>], unsupported <OUTPU-TYPE>: $OUTPUT_FILETYPE, <OUTPU-TYPE> should be one of zip|tar.gz|tar.xz|tar.lz|tar.bz2"
                esac
                ;;
            -o) shift
                if [ -z "$1" ] ; then
                    abort 1 "$_0 pack <PACKAGE-NAME> [-t <OUTPU-TYPE>] [-o <OUTPUT-PATH>], -o option is given but <OUTPUT-PATH> is unspecified."
                else
                    OUTPUT_FILEPATH="$1"
                fi
                ;;
            *)  abort 1 "$_0 pack <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>] [--keep-packing-dir], unrecognized option: $1"
        esac
        shift
    done

    case $TARGET_PLATFORM_NAME in
        iPhoneOS)
            TARGET_PLATFORM_NAME_CANONICAL_NAME=ios
            ;;
        iPhoneSimulator)
            TARGET_PLATFORM_NAME_CANONICAL_NAME=iosSimulator
            ;;
        WatchOS)
            TARGET_PLATFORM_NAME_CANONICAL_NAME=watchos
            ;;
        WatchSimulator)
            TARGET_PLATFORM_NAME_CANONICAL_NAME=watchosSimulator
            ;;
        AppleTVOS)
            TARGET_PLATFORM_NAME_CANONICAL_NAME=tvos
            ;;
        AppleTVSimulator)
            TARGET_PLATFORM_NAME_CANONICAL_NAME=tvosSimulator
            ;;
        MacOSX)
            TARGET_PLATFORM_NAME_CANONICAL_NAME=macos
            ;;
        *)  TARGET_PLATFORM_NAME_CANONICAL_NAME="$TARGET_PLATFORM_NAME"
    esac

    PACKED_DIR_NAME="$RECEIPT_PACKAGE_NAME-$RECEIPT_PACKAGE_VERSION-$TARGET_PLATFORM_NAME_CANONICAL_NAME$TARGET_PLATFORM_VERS-$TARGET_PLATFORM_ARCH"

    ###########################################################################################

    if [ -z "$OUTPUT_FILEPATH" ] ; then
        if [ -z "$OUTPUT_FILETYPE" ] ; then
            OUTPUT_FILETYPE='tar.xz'
        fi

        OUTPUT_DIR="$XCPKG_HOME/packed"
        OUTPUT_FILENAME="$PACKED_DIR_NAME.$OUTPUT_FILETYPE"
    else
        if [ -d "$OUTPUT_FILEPATH" ] ; then
            if [ -z "$OUTPUT_FILETYPE" ] ; then
                OUTPUT_FILETYPE='tar.xz'
            fi

            OUTPUT_DIR="$(realpath -s "$OUTPUT_FILEPATH")"
            OUTPUT_FILENAME="$PACKED_DIR_NAME.$OUTPUT_FILETYPE"
        else
            case $OUTPUT_FILEPATH in
                */)
                    if [ -z "$OUTPUT_FILETYPE" ] ; then
                        OUTPUT_FILETYPE='tar.xz'
                    fi

                    OUTPUT_DIR="$(realpath -s "$OUTPUT_FILEPATH")"
                    OUTPUT_FILENAME="$PACKED_DIR_NAME.$OUTPUT_FILETYPE"
                    ;;
                *)
                    OUTPUT_FILEPATH="$(realpath -s "$OUTPUT_FILEPATH")"

                    if [ -z "$OUTPUT_FILETYPE" ] ; then
                        case $OUTPUT_FILEPATH in
                            *.tar.gz|*.tgz)
                                OUTPUT_FILETYPE=tar.gz
                                ;;
                            *.tar.xz|*.txz)
                                OUTPUT_FILETYPE=tar.xz
                                ;;
                            *.tar.lz|*.tlz)
                                OUTPUT_FILETYPE=tar.lz
                                ;;
                            *.tar.bz2|*.tbz2)
                                OUTPUT_FILETYPE=tar.bz2
                                ;;
                            *.zip)
                                OUTPUT_FILETYPE=zip
                                ;;
                            *.7z)
                                OUTPUT_FILETYPE=7z
                                ;;
                            *)  abort 1 "when -t <OUTPUT-TYPE> option is not given, -o <OUTPUT-PATH> option specified filename must ends with one of .tar.gz|.tar.xz|.tar.lz|.tar.bz2|.tgz|.txz|.tlz|.tbz2|.zip|.7z"
                        esac
                    fi

                    OUTPUT_DIR="$(dirname "$OUTPUT_FILEPATH")"
                    OUTPUT_FILENAME="$(basename "$OUTPUT_FILEPATH")"
            esac
        fi
    fi

    ###########################################################################################

    step "create packing directory"
    printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mktemp -d$COLOR_OFF"
    PACKING_DIR=$(mktemp -d)

    step "change to packing directory"
    run cd "$PACKING_DIR"

    step "make link refer to installed package root dir"
    run ln -s "$PACKAGE_INSTALLED_DIR" "$PACKED_DIR_NAME"

    step "packing"
    case $OUTPUT_FILETYPE in
        zip) run zip -9 -r     "$OUTPUT_FILENAME" "$PACKED_DIR_NAME" ;;
        7z)  run 7za a -t7z -r "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.xcpkg" ;;
        tar.xz)  run tar cv --xz    -f "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.xcpkg" ;;
        tar.gz)  run tar cv --gzip  -f "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.xcpkg" ;;
        tar.lz)  run tar cv --lzip  -f "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.xcpkg" ;;
        tar.bz2) run tar cv --bzip2 -f "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.xcpkg" ;;
    esac

    step "check integrity of packed file"
    case $OUTPUT_FILETYPE in
        7z)    run 7za t -t7z "$OUTPUT_FILENAME" ;;
        zip)   run unzip -t   "$OUTPUT_FILENAME" ;;
        tar.*) run tar   -tf  "$OUTPUT_FILENAME" ;;
    esac

    step "show size of packed file"
    run "du -sh $OUTPUT_FILENAME | cut -f1"

    if [ ! -d "$OUTPUT_DIR" ] ; then
        step "create output dir"
        run install -d "$OUTPUT_DIR"
    fi

    step "copy packed file to output dir"
    run cp "$OUTPUT_FILENAME" "$OUTPUT_DIR/"

    if [ "$KEEP_PACKING_DIR" = yes ] ; then
        printf '\n'
        note "the work dir [$PACKING_DIR] is not deleted as --keep-packing-dir option is given."
    else
        step "delete packing directory"
        run rm -rf "$PACKING_DIR"
    fi
}

# }}}
##############################################################################
# {{{ xcpkg upgrade-self

# __upgrade_self <URL>
  __upgrade_self() {
    if [ -z "$1" ] ; then
        error "__upgrade_self <URL> , <URL> must be non-empty."
        return 1
    fi

    unset CURRENT_SCRIPT_REALPATH

    # if file exists and is a symbolic link
    if [ -L "$CURRENT_SCRIPT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            CURRENT_SCRIPT_REALPATH=$(realpath "$CURRENT_SCRIPT_FILEPATH")
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            CURRENT_SCRIPT_REALPATH=$(readlink -f "$CURRENT_SCRIPT_FILEPATH")
        else
            CURRENT_SCRIPT_REALPATH=$(realpath "$CURRENT_SCRIPT_FILEPATH")
        fi
    else
        CURRENT_SCRIPT_REALPATH="$CURRENT_SCRIPT_FILEPATH"
    fi

    printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mktemp -d$COLOR_OFF"
    WORKING_DIR=$(mktemp -d)

    run cd "$WORKING_DIR"

    wfetch "$1" --output-path="$WORKING_DIR/self"

    __upgrade_self_exit() {
        if [ -w "$CURRENT_SCRIPT_REALPATH" ] ; then
            run      install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        else
            run sudo install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        fi

        run rm -rf "$WORKING_DIR"
    }

    trap __upgrade_self_exit EXIT
}

# }}}
##############################################################################
# {{{ xcpkg integrate zsh

# __integrate_zsh_completions <URL> [--output-dir=<DIR>]
  __integrate_zsh_completions() {
    if [ -z "$1" ] ; then
        error "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , <URL> must be non-empty."
        return 1
    else
        ZSH_COMPLETIONS_SCRIPT_URL="$1"
    fi

    shift

    unset OUTPUT_DIR

    for arg in "$@"
    do
        case $arg in
            --output-dir=*)
                OUTPUT_DIR="${arg#*=}"
                case $OUTPUT_DIR in
                    '')     abort 1 "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , <DIR> must be non-empty." ;;
                    \~|\~/) OUTPUT_DIR="${HOME}" ;;
                    \~/*)   OUTPUT_DIR="$HOME/$(printf '%s\n' "$OUTPUT_DIR" | cut -c3-)" ;;
                esac
                ;;
            *)  abort 1 "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , unrecognized argument: $arg"
        esac
    done

    ZSH_COMPLETIONS_SCRIPT_FILENAME="_$CURRENT_SCRIPT_FILENAME"

    if [ -n "$OUTPUT_DIR" ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="$OUTPUT_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    elif [ "$(uname)" = Linux ] && command -v termux-info > /dev/null && [ "$HOME" = '/data/data/com.termux/files/home' ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/data/data/com.termux/files/usr/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/usr/local/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    fi

    # if file exists and is a symbolic link
    if [ -L "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(readlink -f "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")
        else
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")
        fi
    fi

    printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mktemp -d$COLOR_OFF"
    WORKING_DIR=$(mktemp -d)

    run cd "$WORKING_DIR"

    wfetch "$ZSH_COMPLETIONS_SCRIPT_URL" --output-path="$WORKING_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"

    if [ -f "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_DIR="$(dirname "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")"
        if [ ! -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" || run sudo install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR"
        fi
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    fi

    run rm -rf "$WORKING_DIR"

    printf '\n'
    note "${COLOR_YELLOW}you need to run command${COLOR_RED} ${COLOR_GREEN}autoload -U compinit && compinit${COLOR_OFF} ${COLOR_YELLOW}in zsh to make it work.${COLOR_OFF}"
}

# }}}
##############################################################################
# {{{ xcpkg compare-versions

package_name_transform_from_uppm_to_brew() {
    case $1 in
        file)     printf '%s\n' 'file-formula' ;;
        delta)    printf '%s\n' 'git-delta' ;;
        gmake)    printf '%s\n' 'make'      ;;
        gtar)     printf '%s\n' 'gnu-tar'   ;;
        gm4)      printf '%s\n' 'm4'        ;;
        patch)    printf '%s\n' 'gpatch'    ;;
        libjxl)   printf '%s\n' 'jpeg-xl'   ;;
        blake3)   printf '%s\n' 'b3sum'     ;;
        libwebp)  printf '%s\n' 'webp'      ;;
        proj7)    printf '%s\n' 'proj@7'    ;;
        openssl)  printf '%s\n' 'openssl@1.1';;
        freetype2)printf '%s\n' 'freetype'  ;;
        freetype2-with-harfbuzz)
                  printf '%s\n' 'freetype'  ;;
        gnu-coreutils)
                  printf '%s\n' 'coreutils' ;;
        libmediainfo|mediainfo)
                  printf '%s\n' 'media-info';;
        tcl-core) printf '%s\n' 'tcl-tk'    ;;
        *)        printf '%s\n' "$1"
    esac
}

__compare_versions_with_brew() {
    cd "$XCPKG_HOME/repos.d/offical-core/formula"

    AVAILABLE_PACKAGE_NAME_LIST=
    AVAILABLE_PACKAGE_NAME_LIST="$(find . -mindepth 1 -maxdepth 1 -name "*.yml" -exec basename {} .yml \;)"

    [ -z "$BREW" ] && {
        BREW="$(command -v brew)" || abort 1 "command not found: brew"
    }

    for PACKAGE_NAME in $AVAILABLE_PACKAGE_NAME_LIST
    do
        __load_formula_of_the_given_package "$PACKAGE_NAME"

        BREW_PKG_NMAE="$(package_name_transform_from_uppm_to_brew "$PACKAGE_NAME")"

        if "$BREW" info "$BREW_PKG_NMAE" > /dev/null 2>&1 ; then
            BREW_PKG_VERS="$("$BREW" info "$BREW_PKG_NMAE" --json | yq '.[0].versions.stable')"

            if version_match "$BREW_PKG_VERS" eq "$PACKAGE_VERSION" ; then
                :
                #printf "${COLOR_GREEN}%-10s %-10s  |  %-10s %-10s${COLOR_OFF}\n" "$PACKAGE_NAME" "$PACKAGE_VERSION" "$BREW_PKG_NMAE" "$BREW_PKG_VERS"
            else
                printf "${COLOR_RED}%-10s %-10s  |  %-10s %-10s${COLOR_OFF}\n" "$PACKAGE_NAME" "$PACKAGE_VERSION" "$BREW_PKG_NMAE" "$BREW_PKG_VERS"
            fi
        else
            printf "${COLOR_BLUE}%-10s %-10s  |${COLOR_OFF}\n" "$PACKAGE_NAME" "$PACKAGE_VERSION"
        fi
    done
}

__compare_versions_with_ppkg() {
    cd "$XCPKG_HOME/repos.d/offical-core/formula"

    AVAILABLE_PACKAGE_NAME_LIST=
    AVAILABLE_PACKAGE_NAME_LIST="$(find . -mindepth 1 -maxdepth 1 -name "*.yml" -exec basename {} .yml \;)"

    [ -z "$PPKG" ] && {
        PPKG="$(command -v ppkg)" || abort 1 "command not found: ppkg"
    }

    for PACKAGE_NAME in $AVAILABLE_PACKAGE_NAME_LIST
    do
        __load_formula_of_the_given_package "$PACKAGE_NAME"

        if "$PPKG" is-available "$PACKAGE_NAME" ; then
            PPKG_PACKAGE_VERSION="$("$PPKG" info "$PACKAGE_NMAE" version)"

            if version_match "$PPKG_PACKAGE_VERSION" eq "$PACKAGE_VERSION" ; then
                :
            else
                printf "${COLOR_RED}%-10s %-10s  |  %-10s %-10s${COLOR_OFF}\n" "$PACKAGE_NAME" "$PACKAGE_VERSION" "$PACKAGE_NAME" "$PPKG_PACKAGE_VERSION"
            fi
        else
            printf "${COLOR_BLUE}%-10s %-10s  |${COLOR_OFF}\n" "$PACKAGE_NAME" "$PACKAGE_VERSION"
        fi
    done
}

# }}}
##############################################################################
# {{{ xcpkg gen-url-transform-sample

__gen_url_transform_sample() {
    install -d "$XCPKG_HOME"

    FILEPATH="$XCPKG_HOME/url-transform.sample"

    cat > "$FILEPATH" <<EOF
#!/bin/sh

# https://ghproxy.com/
case \$1 in
    *githubusercontent.com/*)
        printf 'https://ghproxy.com/%s\n' "\$1"
        ;;
    https://github.com/*)
        printf 'https://ghproxy.com/%s\n' "\$1"
        ;;
    '') printf '%s\n' "\$0 <URL>, <URL> is unspecified." >&2 ;;
    *)  printf '%s\n' "\$1"
esac
EOF

    chmod +x "$FILEPATH"

    success "url-transform sample has been written into $XCPKG_HOME/url-transform.sample"
    note "You can rename url-transform.sample to url-transform then edit it to meet your needs. To apply this, you should run 'export XCPKG_URL_TRANSFORM=$XCPKG_HOME/url-transform' in your terminal."
}

# }}}
##############################################################################
# {{{ xcpkg gen-github-workflows

__gen_github_workflows() {
    unset GROUP_SIZE
    unset OUTPUT_DIR

    while [ -n "$1" ]
    do
        case $1 in
            --group-size=*)
                GROUP_SIZE="${1#*=}"
                is_integer "$GROUP_SIZE" || abort 1 "--group-size=<INTEGER>, <INTEGER> must be an integer."
                ;;
            --output-dir=*)
                OUTPUT_DIR="${1#*=}"

                case "$OUTPUT_DIR" in
                    '') abort 1 "--output-dir=<DIR>, <DIR> must be non-empty." ;;
                    /*) ;;
                    \~|\~/) OUTPUT_DIR="${HOME}" ;;
                    \~/*)   OUTPUT_DIR="${HOME}${OUTPUT_DIR#'~/'}" ;;
                    .|./)   OUTPUT_DIR="${PWD}" ;;
                    *)      OUTPUT_DIR="${PWD}/$OUTPUT_DIR" ;;
                esac

                [ -d "$OUTPUT_DIR" ] || run install -d "$OUTPUT_DIR"
        esac
        shift
    done

    if [ -z "$GROUP_SIZE" ] ; then
        abort 1 "--group-size=<INTEGER> option must be given."
    fi

    if [ -z "$OUTPUT_DIR" ] ; then
        OUTPUT_DIR="$XCPKG_HOME/repos.d/offical-core/.github/workflows"
    fi

    GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH="$XCPKG_HOME/repos.d/offical-core/.github/workflows/template"

    if [ ! -f "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" ] ; then
        __sync_available_formula_repositories
    fi

    ##############################################################################

    unset AVAILABLE_PACKAGE_NAME_LIST
    unset AVAILABLE_PACKAGE_NAME_LIST_PART1
    unset AVAILABLE_PACKAGE_NAME_LIST_PART2

    # part1 are packages that are     depended by any other packages.
    # part2 are packages that are not depended by any other packages.

    ##############################################################################

    AVAILABLE_PACKAGE_NAME_LIST="$(__list_available_packages)"

    for item in test v8 webrtc
    do
        AVAILABLE_PACKAGE_NAME_LIST=$(printf '%s\n' "$AVAILABLE_PACKAGE_NAME_LIST" | sed "s|^$item$||")
    done

    ##############################################################################

    for item in $AVAILABLE_PACKAGE_NAME_LIST
    do
        __load_formula_of_the_given_package "$item"

        AVAILABLE_PACKAGE_NAME_LIST_PART1="$AVAILABLE_PACKAGE_NAME_LIST_PART1 $PACKAGE_DEP_PKG"
    done

    AVAILABLE_PACKAGE_NAME_LIST_PART1=$(printf '%s\n' $AVAILABLE_PACKAGE_NAME_LIST_PART1 | sort | uniq)

    printf '%s\n' "AVAILABLE_PACKAGE_NAME_LIST_PART1=$AVAILABLE_PACKAGE_NAME_LIST_PART1"

    ##############################################################################

    unset AVAILABLE_PACKAGE_NAME_LIST_SIZE

    AVAILABLE_PACKAGE_NAME_LIST_SIZE="$(list_size $AVAILABLE_PACKAGE_NAME_LIST)"

    printf '%s\n' "$AVAILABLE_PACKAGE_NAME_LIST_SIZE"

    ##############################################################################

    I=0
    J=0
    K=0

    for x in $AVAILABLE_PACKAGE_NAME_LIST
    do
        I="$(expr "$I" + 1)"

        for y in $AVAILABLE_PACKAGE_NAME_LIST_PART1
        do
            [ "$x" = "$y" ] && continue 2
        done

        AVAILABLE_PACKAGE_NAME_LIST_PART2="$AVAILABLE_PACKAGE_NAME_LIST_PART2,$x"

        K="$(expr "$K" + 1)"

        if [ "$I" -eq "$AVAILABLE_PACKAGE_NAME_LIST_SIZE" ] || [ "$K" -eq "$GROUP_SIZE" ] ; then
            J="$(expr "$J" + 1)"

            OUTPUT_FILEPATH="$OUTPUT_DIR/ci$J.yml"

            AVAILABLE_PACKAGE_NAME_LIST_PART2="${AVAILABLE_PACKAGE_NAME_LIST_PART2#,}"

            printf '\n'
            run cp "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH"          "$OUTPUT_FILEPATH"
            sed_in_place "s/INDEX/$J/"                                   "$OUTPUT_FILEPATH"
            sed_in_place "s/PKGLIST/$AVAILABLE_PACKAGE_NAME_LIST_PART2/" "$OUTPUT_FILEPATH"

            AVAILABLE_PACKAGE_NAME_LIST_PART2=

            K=0
        fi
    done
}

# }}}
##############################################################################
# {{{ xcpkg cleanup

__cleanup() {
    success "Done."
}

# }}}
##############################################################################
# {{{ xcpkg uninstall

__uninstall_the_given_packages() {
    [ -z "$1" ] && abort 1 "package name or spec is unspecified."

    XCODE_SUPPORT_PLATFORM_NAMES='MacOSX DriverKit WatchOS WatchSimulator iPhoneOS iPhoneSimulator AppleTVOS AppleTVSimulator'

    unset PACKAGE_SPECS

    for item in "$@"
    do
        PACKAGE_SPECS="$PACKAGE_SPECS $(inspect_package_spec "$item")"
    done

    for PACKAGE_SPEC in $PACKAGE_SPECS
    do
        __uninstall_the_given_package "$PACKAGE_SPEC" || return 1
    done
}

# __uninstall_the_given_package <PACKAGE-SPEC>
  __uninstall_the_given_package() {
    is_package_installed "$1" || abort 1 "$1 is not installed."
    run rm -rf "$XCPKG_PACKAGE_INSTALLED_ROOT/$1"
}

# }}}
##############################################################################
# {{{ xcpkg reinstall

__reinstall_the_given_packages() {
    inspect_install_arguments "$@"

    [ -z "$USER_SPECIFIED_PACKAGE_SPEC_LIST" ] && abort 1 "package name or spec is unspecified."

    for packageName in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        is_package_available "$1" || abort 1 "$1 is not available."
        is_package_installed "$1" || abort 1 "$1 is not installed."
    done

    for PACKAGE_NAME in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        [ -d "$XCPKG_BACKUP_DIR" ] || {
            install -d "$XCPKG_BACKUP_DIR" || return 1
        }

        mv "$XCPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_NAME" "$XCPKG_BACKUP_DIR/$PACKAGE_NAME" || return 1

        (__install_the_given_package "$PACKAGE_NAME") || return 1

        rm -rf "$XCPKG_BACKUP_DIR/$PACKAGE_NAME" || return 1
    done
}

# }}}
##############################################################################
# {{{ xcpkg upgrade

__upgrade_packages() {
    inspect_install_arguments "$@"

    if [ -z "$USER_SPECIFIED_PACKAGE_SPEC_LIST" ] ; then
        USER_SPECIFIED_PACKAGE_SPEC_LIST=$(__list__outdated_packages)
    fi

    for packageName in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        is_package_available "$1" || abort 1 "$1 is not available."
        is_package_installed "$1" || abort 1 "$1 is not installed."
    done

    for PACKAGE_NAME in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        [ -d "$XCPKG_BACKUP_DIR" ] || {
            install -d "$XCPKG_BACKUP_DIR" || return 1
        }

        mv "$XCPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_NAME" "$XCPKG_BACKUP_DIR/$PACKAGE_NAME" || return 1

        (__install_the_given_package "$PACKAGE_NAME") || return 1

        rm -rf "$XCPKG_BACKUP_DIR/$PACKAGE_NAME" || return 1
    done
}

# }}}
##############################################################################
# {{{ xcpkg install

# inspect_package_spec <PACKAGE-NAME|PACKAGE-SPEC>
  inspect_package_spec() {
    [ -z "$1" ] && abort 1 "package name or package spec is unspecified."

    if printf '%s\n' "$1" | grep -q -E '^[A-Za-z0-9+-._]{1,50}$' ; then
        if [ -z "$XCPKG_DEFAULT_TARGET_PLATFORM_SPEC" ] ; then
            PACKAGE_SPEC="$NATIVE_OS_NAME/$NATIVE_OS_VERS/$NATIVE_OS_ARCH/$1"
        else
            case $XCPKG_DEFAULT_TARGET_PLATFORM_SPEC in
                */*/*/*)
                    abort 1 "you have set XCPKG_DEFAULT_TARGET_PLATFORM_SPEC=$XCPKG_DEFAULT_TARGET_PLATFORM_SPEC , but it is an invalid package spec."
                    ;;
                */*/*)
                    unset TARGET_PLATFORM_NAME
                    unset TARGET_PLATFORM_VERS
                    unset TARGET_PLATFORM_ARCH

                    TARGET_PLATFORM_NAME=$(printf '%s\n' "$XCPKG_DEFAULT_TARGET_PLATFORM_SPEC" | cut -d/ -f1)
                    TARGET_PLATFORM_VERS=$(printf '%s\n' "$XCPKG_DEFAULT_TARGET_PLATFORM_SPEC" | cut -d/ -f2)
                    TARGET_PLATFORM_ARCH=$(printf '%s\n' "$XCPKG_DEFAULT_TARGET_PLATFORM_SPEC" | cut -d/ -f3)

                    if [ -z "$TARGET_PLATFORM_NAME" ] ; then
                        TARGET_PLATFORM_NAME=$NATIVE_OS_NAME
                    else
                        TARGET_PLATFORM_NAME_IS_SUPPORTED=no

                        for XCODE_SUPPORT_PLATFORM_NAME in $XCODE_SUPPORT_PLATFORM_NAMES
                        do
                            if [ "$XCODE_SUPPORT_PLATFORM_NAME" = "$TARGET_PLATFORM_NAME" ] ; then
                                TARGET_PLATFORM_NAME_IS_SUPPORTED=yes
                                break;
                            fi
                        done

                        if [ "$TARGET_PLATFORM_NAME_IS_SUPPORTED" = no ] ; then
                            abort 1 "you have set XCPKG_DEFAULT_TARGET_PLATFORM_SPEC=$XCPKG_DEFAULT_TARGET_PLATFORM_SPEC , but it is an invalid package spec. unrecognized platform: $TARGET_PLATFORM_NAME"
                        fi
                    fi

                    if [ -z "$TARGET_PLATFORM_VERS" ] ; then
                        case $TARGET_PLATFORM_NAME in
                            iPhoneOS|iPhoneSimulator)
                                TARGET_PLATFORM_VERS=9.0
                                ;;
                            WatchOS|WatchSimulator)
                                TARGET_PLATFORM_VERS=5.0
                                ;;
                            AppleTVOS|AppleTVSimulator)
                                TARGET_PLATFORM_VERS=9.0
                                ;;
                            MacOSX)
                                TARGET_PLATFORM_VERS=$NATIVE_OS_VERS
                                ;;
                        esac
                    fi

                    if [ -z "$TARGET_PLATFORM_ARCH" ] ; then
                        case $TARGET_PLATFORM_NAME in
                            WatchOS)
                                TARGET_PLATFORM_ARCH=arm64_32
                                ;;
                            WatchSimulator)
                                TARGET_PLATFORM_ARCH=arm64
                                ;;
                            iPhoneOS|iPhoneSimulator)
                                TARGET_PLATFORM_ARCH=arm64
                                ;;
                            AppleTVOS|AppleTVSimulator)
                                TARGET_PLATFORM_ARCH=arm64
                                ;;
                            MacOSX)
                                TARGET_PLATFORM_ARCH=$NATIVE_OS_ARCH
                                ;;
                        esac
                    fi

                    PACKAGE_SPEC="$TARGET_PLATFORM_NAME/$TARGET_PLATFORM_VERS/$TARGET_PLATFORM_ARCH/$1"
                    ;;
                *) abort 1 "you have set XCPKG_DEFAULT_TARGET_PLATFORM_SPEC=$XCPKG_DEFAULT_TARGET_PLATFORM_SPEC , but it is an invalid package spec."
            esac
        fi

        note "$1 will be treated as a package name, and it will be expanded to $PACKAGE_SPEC"
        printf '%s\n' "$PACKAGE_SPEC"
    else
        case $1 in
            */*/*/*/*)
                abort 1 "invalid package spec: $1"
                ;;
            */*/*/*)
                unset PACKAGE_NAME

                unset TARGET_PLATFORM_NAME
                unset TARGET_PLATFORM_VERS
                unset TARGET_PLATFORM_ARCH

                TARGET_PLATFORM_NAME=$(printf '%s\n' "$1" | cut -d/ -f1)
                TARGET_PLATFORM_VERS=$(printf '%s\n' "$1" | cut -d/ -f2)
                TARGET_PLATFORM_ARCH=$(printf '%s\n' "$1" | cut -d/ -f3)
                        PACKAGE_NAME=$(printf '%s\n' "$1" | cut -d/ -f4)

                if [ -z "$PACKAGE_NAME" ] ; then
                    abort 1 "invalid package spec: $1\npackage name is unspecified."
                elif printf '%s\n' "$PACKAGE_NAME" | grep -q -E '^[A-Za-z0-9+-._]{1,50}$' ; then
                    :
                else
                    abort 1 "invalid package spec: $1\npackage name does not match pattern ^[A-Za-z0-9+-._]{1,50}$"
                fi

                if [ -z "$TARGET_PLATFORM_NAME" ] ; then
                    TARGET_PLATFORM_NAME=$NATIVE_OS_NAME
                else
                    TARGET_PLATFORM_NAME_IS_SUPPORTED=no

                    for XCODE_SUPPORT_PLATFORM_NAME in $XCODE_SUPPORT_PLATFORM_NAMES
                    do
                        if [ "$XCODE_SUPPORT_PLATFORM_NAME" = "$TARGET_PLATFORM_NAME" ] ; then
                            TARGET_PLATFORM_NAME_IS_SUPPORTED=yes
                            break;
                        fi
                    done

                    if [ "$TARGET_PLATFORM_NAME_IS_SUPPORTED" = no ] ; then
                        abort 1 "invalid package spec: $1\nunsupported platform: $TARGET_PLATFORM_NAME"
                    fi
                fi

                if [ -z "$TARGET_PLATFORM_VERS" ] ; then
                    case $TARGET_PLATFORM_NAME in
                        iPhoneOS|iPhoneSimulator)
                            TARGET_PLATFORM_VERS=9.0
                            ;;
                        WatchOS|WatchSimulator)
                            TARGET_PLATFORM_VERS=5.0
                            ;;
                        AppleTVOS|AppleTVSimulator)
                            TARGET_PLATFORM_VERS=9.0
                            ;;
                        MacOSX)
                            TARGET_PLATFORM_VERS=$NATIVE_OS_VERS
                            ;;
                    esac
                fi

                if [ -z "$TARGET_PLATFORM_ARCH" ] ; then
                    case $TARGET_PLATFORM_NAME in
                        WatchOS)
                            TARGET_PLATFORM_ARCH=arm64_32
                            ;;
                        WatchSimulator)
                            TARGET_PLATFORM_ARCH=arm64
                            ;;
                        iPhoneOS|iPhoneSimulator)
                            TARGET_PLATFORM_ARCH=arm64
                            ;;
                        AppleTVOS|AppleTVSimulator)
                            TARGET_PLATFORM_ARCH=arm64
                            ;;
                        MacOSX)
                            TARGET_PLATFORM_ARCH=$NATIVE_OS_ARCH
                            ;;
                    esac
                fi

                PACKAGE_SPEC="$TARGET_PLATFORM_NAME/$TARGET_PLATFORM_VERS/$TARGET_PLATFORM_ARCH/$PACKAGE_NAME"
                printf '%s\n' "$PACKAGE_SPEC"
                ;;
            *)  abort 1 "invalid package spec: $1"
        esac
    fi
}

inspect_install_arguments() {
    xcinfo

    # https://stackoverflow.com/questions/18476490/what-is-purpose-of-target-arch-variable-in-makefiles
    unset TARGET_ARCH

    unset USER_SPECIFIED_PACKAGE_SPEC_LIST

    unset DRYRUN

    CCACHE_ENABLED=no

    LOG_LEVEL_QUIET=0
    LOG_LEVEL_NORMAL=1
    LOG_LEVEL_VERBOSE=2
    LOG_LEVEL_VERY_VERBOSE=3

    LOG_LEVEL=$LOG_LEVEL_NORMAL

    BUILD_NJOBS=$NATIVE_OS_NCPU

    BUILD_TYPE=release

    LINK_TYPE=static-prefered

    INSTALL_LIB=static

    KEEP_WORKING_DIR=no

    EXPORT_COMPILE_COMMANDS_JSON=no

    while [ -n "$1" ]
    do
        case $1 in
            -vv)
                LOG_LEVEL=$LOG_LEVEL_VERY_VERBOSE
                ;;
            -v)
                LOG_LEVEL=$LOG_LEVEL_VERBOSE
                ;;
            -q)
                LOG_LEVEL=$LOG_LEVEL_QUIET
                ;;
            --disable-ccache)
                CCACHE_ENABLED=no
                ;;
            --dry-run)
                DRYRUN=yes
                ;;
            --keep-working-dir)
                KEEP_WORKING_DIR=yes
                ;;
            --export-compile-commands-json)
                EXPORT_COMPILE_COMMANDS_JSON=yes
                ;;
            --install-lib=*)
                INSTALL_LIB="${1#*=}"
                case $INSTALL_LIB in
                    static|shared|both|yes|no) ;;
                    '') abort 1 "--install-lib=<VALUE>, VALUE must be non-empty." ;;
                    *)  abort 1 "--install-lib=<VALUE>, VALUE must be one of static|shared|both|yes|no"
                esac
                ;;
            --build-type=*)
                BUILD_TYPE="${1#*=}"
                case $BUILD_TYPE in
                    debug|release) ;;
                    '') abort 1 "--build-type=<VALUE>, VALUE must be non-empty." ;;
                    *)  abort 1 "--build-type=<VALUE>, VALUE must be one of debug|release"
                esac
                ;;
            --link-type=*)
                LINK_TYPE="${1#*=}"
                case $LINK_TYPE in
                    static-only|shared-only|static-prefered|shared-prefered) ;;
                    '') abort 1 "--link-type=<VALUE>, VALUE must be non-empty." ;;
                    *)  abort 1 "--link-type=<VALUE>, VALUE must be one of static-only|shared-only|static-prefered|shared-prefered"
                esac
                ;;
            --jobs=*)
                BUILD_NJOBS="${1#*=}"
                is_integer "$BUILD_NJOBS" || abort 1 "--jobs=INTEGER argument's value must be an integer."
                ;;
            -*) abort 1 "unrecognized option: $1"
                ;;
            *)  PACKAGE_SPEC=
                PACKAGE_SPEC="$(inspect_package_spec "$1")"

                if [ -z "$USER_SPECIFIED_PACKAGE_SPEC_LIST" ] ; then
                    USER_SPECIFIED_PACKAGE_SPEC_LIST="$PACKAGE_SPEC"
                else
                    USER_SPECIFIED_PACKAGE_SPEC_LIST="$USER_SPECIFIED_PACKAGE_SPEC_LIST $PACKAGE_SPEC"
                fi
        esac
        shift
    done

    if [ "$LOG_LEVEL" -eq "$LOG_LEVEL_QUIET" ] ; then
        exec 1>/dev/null
        exec 2>&1
    fi
}

__install_the_given_packages() {
    inspect_install_arguments "$@"

    [ -z "$USER_SPECIFIED_PACKAGE_SPEC_LIST" ] && abort 1 "$_0 install <PACKAGE-SPEC|PACKAGE-NAME>..., <|PACKAGE-SPEC|PACKAGE-NAME> is unspecified."

    #########################################################################################

    SESSION_DIR="$XCPKG_HOME/installing/.session/$$"

    rm -rf     "$SESSION_DIR"
    install -d "$SESSION_DIR"

    #########################################################################################

    # 1. check if has circle
    # 2. backup formulas
    # 3. cache variables

    for USER_SPECIFIED_PACKAGE_SPEC in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        STACK="${USER_SPECIFIED_PACKAGE_SPEC##*/}"

        while [ -n "$STACK" ]
        do
            case $STACK in
                *\;*) PACKAGE_NAME="${STACK##*;}" ; STACK="${STACK%;*}" ;;
                *)    PACKAGE_NAME="${STACK}"     ; STACK=
            esac

            if [ -f "$SESSION_DIR/$PACKAGE_NAME.yml" ] ; then
                continue
            fi

            __load_formula_of_the_given_package "$PACKAGE_NAME"

            cp "$PACKAGE_FORMULA_FILEPATH" "$SESSION_DIR/$PACKAGE_NAME.yml"

            eval "PACKAGE_DEP_PKG_${PACKAGE_NAME_UPPERCASE_UNDERSCORE}='$PACKAGE_DEP_PKG'"

            for DEPENDENT_PACKAGE_NAME in $PACKAGE_DEP_PKG
            do
                if [ "$DEPENDENT_PACKAGE_NAME" = "$PACKAGE_NAME" ] ; then
                    abort 1 "package '$PACKAGE_NAME' depends itself."
                fi

                if [ -z "$STACK" ] ; then
                    STACK="$DEPENDENT_PACKAGE_NAME"
                else
                    STACK="$STACK;$DEPENDENT_PACKAGE_NAME"
                fi
            done
        done
    done

    #########################################################################################

    for USER_SPECIFIED_PACKAGE_SPEC in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        unset TARGET_PLATFORM_NAME
        unset TARGET_PLATFORM_VERS
        unset TARGET_PLATFORM_ARCH

        TARGET_PLATFORM_NAME="$(printf '%s\n' "$USER_SPECIFIED_PACKAGE_SPEC" | cut -d/ -f1)"
        TARGET_PLATFORM_VERS="$(printf '%s\n' "$USER_SPECIFIED_PACKAGE_SPEC" | cut -d/ -f2)"
        TARGET_PLATFORM_ARCH="$(printf '%s\n' "$USER_SPECIFIED_PACKAGE_SPEC" | cut -d/ -f3)"

        TARGET_PLATFORM_SPEC="$TARGET_PLATFORM_NAME/$TARGET_PLATFORM_VERS/$TARGET_PLATFORM_ARCH"

        ##################################################################

        TO_BE_INSTALLED_PACKAGE_NAMES=

        STACK="${USER_SPECIFIED_PACKAGE_SPEC##*/}"

        while [ -n "$STACK" ]
        do
            case $STACK in
                *\;*) PACKAGE_NAME="${STACK##*;}" ; STACK="${STACK%;*}" ;;
                *)    PACKAGE_NAME="${STACK}"     ; STACK=
            esac

            ##################################################################

            TO_BE_INSTALLED_PACKAGE_NAMES2="$PACKAGE_NAME"

            for item in $TO_BE_INSTALLED_PACKAGE_NAMES
            do
                [ "$item" = "$PACKAGE_NAME" ] && continue
                TO_BE_INSTALLED_PACKAGE_NAMES2="$TO_BE_INSTALLED_PACKAGE_NAMES2 $item"
            done

            TO_BE_INSTALLED_PACKAGE_NAMES="$TO_BE_INSTALLED_PACKAGE_NAMES2"

            ##################################################################

            PACKAGE_NAME_UPPERCASE_UNDERSCORE="$(printf '%s\n' "$PACKAGE_NAME" | tr a-z A-Z | tr '@+-.' '_')"

            for item in $(eval echo \$PACKAGE_DEP_PKG_"${PACKAGE_NAME_UPPERCASE_UNDERSCORE}")
            do
                if [ -z "$STACK" ] ; then
                    STACK="$item"
                else
                    STACK="$STACK;$item"
                fi
            done
        done

        ##################################################################

        for PACKAGE_NAME in $TO_BE_INSTALLED_PACKAGE_NAMES
        do
            PACKAGE_SPEC="$TARGET_PLATFORM_SPEC/$PACKAGE_NAME"

            if is_package_installed "$PACKAGE_SPEC" ; then
                if [ "$LOG_LEVEL" -gt 0 ] ; then
                    printf "$COLOR_GREEN%-10s$COLOR_OFF already have been installed.\n" "$PACKAGE_SPEC"
                fi
            else
                (__install_the_given_package "$PACKAGE_SPEC")
            fi
        done
    done
}

__install_the_given_package_onexit() {
    if [ "$DRYRUN" != yes ] ; then
        is_package_installed "$PACKAGE_SPEC" || abort 1 "package installation failure: $PACKAGE_SPEC"
    fi
}

# Note: this function must run in a subshell
__install_the_given_package() {
    printf '%b\n' "${COLOR_PURPLE}=============== Installing ${COLOR_OFF}${COLOR_GREEN}${1}${COLOR_OFF}${COLOR_PURPLE} ===============${COLOR_OFF}"

    trap  __install_the_given_package_onexit EXIT

    # brew install meson
    # Error: The current work directory doesn't exist, cannot proceed.
    # beacuse previous package's work direcotory is deleted.
    cd "$HOME"

    #########################################################################################

    STATIC_LIBRARY_SUFFIX=.a
    SHARED_LIBRARY_SUFFIX=.dylib

    if [ "$TARGET_PLATFORM_NAME-$TARGET_PLATFORM_ARCH" = "$NATIVE_OS_NAME-$NATIVE_OS_ARCH" ] ; then
        CROSS_COMPILING=no
    else
        CROSS_COMPILING=yes
    fi

    TARGET_PLATFORM_NAME_LOWER_CASE="$(printf "$TARGET_PLATFORM_NAME" | tr A-Z a-z)"

    #########################################################################################

    printf '%s\n' "
     TIMESTAMP_UNIX = $TIMESTAMP_UNIX

     NATIVE_OS_KIND = $NATIVE_OS_KIND
     NATIVE_OS_TYPE = $NATIVE_OS_TYPE
     NATIVE_OS_NAME = $NATIVE_OS_NAME
     NATIVE_OS_VERS = $NATIVE_OS_VERS
     NATIVE_OS_ARCH = $NATIVE_OS_ARCH
     NATIVE_OS_NCPU = $NATIVE_OS_NCPU
     NATIVE_OS_EUID = $NATIVE_OS_EUID
     NATIVE_OS_EGID = $NATIVE_OS_EGID

XCPKG_VERSION        = $XCPKG_VERSION
XCPKG_HOME           = $XCPKG_HOME
XCPKG                = $XCPKG
XCPKG_URL_TRANSFORM  = $XCPKG_URL_TRANSFORM

          LOG_LEVEL = $LOG_LEVEL
          LINK_TYPE = $LINK_TYPE
         BUILD_TYPE = $BUILD_TYPE

             DRYRUN = ${DRYRUN:-no}
     CCACHE_ENABLED = $CCACHE_ENABLED
    CROSS_COMPILING = $CROSS_COMPILING
   KEEP_WORKING_DIR = $KEEP_WORKING_DIR
EXPORT_COMPILE_COMMANDS_JSON = $EXPORT_COMPILE_COMMANDS_JSON
    "

    #########################################################################################

    step "create and change to working directory"

    PACKAGE_INSTALL_DIR="$XCPKG_HOME/installed/$1"
    PACKAGE_WORKING_DIR="$XCPKG_HOME/installing/$1"

    PACKAGE_INSTALLING_SRC_DIR="$PACKAGE_WORKING_DIR/src"
    PACKAGE_INSTALLING_FIX_DIR="$PACKAGE_WORKING_DIR/fix"
    PACKAGE_INSTALLING_RES_DIR="$PACKAGE_WORKING_DIR/res"
    PACKAGE_INSTALLING_BIN_DIR="$PACKAGE_WORKING_DIR/bin"
    PACKAGE_INSTALLING_LIB_DIR="$PACKAGE_WORKING_DIR/lib"
    PACKAGE_INSTALLING_INC_DIR="$PACKAGE_WORKING_DIR/include"

    PACKAGE_BCACHED_DIR="$PACKAGE_WORKING_DIR/src/_"

    rm -rf     "$PACKAGE_WORKING_DIR"

    install -d "$PACKAGE_INSTALLING_SRC_DIR"
    install -d "$PACKAGE_INSTALLING_FIX_DIR"
    install -d "$PACKAGE_INSTALLING_RES_DIR"
    install -d "$PACKAGE_INSTALLING_BIN_DIR"
    install -d "$PACKAGE_INSTALLING_INC_DIR"
    install -d "$PACKAGE_INSTALLING_LIB_DIR"
    install -d "$PACKAGE_BCACHED_DIR"

    cat <<EOF
PACKAGE_WORKING_DIR = $PACKAGE_WORKING_DIR
PACKAGE_BCACHED_DIR = $PACKAGE_BCACHED_DIR
PACKAGE_INSTALL_DIR = $PACKAGE_INSTALL_DIR
EOF

    run cd "$PACKAGE_WORKING_DIR"

    #########################################################################################

    step "locate C/C++ toolchain for native build"

    # https://www.real-world-systems.com/docs/xcrun.1.html
    # do not use this environment variable
    unset SDKROOT

    unset      CC_FOR_BUILD
    unset    OBJC_FOR_BUILD
    unset     CXX_FOR_BUILD
    unset     CPP_FOR_BUILD
    unset      AS_FOR_BUILD
    unset      AR_FOR_BUILD
    unset  RANLIB_FOR_BUILD
    unset      LD_FOR_BUILD
    unset      NM_FOR_BUILD
    unset    SIZE_FOR_BUILD
    unset   STRIP_FOR_BUILD
    unset STRINGS_FOR_BUILD
    unset OBJDUMP_FOR_BUILD
    unset SYSROOT_FOR_BUILD

         CC_FOR_BUILD="$(xcrun --sdk macosx --find clang)"
       OBJC_FOR_BUILD="$(xcrun --sdk macosx --find clang)"
        CXX_FOR_BUILD="$(xcrun --sdk macosx --find clang++)"
         AS_FOR_BUILD="$(xcrun --sdk macosx --find as)"
         AR_FOR_BUILD="$(xcrun --sdk macosx --find ar)"
     RANLIB_FOR_BUILD="$(xcrun --sdk macosx --find ranlib)"
         LD_FOR_BUILD="$(xcrun --sdk macosx --find ld)"
         NM_FOR_BUILD="$(xcrun --sdk macosx --find nm)"
       SIZE_FOR_BUILD="$(xcrun --sdk macosx --find size)"
      STRIP_FOR_BUILD="$(xcrun --sdk macosx --find strip)"
    STRINGS_FOR_BUILD="$(xcrun --sdk macosx --find strings)"
    OBJDUMP_FOR_BUILD="$(xcrun --sdk macosx --find objdump)"
    SYSROOT_FOR_BUILD="$(xcrun --sdk macosx --show-sdk-path)"

    for TOOL in CC OBJC CXX AS AR RANLIB LD NM STRIP SIZE STRINGS OBJDUMP SYSROOT
    do
        export "${TOOL}_FOR_BUILD"
        printf "%17s = %s\n" "${TOOL}_FOR_BUILD" "$(eval echo \$"${TOOL}_FOR_BUILD")"
    done

    ##################################################################################

    step "create proxy for C/C++ compiler for native build"

    cat > proxy-cc-for-build.c <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char * argv[]) {
    char * PROXIED_PROGRAM = NULL;

    if (argv[0][strlen(argv[0]) - 1] == '+') {
        PROXIED_PROGRAM = getenv("PROXIED_CXX_FOR_BUILD");

        if (PROXIED_PROGRAM == NULL) {
            fprintf(stderr, "PROXIED_CXX_FOR_BUILD environment variable is not set.\n");
            return 2;
        }
    } else {
        PROXIED_PROGRAM = getenv("PROXIED_CC_FOR_BUILD");

        if (PROXIED_PROGRAM == NULL) {
            fprintf(stderr, "PROXIED_CC_FOR_BUILD environment variable is not set.\n");
            return 2;
        }
    }

    char * SYSROOT = getenv("SYSROOT_FOR_BUILD");

    if (SYSROOT == NULL) {
        fprintf(stderr, "SYSROOT_FOR_BUILD environment variable is not set.\n");
        return 2;
    }

    size_t sysrootLength = strlen(SYSROOT) + 11;
    char   sysroot[sysrootLength];
    snprintf(sysroot, sysrootLength, "--sysroot=%s", SYSROOT);

    char * argv2[argc + 2];

    argv2[0] = PROXIED_PROGRAM;
    argv2[1] = sysroot;

    for (int i = 1; i < argc; i++) {
        argv2[i + 1] = argv[i];
    }

    argv2[argc + 1] = NULL;

    if (PROXIED_PROGRAM[0] == '/') {
        execv (PROXIED_PROGRAM, argv2);
        perror(PROXIED_PROGRAM);
        return -1;
    } else {
        execvp(PROXIED_PROGRAM, argv2);
        perror(PROXIED_PROGRAM);
        return -1;
    }

    return 0;
}
EOF

    PROXY_CC_FOR_BUILD="$XCPKG_CORE_BIN_DIR/proxy-native-cc"
    PROXY_CXX_FOR_BUILD="$XCPKG_CORE_BIN_DIR/proxy-native-c++"

    run "$CC_FOR_BUILD" -std=c99 -isysroot "$SYSROOT_FOR_BUILD" -o "$PROXY_CC_FOR_BUILD" proxy-cc-for-build.c

    run ln -sfr "$PROXY_CC_FOR_BUILD" "$PROXY_CXX_FOR_BUILD"

    export PROXIED_CC_FOR_BUILD="$CC_FOR_BUILD"
    export PROXIED_CXX_FOR_BUILD="$CXX_FOR_BUILD"

    export CC_FOR_BUILD="$PROXY_CC_FOR_BUILD"
    export CXX_FOR_BUILD="$PROXY_CXX_FOR_BUILD"
    export CPP_FOR_BUILD="$CC_FOR_BUILD -E"

cat <<EOF
PROXIED_CC_FOR_BUILD  = $PROXIED_CC_FOR_BUILD
PROXIED_CXX_FOR_BUILD = $PROXIED_CXX_FOR_BUILD

        CC_FOR_BUILD  = $CC_FOR_BUILD
        CPP_FOR_BUILD = $CPP_FOR_BUILD
        CXX_FOR_BUILD = $CXX_FOR_BUILD
EOF

    #########################################################################################

    step "config CFLAGS_FOR_BUILD OBJCFLAGS_FOR_BUILD CXXFLAGS_FOR_BUILD CPPFLAGS_FOR_BUILD LDFLAGS_FOR_BUILD"

    export    CFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH -Qunused-arguments"
    export OBJCFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH -Qunused-arguments"
    export  CXXFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH -Qunused-arguments"
    export  CPPFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -Qunused-arguments"
    export   LDFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH"

    if [ "$LOG_LEVEL" -ge 3 ] ; then
          CFLAGS_FOR_BUILD="$CFLAGS_FOR_BUILD -v"
        CXXFLAGS_FOR_BUILD="$CXXFLAGS_FOR_BUILD -v"
       OBJCFLAGS_FOR_BUILD="$OBJCFLAGS_FOR_BUILD -v"
         LDFLAGS_FOR_BUILD="$LDFLAGS_FOR_BUILD -Wl,-v"
    fi

    if [ "$BUILD_TYPE" = release ] ; then
          CFLAGS_FOR_BUILD="$CFLAGS_FOR_BUILD -Os"
        CXXFLAGS_FOR_BUILD="$CXXFLAGS_FOR_BUILD -Os"
       OBJCFLAGS_FOR_BUILD="$OBJCFLAGS_FOR_BUILD -Os"
         LDFLAGS_FOR_BUILD="$LDFLAGS_FOR_BUILD -Wl,-S"
    fi

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CFLAGS_FOR_BUILD"
    printf '%s\n' "$CFLAGS_FOR_BUILD"   | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} OBJCFLAGS_FOR_BUILD"
    printf '%s\n' "$OBJCFLAGS_FOR_BUILD" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CXXFLAGS_FOR_BUILD"
    printf '%s\n' "$CXXFLAGS_FOR_BUILD" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CPPFLAGS_FOR_BUILD"
    printf '%s\n' "$CPPFLAGS_FOR_BUILD" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} LDFLAGS_FOR_BUILD"
    printf '%s\n' "$LDFLAGS_FOR_BUILD"  | xargs printf '        %s\n'

    #########################################################################################

    # install perl module need these, they will be override when cross compile starting

    export      CC="$CC_FOR_BUILD"
    export    OBJC="$OBJC_FOR_BUILD"
    export     CXX="$CXX_FOR_BUILD"
    export     CPP="$CPP_FOR_BUILD"
    export      AS="$AS_FOR_BUILD"
    export      AR="$AR_FOR_BUILD"
    export  RANLIB="$RANLIB_FOR_BUILD"
    export      LD="$LD_FOR_BUILD"
    export      NM="$NM_FOR_BUILD"
    export    SIZE="$SIZE_FOR_BUILD"
    export   STRIP="$STRIP_FOR_BUILD"
    export STRINGS="$STRINGS_FOR_BUILD"
    export OBJDUMP="$OBJDUMP_FOR_BUILD"

    export    CFLAGS="$CFLAGS_FOR_BUILD"
    export OBJCFLAGS="$OBJCFLAGS_FOR_BUILD"
    export  CXXFLAGS="$CXXFLAGS_FOR_BUILD"
    export  CPPFLAGS="$CPPFLAGS_FOR_BUILD"
    export   LDFLAGS="$LDFLAGS_FOR_BUILD"

    #########################################################################################

    PACKAGE_FORMULA_FILEPATH="$SESSION_DIR/$PACKAGE_NAME.yml"

    step "view formula"
    run yq "$PACKAGE_FORMULA_FILEPATH"
   
    step "load formula"
    __load_formula_of_the_given_package "$PACKAGE_NAME" "$PACKAGE_FORMULA_FILEPATH"

    #########################################################################################

    if [ "$PACKAGE_BUILD_IN_PARALLEL" = no ] ; then
        BUILD_NJOBS=1
    fi

    printf '%s\n' "
        BUILD_NJOBS = $BUILD_NJOBS
    "

    #########################################################################################

    unset RECURSIVE_DEPENDENT_PACKAGE_NAMES

    [ -n "$PACKAGE_DEP_PKG" ] && {
        step "calculate dependency list of $1"

        unset STACK

        for item in $PACKAGE_DEP_PKG
        do
            if [ -z "$item" ] ; then
                STACK="$item"
            else
                STACK="$STACK;$item"
            fi
        done

        while [ -n "$STACK" ]
        do
            case $STACK in
                *\;*) TOPE="${STACK##*;}" ; STACK="${STACK%;*}" ;;
                *)    TOPE="${STACK}"     ; STACK=
            esac

            RECURSIVE_DEPENDENT_PACKAGE_NAMES2="$TOPE"

            for item in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
            do
                if [ "$item" != "$TOPE" ] ; then
                    RECURSIVE_DEPENDENT_PACKAGE_NAMES2="$RECURSIVE_DEPENDENT_PACKAGE_NAMES2 $item"
                fi
            done

            RECURSIVE_DEPENDENT_PACKAGE_NAMES="$RECURSIVE_DEPENDENT_PACKAGE_NAMES2"

            unset TOPE_UPPERCASE_UNDERSCORE
            TOPE_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$TOPE" | tr '@+-.' '_' | tr a-z A-Z)

            for item in $(eval echo \$PACKAGE_DEP_PKG_"${TOPE_UPPERCASE_UNDERSCORE}")
            do
                if [ -z "$item" ] ; then
                    STACK="$item"
                else
                    STACK="$STACK;$item"
                fi
            done
        done

        printf '%s\n' "$RECURSIVE_DEPENDENT_PACKAGE_NAMES"
    }

    #########################################################################################

    unset RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS

    [ -n "$PACKAGE_DEP_PKG" ] && {
        for DEPENDENT_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
        do
            DEPENDENT_PACKAGE_INSTALL_DIR="$XCPKG_PACKAGE_INSTALLED_ROOT/$TARGET_PLATFORM_SPEC/$DEPENDENT_PACKAGE_NAME"

            if [ -z "$RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS" ] ; then
                RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR"
            else
                RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS="$RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS $DEPENDENT_PACKAGE_INSTALL_DIR"
            fi

            if [ "$CROSS_COMPILING" = yes ] ; then
                DEPENDENT_PACKAGE_BINARY__DIR="$XCPKG_HOME/native/$DEPENDENT_PACKAGE_NAME/bin"

                if [ -d  "$DEPENDENT_PACKAGE_BINARY__DIR" ] ; then
                    PATH="$DEPENDENT_PACKAGE_BINARY__DIR:$PATH"
                fi

                DEPENDENT_PACKAGE_BINARY__DIR="$XCPKG_HOME/native/$DEPENDENT_PACKAGE_NAME/sbin"

                if [ -d  "$DEPENDENT_PACKAGE_BINARY__DIR" ] ; then
                    PATH="$DEPENDENT_PACKAGE_BINARY__DIR:$PATH"
                fi

                if [ -d          "$XCPKG_HOME/native/$DEPENDENT_PACKAGE_NAME/share/aclocal" ] ; then
                    ACLOCAL_PATH="$XCPKG_HOME/native/$DEPENDENT_PACKAGE_NAME/share/aclocal:$ACLOCAL_PATH"
                fi
            else
                DEPENDENT_PACKAGE_BINARY__DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/bin"

                if [ -d  "$DEPENDENT_PACKAGE_BINARY__DIR" ] ; then
                    PATH="$DEPENDENT_PACKAGE_BINARY__DIR:$PATH"
                fi

                DEPENDENT_PACKAGE_BINARY__DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/sbin"

                if [ -d  "$DEPENDENT_PACKAGE_BINARY__DIR" ] ; then
                    PATH="$DEPENDENT_PACKAGE_BINARY__DIR:$PATH"
                fi
            fi

            if [ "$DEPENDENT_PACKAGE_NAME" = docbook ] ; then
                # http://xmlsoft.org/xslt/xsltproc.html
                export XML_CATALOG_FILES="$DEPENDENT_PACKAGE_INSTALL_DIR/catalog.xml"
                printf '%s\n' "XML_CATALOG_FILES=$XML_CATALOG_FILES"
            fi
        done
    }

    #########################################################################################

    [ -n "$PACKAGE_DEP_PKG" ] && {
        step "generate  dependency tree of $1"

        unset DOT_CONTENT

        STACK="$PACKAGE_NAME"

        while [ -n "$STACK" ]
        do
            case $STACK in
                *\;*) TOPE="${STACK##*;}" ; STACK="${STACK%;*}" ;;
                *)    TOPE="${STACK}"     ; STACK=
            esac

            unset TOPE_UPPERCASE_UNDERSCORE
            TOPE_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$TOPE" | tr '@+-.' '_' | tr a-z A-Z)

            TOPE_DEP_PKG="$(eval echo \$PACKAGE_DEP_PKG_"${TOPE_UPPERCASE_UNDERSCORE}")"

            if [ -n "$TOPE_DEP_PKG" ] ; then
                unset X; X="$(printf '"%s" ' $TOPE_DEP_PKG)"
                unset Y; Y="$(printf '    "%s" -> { %s}\n' "$TOPE" "$X")"

                if [ -z "$DOT_CONTENT" ] ; then
                    DOT_CONTENT="$Y"
                else
                    DOT_CONTENT="$(printf '%s\n%s\n' "$DOT_CONTENT" "$Y")"
                fi
            fi

            for item in $TOPE_DEP_PKG
            do

                if [ -z "$item" ] ; then
                    STACK="$item"
                else
                    STACK="$STACK;$item"
                fi
            done
        done

        DOT_CONTENT="digraph G {
$DOT_CONTENT
}"

        ############################################################################

        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT="$PACKAGE_WORKING_DIR/dependencies.dot"
        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX="$PACKAGE_WORKING_DIR/dependencies.box"

        ############################################################################

        printf '%s\n' "$DOT_CONTENT" > "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT"

        ############################################################################

        # https://github.com/ggerganov/dot-to-ascii
        curl \
            -o "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX" \
            -s \
            -G \
            --data-urlencode "boxart=1" \
            --data-urlencode "src=$DOT_CONTENT" \
            "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php" || true

        ############################################################################

        command -v dot > /dev/null && {
            run dot -Tsvg -o "$PACKAGE_WORKING_DIR/dependencies.svg" "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT" || true
            run dot -Tpng -o "$PACKAGE_WORKING_DIR/dependencies.png" "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT" || true
        }

        ############################################################################

        if [ -f "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX" ] ; then
            cat "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX"
        else
            cat "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT"
        fi
    }

    #########################################################################################

    PACKAGE_DEP_UPP="${PACKAGE_DEP_UPP#' '}"

    PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP pkg-config"

    if [ "$PACKAGE_BUILD_SYSTEM_GMAKE" = yes ] && [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] && [ "$BEAR_ENABLED" = yes ] ; then
        PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL bear"
    fi

    if [ "$CCACHE_ENABLED" = yes ] ; then
        PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL ccache"
    fi

    PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL tree"

    #########################################################################################

    if [ "$XCPKG_USE_EXTERNAL_PACKAGE_MANAGER" = brew ] ; then
        step "install needed packages via brew"

        BREW=
        BREW="$(command -v brew)" || abort 1 "command not found: brew"

        #run "$BREW" update
        run "$BREW" --env

        for item in $PACKAGE_DEP_UPP_ALL
        do
            BREW_PACKAGE_NAME=
            BREW_PACKAGE_NAME=$(package_name_transform_from_uppm_to_brew "$item")

            if [ "$BREW_PACKAGE_NAME" = 'python3' ] ; then
                run "$BREW" install --overwrite "$BREW_PACKAGE_NAME"
            else
                run "$BREW" install             "$BREW_PACKAGE_NAME"
            fi

            BREW_PACKAGE_INSTALLED_DIR=
            BREW_PACKAGE_INSTALLED_DIR="$("$BREW" --prefix "$BREW_PACKAGE_NAME")"

            if [ -d  "$BREW_PACKAGE_INSTALLED_DIR/bin" ] ; then
                PATH="$BREW_PACKAGE_INSTALLED_DIR/bin:$PATH"
            fi

            if [ -d  "$BREW_PACKAGE_INSTALLED_DIR/sbin" ] ; then
                PATH="$BREW_PACKAGE_INSTALLED_DIR/sbin:$PATH"
            fi

            if [ -d  "$BREW_PACKAGE_INSTALLED_DIR/libexec/gnubin" ] ; then
                PATH="$BREW_PACKAGE_INSTALLED_DIR/libexec/gnubin:$PATH"
            fi
        done
    elif [ "$XCPKG_USE_EXTERNAL_PACKAGE_MANAGER" = uppm ] ; then
        step "install needed packages via uppm"

        UPPM="$XCPKG_CORE_BIN_DIR/uppm"

        run "$UPPM" env
        run "$UPPM" update

        # these packages are not relocatable, we should build them from source locally.
        PACKAGE_USE_PERL=no
        PACKAGE_USE_PYTHON3=no
        PACKAGE_USE_LIBTOOL=no
        PACKAGE_USE_AUTOMAKE=no
        PACKAGE_USE_AUTOCONF=no

        for item in $PACKAGE_DEP_UPP_ALL
        do
            case $item in
                perl)     PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake"       ; PACKAGE_USE_PERL=yes ;;
                python3)  PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake cmake" ; PACKAGE_USE_PYTHON3=yes  ; PACKAGE_USE_PERL=yes  ;;
                libtool)  PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake gm4"   ; PACKAGE_USE_LIBTOOL=yes  ;;
                autoconf) PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake"       ; PACKAGE_USE_AUTOCONF=yes ;;
                automake) PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake"       ; PACKAGE_USE_AUTOCONF=yes ; PACKAGE_USE_AUTOMAKE=yes ;;
            esac
        done

        for item in $PACKAGE_DEP_UPP_ALL
        do
            case $item in
                perl|python3|libtool|autoconf|automake) continue
            esac

            run "$UPPM" install "$item"

            UPPM_PACKAGE_INSTALLED_DIR="$("$UPPM" info "$item" installed-dir)"

            if [ -d  "$UPPM_PACKAGE_INSTALLED_DIR/bin" ] ; then
                PATH="$UPPM_PACKAGE_INSTALLED_DIR/bin:$PATH"
            fi

            if [ -d  "$UPPM_PACKAGE_INSTALLED_DIR/sbin" ] ; then
                PATH="$UPPM_PACKAGE_INSTALLED_DIR/sbin:$PATH"
            fi

            if [ -d          "$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal" ] ; then
                ACLOCAL_PATH="$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal:$ACLOCAL_PATH"
            fi
        done

        (
            export CPPFLAGS="$CPPFLAGS -I$XCPKG_CORE_DIR/include"
            export  LDFLAGS="$LDFLAGS  -L$XCPKG_CORE_DIR/lib -Wl,-rpath,$XCPKG_CORE_DIR/lib"

            export PKG_CONFIG_PATH="$XCPKG_CORE_DIR/lib/pkgconfig"

            unset MACOSX_DEPLOYMENT_TARGET

            GMAKE="$HOME/.uppm/installed/gmake/bin/gmake"
            CMAKE="$HOME/.uppm/installed/cmake/bin/cmake"

            [ "$PACKAGE_USE_PERL" = yes ] && {
                step "install perl"

                SRC_URL='https://cpan.metacpan.org/authors/id/R/RJ/RJBS/perl-5.36.0.tar.xz'
                SRC_SHA='0f386dccbee8e26286404b2cca144e1005be65477979beb9b1ba272d4819bcf0'

                RECEIPT_FILEPATH="$XCPKG_CORE_DIR/.perl"

                if [ -f "$RECEIPT_FILEPATH" ] && [ "$(cat "$RECEIPT_FILEPATH")" = "$SRC_SHA" ] ; then
                    note "perl already has been built, skipped."
                else
                    wfetch "$SRC_URL" --sha256="$SRC_SHA" --output-dir="$XCPKG_DOWNLOADS_DIR"

                    SRC_DIR="$PACKAGE_WORKING_DIR/$TIMESTAMP_UNIX/perl"

                    run install -d "$SRC_DIR"
                    run cd         "$SRC_DIR"

                    run tar vxf "$FETCH_OUTPUT_PATH" --strip-components=1 --no-same-owner

                    run ./Configure "-Dprefix=$XCPKG_CORE_DIR" "-Dman1dir=$XCPKG_CORE_DIR/share/man/man1" "-Dman3dir=$XCPKG_CORE_DIR/share/man/man3" -des -Dmake=gmake -Duselargefiles -Duseshrplib -Dusethreads -Dusenm=false -Dusedl=true
                    run "$GMAKE" "--jobs=$NATIVE_OS_NCPU"
                    run "$GMAKE" install

                    printf '%s\n' "$SRC_SHA" > "$RECEIPT_FILEPATH"
                fi
            }

            [ "$PACKAGE_USE_LIBTOOL" = yes ] && {
                step "install libtool"

                SRC_URL='https://ftp.gnu.org/gnu/libtool/libtool-2.4.7.tar.xz'
                SRC_SHA='4f7f217f057ce655ff22559ad221a0fd8ef84ad1fc5fcb6990cecc333aa1635d'

                RECEIPT_FILEPATH="$XCPKG_CORE_DIR/.libtool"

                if [ -f "$RECEIPT_FILEPATH" ] && [ "$(cat "$RECEIPT_FILEPATH")" = "$SRC_SHA" ] ; then
                    note "libtool already has been built, skipped."
                else
                    wfetch "$SRC_URL" --sha256="$SRC_SHA" --output-dir="$XCPKG_DOWNLOADS_DIR"

                    SRC_DIR="$PACKAGE_WORKING_DIR/$TIMESTAMP_UNIX/libtool"

                    run install -d "$SRC_DIR"
                    run cd         "$SRC_DIR"

                    run tar vxf "$FETCH_OUTPUT_PATH" --strip-components=1 --no-same-owner

                    run ./configure "--prefix=$XCPKG_CORE_DIR" --enable-ltdl-install
                    run "$GMAKE" "--jobs=$NATIVE_OS_NCPU"
                    run "$GMAKE" install

                    printf '%s\n' "$SRC_SHA" > "$RECEIPT_FILEPATH"
                fi
            }

            [ "$PACKAGE_USE_AUTOCONF" = yes ] && {
                step "install autoconf"

                SRC_URL='https://ftp.gnu.org/gnu/autoconf/autoconf-2.71.tar.gz'
                SRC_SHA='431075ad0bf529ef13cb41e9042c542381103e80015686222b8a9d4abef42a1c'

                RECEIPT_FILEPATH="$XCPKG_CORE_DIR/.autoconf"

                if [ -f "$RECEIPT_FILEPATH" ] && [ "$(cat "$RECEIPT_FILEPATH")" = "$SRC_SHA" ] ; then
                    note "autoconf already has been built, skipped."
                else
                    wfetch "$SRC_URL" --sha256="$SRC_SHA" --output-dir="$XCPKG_DOWNLOADS_DIR"

                    SRC_DIR="$PACKAGE_WORKING_DIR/$TIMESTAMP_UNIX/autoconf"

                    run install -d "$SRC_DIR"
                    run cd         "$SRC_DIR"

                    run tar vxf "$FETCH_OUTPUT_PATH" --strip-components=1 --no-same-owner

                    run ./configure "--prefix=$XCPKG_CORE_DIR"
                    run "$GMAKE" "--jobs=$NATIVE_OS_NCPU"
                    run "$GMAKE" install

                    printf '%s\n' "$SRC_SHA" > "$RECEIPT_FILEPATH"
                fi
            }

            [ "$PACKAGE_USE_AUTOMAKE" = yes ] && {
                step "install automake"

                SRC_URL='https://ftp.gnu.org/gnu/automake/automake-1.16.5.tar.xz'
                SRC_SHA='f01d58cd6d9d77fbdca9eb4bbd5ead1988228fdb73d6f7a201f5f8d6b118b469'

                RECEIPT_FILEPATH="$XCPKG_CORE_DIR/.automake"

                if [ -f "$RECEIPT_FILEPATH" ] && [ "$(cat "$RECEIPT_FILEPATH")" = "$SRC_SHA" ] ; then
                    note "automake already has been built, skipped."
                else
                    wfetch "$SRC_URL" --sha256="$SRC_SHA" --output-dir="$XCPKG_DOWNLOADS_DIR"

                    SRC_DIR="$PACKAGE_WORKING_DIR/$TIMESTAMP_UNIX/automake"

                    run install -d "$SRC_DIR"
                    run cd         "$SRC_DIR"

                    run tar vxf "$FETCH_OUTPUT_PATH" --strip-components=1 --no-same-owner

                    run ./configure "--prefix=$XCPKG_CORE_DIR"
                    run "$GMAKE" "--jobs=$NATIVE_OS_NCPU"
                    run "$GMAKE" install

                    printf '%s\n' "$SRC_SHA" > "$RECEIPT_FILEPATH"
                fi
            }

            [ "$PACKAGE_USE_PYTHON3" = yes ] && {
                step "install zlib"

                ZLIB_FORMULA_FILEPATH="$XCPKG_FORMULA_REPO_ROOT/offical-core/formula/zlib.yml"

                SRC_URL="$(yq .src-url "$ZLIB_FORMULA_FILEPATH")"
                SRC_SHA="$(yq .src-sha "$ZLIB_FORMULA_FILEPATH")"

                RECEIPT_FILEPATH="$XCPKG_CORE_DIR/.zlib"

                if [ -f "$RECEIPT_FILEPATH" ] && [ "$(cat "$RECEIPT_FILEPATH")" = "$SRC_SHA" ] ; then
                    note "zlib already has been built, skipped."
                else
                    wfetch "$SRC_URL" --sha256="$SRC_SHA" --output-dir="$XCPKG_DOWNLOADS_DIR"

                    SRC_DIR="$PACKAGE_WORKING_DIR/$TIMESTAMP_UNIX/zlib"

                    run install -d "$SRC_DIR"
                    run cd         "$SRC_DIR"

                    run tar vxf "$FETCH_OUTPUT_PATH" --strip-components=1 --no-same-owner

                    sed_in_place 's|/share/pkgconfig|/lib/pkgconfig|' CMakeLists.txt

                    run "$CMAKE" -DCMAKE_INSTALL_PREFIX=$XCPKG_CORE_DIR -DCMAKE_INSTALL_LIBDIR=lib -DCMAKE_VERBOSE_MAKEFILE=OFF -S . -B build.d
                    run "$CMAKE" --build   build.d -- "--jobs=$NATIVE_OS_NCPU"
                    run "$CMAKE" --install build.d

                    printf '%s\n' "$SRC_SHA" > "$RECEIPT_FILEPATH"
                fi

                ################################################################################################

                step "install sqlite3"

                SQLITE_FORMULA_FILEPATH="$XCPKG_FORMULA_REPO_ROOT/offical-core/formula/sqlite.yml"

                SRC_URL="$(yq .src-url "$SQLITE_FORMULA_FILEPATH")"
                SRC_SHA="$(yq .src-sha "$SQLITE_FORMULA_FILEPATH")"

                RECEIPT_FILEPATH="$XCPKG_CORE_DIR/.sqlite"

                if [ -f "$RECEIPT_FILEPATH" ] && [ "$(cat "$RECEIPT_FILEPATH")" = "$SRC_SHA" ] ; then
                    note "sqlite3 already has been built, skipped."
                else
                    wfetch "$SRC_URL" --sha256="$SRC_SHA" --output-dir="$XCPKG_DOWNLOADS_DIR"

                    SRC_DIR="$PACKAGE_WORKING_DIR/$TIMESTAMP_UNIX/sqlite"

                    run install -d "$SRC_DIR"
                    run cd         "$SRC_DIR"

                    run tar vxf "$FETCH_OUTPUT_PATH" --strip-components=1 --no-same-owner

                    run ./configure "--prefix=$XCPKG_CORE_DIR" --disable-dependency-tracking --enable-static --disable-shared --enable-largefile --disable-editline --disable-readline
                    run "$GMAKE" "--jobs=$NATIVE_OS_NCPU"
                    run "$GMAKE" install

                    printf '%s\n' "$SRC_SHA" > "$RECEIPT_FILEPATH"
                fi

                ################################################################################################

                step "install libffi"

                SRC_URL='https://github.com/libffi/libffi/releases/download/v3.4.4/libffi-3.4.4.tar.gz'
                SRC_SHA='d66c56ad259a82cf2a9dfc408b32bf5da52371500b84745f7fb8b645712df676'

                RECEIPT_FILEPATH="$XCPKG_CORE_DIR/.libffi"

                if [ -f "$RECEIPT_FILEPATH" ] && [ "$(cat "$RECEIPT_FILEPATH")" = "$SRC_SHA" ] ; then
                    note "libffi already has been built, skipped."
                else
                    wfetch "$SRC_URL" --sha256="$SRC_SHA" --output-dir="$XCPKG_DOWNLOADS_DIR"

                    SRC_DIR="$PACKAGE_WORKING_DIR/$TIMESTAMP_UNIX/libffi"

                    run install -d "$SRC_DIR"
                    run cd         "$SRC_DIR"

                    run tar vxf "$FETCH_OUTPUT_PATH" --strip-components=1 --no-same-owner

                    run ./configure "--prefix=$XCPKG_CORE_DIR" --disable-dependency-tracking --enable-static --disable-shared --disable-docs --disable-symvers
                    run "$GMAKE" "--jobs=$NATIVE_OS_NCPU"
                    run "$GMAKE" install

                    printf '%s\n' "$SRC_SHA" > "$RECEIPT_FILEPATH"
                fi

                ################################################################################################

                step "install expat"

                SRC_URL='https://github.com/libexpat/libexpat/releases/download/R_2_5_0/expat-2.5.0.tar.xz'
                SRC_SHA='ef2420f0232c087801abf705e89ae65f6257df6b7931d37846a193ef2e8cdcbe'

                RECEIPT_FILEPATH="$XCPKG_CORE_DIR/.expat"

                if [ -f "$RECEIPT_FILEPATH" ] && [ "$(cat "$RECEIPT_FILEPATH")" = "$SRC_SHA" ] ; then
                    note "expat already has been built, skipped."
                else
                    wfetch "$SRC_URL" --sha256="$SRC_SHA" --output-dir="$XCPKG_DOWNLOADS_DIR"

                    SRC_DIR="$PACKAGE_WORKING_DIR/$TIMESTAMP_UNIX/expat"

                    run install -d "$SRC_DIR"
                    run cd         "$SRC_DIR"

                    run tar vxf "$FETCH_OUTPUT_PATH" --strip-components=1 --no-same-owner

                    run "$CMAKE" -DCMAKE_INSTALL_PREFIX=$XCPKG_CORE_DIR -DCMAKE_INSTALL_LIBDIR=lib -DCMAKE_VERBOSE_MAKEFILE=OFF -DEXPAT_BUILD_DOCS=OFF -DEXPAT_BUILD_TESTS=OFF -DEXPAT_BUILD_FUZZERS=OFF -DEXPAT_BUILD_EXAMPLES=OFF -DEXPAT_BUILD_TOOLS=OFF -S . -B build.d
                    run "$CMAKE" --build   build.d -- "--jobs=$NATIVE_OS_NCPU"
                    run "$CMAKE" --install build.d

                    printf '%s\n' "$SRC_SHA" > "$RECEIPT_FILEPATH"
                fi

                ################################################################################################

                step "install openssl"

                SRC_URL='https://www.openssl.org/source/openssl-3.0.5.tar.gz'
                SRC_SHA='aa7d8d9bef71ad6525c55ba11e5f4397889ce49c2c9349dcea6d3e4f0b024a7a'

                RECEIPT_FILEPATH="$XCPKG_CORE_DIR/.openssl"

                if [ -f "$RECEIPT_FILEPATH" ] && [ "$(cat "$RECEIPT_FILEPATH")" = "$SRC_SHA" ] ; then
                    note "openssl already has been built, skipped."
                else
                    wfetch "$SRC_URL" --sha256="$SRC_SHA" --output-dir="$XCPKG_DOWNLOADS_DIR"

                    SRC_DIR="$PACKAGE_WORKING_DIR/$TIMESTAMP_UNIX/openssl"

                    run install -d "$SRC_DIR"
                    run cd         "$SRC_DIR"

                    run tar vxf "$FETCH_OUTPUT_PATH" --strip-components=1 --no-same-owner

                    run ./config no-tests no-ssl3 no-ssl3-method no-zlib --prefix=$XCPKG_CORE_DIR --libdir=$XCPKG_CORE_DIR/lib --openssldir=$XCPKG_CORE_DIR/etc/ssl
                    run "$GMAKE" "--jobs=$NATIVE_OS_NCPU"
                    run "$GMAKE" install

                    printf '%s\n' "$SRC_SHA" > "$RECEIPT_FILEPATH"
                fi

                ################################################################################################

                step "install python3"

                SRC_URL='https://www.python.org/ftp/python/3.11.2/Python-3.11.2.tgz'
                SRC_SHA='2411c74bda5bbcfcddaf4531f66d1adc73f247f529aee981b029513aefdbf849'

                RECEIPT_FILEPATH="$XCPKG_CORE_DIR/.python3"

                if [ -f "$RECEIPT_FILEPATH" ] && [ "$(cat "$RECEIPT_FILEPATH")" = "$SRC_SHA" ] ; then
                    note "python3 already has been built, skipped."
                else
                    wfetch "$SRC_URL" --sha256="$SRC_SHA" --output-dir="$XCPKG_DOWNLOADS_DIR"

                    SRC_DIR="$PACKAGE_WORKING_DIR/$TIMESTAMP_UNIX/python3"

                    run install -d "$SRC_DIR"
                    run cd         "$SRC_DIR"

                    run tar vxf "$FETCH_OUTPUT_PATH" --strip-components=1 --no-same-owner

                    unset PYTHONHOME
                    unset PYTHONPATH

                    run ./configure "--prefix=$XCPKG_CORE_DIR" --with-system-expat --with-system-ffi --with-openssl=$XCPKG_CORE_DIR --with-ensurepip=yes --with-lto --enable-ipv6 --enable-shared --enable-largefile --disable-option-checking --disable-nls --disable-debug --enable-loadable-sqlite-extensions --disable-profiling
                    run "$GMAKE" "--jobs=$NATIVE_OS_NCPU"
                    run "$GMAKE" install

                    printf '%s\n' "$SRC_SHA" > "$RECEIPT_FILEPATH"
                fi
            }

            :
        )
    fi

    PATH="$(printf '%s\n' "$PATH" | sed "s|:$XCPKG_CORE_BIN_DIR||g")"
    PATH="$XCPKG_CORE_BIN_DIR:$PATH"

    #########################################################################################

    [ -n "$PACKAGE_DEP_PYM" ] && {
        step "install needed python packages via pip3"

        run pip3 --version
        run pip3 install --upgrade pip setuptools wheel
        run pip3 --version

        for item in $PACKAGE_DEP_PYM
        do
            run pip3 install "$item" --upgrade
        done
    }

    #########################################################################################

    # cpan use the C/C++ compiler same as perl was built with
    # so make sure C/C++ compiler be found before reaching here

    [ -n "$PACKAGE_DEP_PLM" ] && {
        step "install needed perl modules via cpan"

        for item in $PACKAGE_DEP_PLM
        do
            if perl -M"$item" -le 'print "installed"' > /dev/null 2>&1 ; then
                note "perl module $item has been already installed."
            else
                case $item in
                    XML::Parser)
                        # https://metacpan.org/release/TODDR/XML-Parser-2.46/source/Makefile.PL#L8-9
                        export EXPATLIBPATH="$expat_LIBRARY_DIR"
                        export EXPATINCPATH="$expat_INCLUDE_DIR"

                        printf '%s\n' EXPATLIBPATH=$EXPATLIBPATH
                        printf '%s\n' EXPATINCPATH=$EXPATINCPATH
                        ;;
                esac

                # Would you like to configure as much as possible automatically? [yes]
                run "printf '%s\n' 'yes' | cpan $item"
            fi
        done

        if [ -d "$HOME/perl5/bin" ] ; then
            # cpan install to default local location
            bppend_to_PATH "$HOME/perl5/bin"
        fi
    }

    #########################################################################################

    [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] && {
        command -v rustup > /dev/null || {
            # https://www.rust-lang.org/tools/install
            note "${COLOR_GREEN}rustup cargo rustc${COLOR_OFF} ${COLOR_YELLOW}commands are required, but it was not found, let's install it.${COLOR_OFF}"

            if [ -f    "$XCPKG_HOME/tmp.d/rustup-init.sh" ] ; then
                run rm "$XCPKG_HOME/tmp.d/rustup-init.sh"
            fi

            wfetch 'https://sh.rustup.rs' --output-path="$XCPKG_HOME/tmp.d/rustup-init.sh"

            run bash "$XCPKG_HOME/tmp.d/rustup-init.sh" -y

            export CARGO_HOME="$HOME/.cargo"
            export PATH="$CARGO_HOME/bin:$PATH"
        }
    }

    #########################################################################################

    step "locate needed tools"

    unset AUTORECONF
    unset AUTOCONF
    unset AUTOMAKE
    unset ACLOCAL
    unset M4

    unset MESON
    unset CMAKE
    unset XMAKE
    unset GMAKE
    unset NINJA

    unset BEAR
    unset CCACHE
    unset PKG_CONFIG

    [ -n "$PACKAGE_DEP_UPP" ] && {
        for item in $PACKAGE_DEP_UPP
        do
            case $item in
                curl)   run curl --version ;;
                git)    run git  --version ;;
                gtar)   run tar  --version ;;
                gzip)   run gzip --version ;;
                xz)     run xz   --version ;;
                patch)  run patch --version ;;
                perl)   run perl --version ;;
                python3)run python3 --version ;;
            esac
        done
    }

    {
        [ "$PACKAGE_BUILD_SYSTEM_AUTOGENSH" = yes ] ||
        [ "$PACKAGE_BUILD_SYSTEM_AUTOTOOLS" = yes ]
    } && {
        AUTORECONF=$(command -v autoreconf) || abort 1 "command not found: autoreconf"
        AUTOCONF=$(command -v autoconf)     || abort 1 "command not found: autoconf"
        AUTOMAKE=$(command -v automake)     || abort 1 "command not found: automake"
        ACLOCAL=$(command -v aclocal)       || abort 1 "command not found: aclocal"
        M4=$(command -v m4)                 || abort 1 "command not found: m4"

        run "$AUTORECONF" --version
        printf '\n'
        run "$AUTOCONF"   --version
        printf '\n'
        run "$AUTOMAKE"   --version
        printf '\n'
        run "$ACLOCAL"    --version
        printf '\n'
        run "$M4"         --version
        printf '\n'
    }

    [ "$PACKAGE_BUILD_SYSTEM_MESON" = yes ] && {
        MESON=$(command -v meson) || abort 1 "command not found: meson"
        run "$MESON"      --version
        printf '\n'
    }

    [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] && {
        CMAKE=$(command -v cmake) || abort 1 "command not found: cmake"
        run "$CMAKE"      --version
        printf '\n'
    }

    [ "$PACKAGE_BUILD_SYSTEM_XMAKE" = yes ] && {
        XMAKE=$(command -v xmake) || abort 1 "command not found: xmake"
        run "$XMAKE"      --version
        printf '\n'
    }

    [ "$PACKAGE_BUILD_SYSTEM_GMAKE" = yes ] && {
        GMAKE=$(command -v gmake || command -v make) || abort 1 "command not found: gmake and make"
        run "$GMAKE"      --version
        printf '\n'
    }

    [ "$PACKAGE_BUILD_SYSTEM_NINJA" = yes ] && {
        NINJA=$(command -v ninja) || abort 1 "command not found: ninja"
        run "$NINJA"      --version
        printf '\n'
    }

    [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] && {
        RUSTUP=$(command -v rustup) || abort 1 "command not found: rustup"
        CARGO=$(command -v cargo)   || abort 1 "command not found: cargo"
        run "$RUSTUP"     --version
        printf '\n'
        run "$CARGO"      --version
        printf '\n'
    }

    [ "$PACKAGE_BUILD_SYSTEM_GO" = yes ] && {
        GO=$(command -v go) || abort 1 "command not found: go"
        run "$GO"      version
        printf '\n'
    }

    [ "$CCACHE_ENABLED" = yes ] && {
        CCACHE=$(command -v ccache) || abort 1 "command not found: ccache"
        run "$CCACHE"    --version
        printf '\n'
    }

    PKG_CONFIG=$(command -v pkg-config || command -v pkgconf) || abort 1 "command not found: pkg-config"

    run "$PKG_CONFIG"    --version
    printf '\n'

    unset  M4
    export M4="$(command -v m4 || true)"

    #########################################################################################

    step "fetch source/patches/resources from server"
    __fetch_sources_of_the_given_package "$1"
    __fetch_patches_of_the_given_package "$1"

    #########################################################################################

    case $PACKAGE_SRC_FILETYPE in
        .dir)
            if [ "$PACKAGE_SRC_FILEPATH" = '/dev/null' ] ; then
                :
            elif [ -d "$PACKAGE_SRC_FILEPATH" ] ; then
                if [ -d "$PACKAGE_SRC_FILEPATH/.git" ] && command -v git > /dev/null ; then
                    PACKAGE_GIT_SHA=$(git -C "$PACKAGE_SRC_FILEPATH" rev-parse HEAD || true)
                fi
                step "copy source files to the installing src directory"
                run cp -r "$PACKAGE_SRC_FILEPATH/." "$PACKAGE_INSTALLING_SRC_DIR"
            else
                abort 1 "src-url point to dir does not exist."
            fi
            ;;
        .git)
            if [ -z "$PACKAGE_GIT_SHA" ] ; then
                PACKAGE_GIT_SHA=$(git -C "$PACKAGE_SRC_FILEPATH" rev-parse HEAD || true)
            fi
            step "copy source files to the installing src directory"
            run cp -r "$PACKAGE_SRC_FILEPATH/." "$PACKAGE_INSTALLING_SRC_DIR"
            ;;
        .zip)
            step "uncompressed source file to the installing src directory"
            run unzip  "$PACKAGE_SRC_FILEPATH" -d "$PACKAGE_INSTALLING_SRC_DIR"
            ;;
        .txz|.tgz|.tlz|.tbz2)
            step "uncompressed source file to the installing src directory"
            run tar xf "$PACKAGE_SRC_FILEPATH" -C "$PACKAGE_INSTALLING_SRC_DIR" --strip-components 1 --no-same-owner
            ;;
        *)  step "copy source files to the installing src directory"
            run cp     "$PACKAGE_SRC_FILEPATH"    "$PACKAGE_INSTALLING_SRC_DIR"
    esac

    if [ -n "$PACKAGE_FIX_FILETYPE" ] ; then
        case $PACKAGE_FIX_FILETYPE in
            .zip)
                step "uncompressed patch file to the installing fix directory"
                run unzip  "$PACKAGE_FIX_FILEPATH" -d "$PACKAGE_INSTALLING_FIX_DIR"
                ;;
            .txz|.tgz|.tlz|.tbz2)
                step "uncompressed patch file to the installing fix directory"
                run tar xf "$PACKAGE_FIX_FILEPATH" -C "$PACKAGE_INSTALLING_FIX_DIR" --strip-components 1 --no-same-owner
                ;;
            *)  step "copy patch file to the installing fix directory"
                run cp     "$PACKAGE_FIX_FILEPATH"    "$PACKAGE_INSTALLING_FIX_DIR"
        esac
    fi

    if [ -n "$PACKAGE_RES_FILETYPE" ] ; then
        case $PACKAGE_RES_FILETYPE in
            .zip)
                step "uncompressed res file to the installing res directory"
                run unzip "$PACKAGE_RES_FILEPATH" -d "$PACKAGE_INSTALLING_RES_DIR"
                ;;
            .txz|.tgz|.tlz|.tbz2)
                step "uncompressed res file to the installing res directory"
                run tar xf "$PACKAGE_RES_FILEPATH" -C "$PACKAGE_INSTALLING_RES_DIR" --strip-components 1 --no-same-owner
                ;;
            *)  step "copy res file to the installing res directory"
                run cp    "$PACKAGE_RES_FILEPATH"   "$PACKAGE_INSTALLING_RES_DIR"
        esac
    fi

    #########################################################################################

    PACKAGE_BSCRIPT_DIR="$PACKAGE_INSTALLING_SRC_DIR/$PACKAGE_BSCRIPT"
    PACKAGE_BSCRIPT_DIR="${PACKAGE_BSCRIPT_DIR%/}"

    step "tree files of the installing top directory"
    run tree --dirsfirst -L 2 "$PACKAGE_WORKING_DIR"

    step "list files of the installing src directory"
    run ls -l "$PACKAGE_INSTALLING_SRC_DIR"

    if [ -n "$PACKAGE_BSCRIPT" ] ; then
        step "list files of the installing build script directory"
        run ls -l "$PACKAGE_BSCRIPT_DIR"
    fi

    #########################################################################################

    [ "$DRYRUN" = yes ] && {
        [ -z "$SHELL" ] || SHELL=$(command -v zsh || command -v bash || command -v sh) || abort 1 "none of zsh|bash|sh shell found in your system."
        exec "$SHELL"
    }

    #########################################################################################

    # https://www.gnu.org/software/gettext/manual/html_node/config_002eguess.html
    # https://git.savannah.gnu.org/cgit/config.git/tree/

    step "replace config.sub and config.guess with the lastest version"

    {
        [ "$PACKAGE_BUILD_SYSTEM_AUTOGENSH" = yes ] ||
        [ "$PACKAGE_BUILD_SYSTEM_AUTOTOOLS" = yes ] ||
        [ "$PACKAGE_BUILD_SYSTEM_CONFIGURE" = yes ]
    } && {
        for FILENAME in config.sub config.guess
        do
            FILEPATH="$PACKAGE_WORKING_DIR/$FILENAME"

            wfetch "http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=$FILENAME;hb=HEAD" --output-path="$FILEPATH"

            run chmod a+x "$FILEPATH"

            if [ "$FILENAME" = 'config.sub' ] ; then
                sed_in_place 's/arm64-*/arm64-*|arm64e-*/g' "$FILEPATH"
            fi

            find "$PACKAGE_BSCRIPT_DIR" -name "$FILENAME" -exec cp -vf "$FILEPATH" {} \;
        done
    }

    #########################################################################################

    step "build for native"

    if [ "$CROSS_COMPILING" = no ] ; then
        note "not cross compiling, skipped."
    elif [ -z "$PACKAGE_BUILD0_ACTIONS" ] ; then
        note "build0 mapping was not found in formula, skipped."
    else
        NATIVE_BCACHED_DIR="$PACKAGE_WORKING_DIR/src/-"
        NATIVE_INSTALL_DIR="$XCPKG_HOME/native/$PACKAGE_NAME"

        cat <<EOF
NATIVE_BCACHED_DIR = $NATIVE_BCACHED_DIR
NATIVE_INSTALL_DIR = $NATIVE_INSTALL_DIR
EOF

        eval "
build0() {
$PACKAGE_BUILD0_ACTIONS
}"

        if [ -f "$NATIVE_INSTALL_DIR/version.txt" ] ; then
            if [ "$(cat "$NATIVE_INSTALL_DIR/version.txt")" != "$PACKAGE_VERSION" ] ; then
                note "build for native already have been done, but not same version. I will remove it then rebuild it."
                run rm -rf "$NATIVE_INSTALL_DIR"
            fi
        fi

        if [ -f "$NATIVE_INSTALL_DIR/version.txt" ] ; then
            note "build for native already have been done, skipped."
        else
            run install -d "$NATIVE_BCACHED_DIR"

            if [ "$PACKAGE_BUILD_IN_BSCRIPT_DIR" = yes ] ; then
                if [ "$PWD" != "$PACKAGE_BSCRIPT_DIR" ] ; then
                    run cd "$PACKAGE_BSCRIPT_DIR"
                fi
            else
                    run cd "$NATIVE_BCACHED_DIR"
            fi

            run build0

            [ -d "$NATIVE_INSTALL_DIR" ] && {
                printf '%s\n' "$PACKAGE_VERSION" > "$NATIVE_INSTALL_DIR/version.txt"

                if [ -d  "$NATIVE_INSTALL_DIR/bin" ] ; then
                    PATH="$NATIVE_INSTALL_DIR/bin:$PATH"
                fi

                if [ -d  "$NATIVE_INSTALL_DIR/sbin" ] ; then
                    PATH="$NATIVE_INSTALL_DIR/sbin:$PATH"
                fi

                if [ -d          "$NATIVE_INSTALL_DIR/share/aclocal" ] ; then
                    ACLOCAL_PATH="$NATIVE_INSTALL_DIR/share/aclocal:$ACLOCAL_PATH"
                fi
            }
        fi
    fi

    #########################################################################################

    step "locate C/C++ toolchain for target build"

    unset      CC
    unset    OBJC
    unset     CXX
    unset     CPP
    unset      AS
    unset      AR
    unset  RANLIB
    unset      LD
    unset      NM
    unset    SIZE
    unset   STRIP
    unset STRINGS
    unset OBJDUMP
    unset SYSROOT

         CC="$(xcrun --sdk "$TARGET_PLATFORM_NAME_LOWER_CASE" --find clang)"
       OBJC="$(xcrun --sdk "$TARGET_PLATFORM_NAME_LOWER_CASE" --find clang)"
        CXX="$(xcrun --sdk "$TARGET_PLATFORM_NAME_LOWER_CASE" --find clang++)"
         AS="$(xcrun --sdk "$TARGET_PLATFORM_NAME_LOWER_CASE" --find as)"
         AR="$(xcrun --sdk "$TARGET_PLATFORM_NAME_LOWER_CASE" --find ar)"
     RANLIB="$(xcrun --sdk "$TARGET_PLATFORM_NAME_LOWER_CASE" --find ranlib)"
         LD="$(xcrun --sdk "$TARGET_PLATFORM_NAME_LOWER_CASE" --find ld)"
         NM="$(xcrun --sdk "$TARGET_PLATFORM_NAME_LOWER_CASE" --find nm)"
       SIZE="$(xcrun --sdk "$TARGET_PLATFORM_NAME_LOWER_CASE" --find size)"
      STRIP="$(xcrun --sdk "$TARGET_PLATFORM_NAME_LOWER_CASE" --find strip)"
    STRINGS="$(xcrun --sdk "$TARGET_PLATFORM_NAME_LOWER_CASE" --find strings)"
    OBJDUMP="$(xcrun --sdk "$TARGET_PLATFORM_NAME_LOWER_CASE" --find objdump)"
    SYSROOT="$(xcrun --sdk "$TARGET_PLATFORM_NAME_LOWER_CASE" --show-sdk-path)"

    for TOOL in CC OBJC CXX AS AR RANLIB LD NM STRIP SIZE STRINGS OBJDUMP SYSROOT
    do
        export "$TOOL"
        printf "%7s = %s\n" "${TOOL}" "$(eval echo \$"${TOOL}")"
    done

    ##################################################################################

    step "create proxy for C/C++ compiler for target build"

    cat > proxy-cc.c <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char * argv[]) {
    char * PROXIED_PROGRAM = NULL;

    if (argv[0][strlen(argv[0]) - 1] == '+') {
        PROXIED_PROGRAM = getenv("PROXIED_CXX");

        if (PROXIED_PROGRAM == NULL) {
            fprintf(stderr, "PROXIED_CXX environment variable is not set.\n");
            return 2;
        }
    } else {
        PROXIED_PROGRAM = getenv("PROXIED_CC");

        if (PROXIED_PROGRAM == NULL) {
            fprintf(stderr, "PROXIED_CC environment variable is not set.\n");
            return 2;
        }
    }

    char * SYSROOT = getenv("SYSROOT");

    if (SYSROOT == NULL) {
        fprintf(stderr, "SYSROOT environment variable is not set.\n");
        return 2;
    }

    size_t sysrootLength = strlen(SYSROOT) + 11;
    char   sysroot[sysrootLength];
    snprintf(sysroot, sysrootLength, "--sysroot=%s", SYSROOT);

    char * argv2[argc + 2];

    argv2[0] = PROXIED_PROGRAM;
    argv2[1] = sysroot;

    for (int i = 1; i < argc; i++) {
        argv2[i + 1] = argv[i];
    }

    argv2[argc + 1] = NULL;

    if (PROXIED_PROGRAM[0] == '/') {
        execv (PROXIED_PROGRAM, argv2);
        perror(PROXIED_PROGRAM);
        return -1;
    } else {
        execvp(PROXIED_PROGRAM, argv2);
        perror(PROXIED_PROGRAM);
        return -1;
    }

    return 0;
}
EOF

    PROXY_CC="$XCPKG_CORE_BIN_DIR/proxy-cc"
    PROXY_CXX="$XCPKG_CORE_BIN_DIR/proxy-c++"

    run "$CC_FOR_BUILD" -std=c99 -o "$PROXY_CC" proxy-cc.c

    run ln -sfr "$PROXY_CC" "$PROXY_CXX"

    export PROXIED_CC="$CC"
    export PROXIED_CXX="$CXX"

    export CC="$PROXY_CC"
    export CXX="$PROXY_CXX"
    export CPP="$CC -E"

cat <<EOF
PROXIED_CC  = $PROXIED_CC
PROXIED_CXX = $PROXIED_CXX

        CC  = $CC
        CPP = $CPP
        CXX = $CXX
EOF

    #########################################################################################

    step "config CFLAGS OBJCFLAGS CXXFLAGS CPPFLAGS LDFLAGS"

    CCFLAGS="$PACKAGE_CCFLAGS -fPIC"
    OCFLAGS="$PACKAGE_OCFLAGS -fPIC"
    OXFLAGS="$PACKAGE_OXFLAGS -fPIC"
    XXFLAGS="$PACKAGE_XXFLAGS -fPIC"
    PPFLAGS="$PACKAGE_PPFLAGS"
    LDFLAGS="$PACKAGE_LDFLAGS"

    CCFLAGS="$(printf '%s\n' "$CCFLAGS" | sed -e 's|--static||g' -e 's|-static||g')"
    OCFLAGS="$(printf '%s\n' "$OCFLAGS" | sed -e 's|--static||g' -e 's|-static||g')"
    OXFLAGS="$(printf '%s\n' "$OXFLAGS" | sed -e 's|--static||g' -e 's|-static||g')"
    XXFLAGS="$(printf '%s\n' "$XXFLAGS" | sed -e 's|--static||g' -e 's|-static||g')"
    LDFLAGS="$(printf '%s\n' "$LDFLAGS" | sed -e 's|--static||g' -e 's|-static||g')"

    ##############################################

    _F_COMMON_OPT_IS_SET=no

    for item in $CCFLAGS
    do
        [ "$item" = '-fcommon' ] && {
            _F_COMMON_OPT_IS_SET=yes
            break
        }
    done

    if [ "$_F_COMMON_OPT_IS_SET" = no ] ; then
        CCFLAGS="$CCFLAGS -fno-common"
    fi

    ##############################################

    _F_COMMON_OPT_IS_SET=no

    for item in $OCFLAGS
    do
        [ "$item" = '-fcommon' ] && {
            _F_COMMON_OPT_IS_SET=yes
            break
        }
    done

    if [ "$_F_COMMON_OPT_IS_SET" = no ] ; then
        OCFLAGS="$OCFLAGS -fno-common"
    fi

    ##############################################

    _F_COMMON_OPT_IS_SET=no

    for item in $OXFLAGS
    do
        [ "$item" = '-fcommon' ] && {
            _F_COMMON_OPT_IS_SET=yes
            break
        }
    done

    if [ "$_F_COMMON_OPT_IS_SET" = no ] ; then
        OXFLAGS="$OXFLAGS -fno-common"
    fi

    ##############################################

    _F_COMMON_OPT_IS_SET=no

    for item in $XXFLAGS
    do
        [ "$item" = '-fcommon' ] && {
            _F_COMMON_OPT_IS_SET=yes
            break
        }
    done

    if [ "$_F_COMMON_OPT_IS_SET" = no ] ; then
        XXFLAGS="$XXFLAGS -fno-common"
    fi

    ##############################################

    PPFLAGS="-isysroot $SYSROOT -Qunused-arguments $PPFLAGS"
    CCFLAGS="-isysroot $SYSROOT -arch $TARGET_PLATFORM_ARCH -m${TARGET_PLATFORM_NAME_LOWER_CASE}-version-min=$TARGET_PLATFORM_VERS -Qunused-arguments $CCFLAGS"
    OCFLAGS="-isysroot $SYSROOT -arch $TARGET_PLATFORM_ARCH -m${TARGET_PLATFORM_NAME_LOWER_CASE}-version-min=$TARGET_PLATFORM_VERS -Qunused-arguments $OCFLAGS"
    OXFLAGS="-isysroot $SYSROOT -arch $TARGET_PLATFORM_ARCH -m${TARGET_PLATFORM_NAME_LOWER_CASE}-version-min=$TARGET_PLATFORM_VERS -Qunused-arguments $OXFLAGS"
    XXFLAGS="-isysroot $SYSROOT -arch $TARGET_PLATFORM_ARCH -m${TARGET_PLATFORM_NAME_LOWER_CASE}-version-min=$TARGET_PLATFORM_VERS -Qunused-arguments $XXFLAGS"
    LDFLAGS="-isysroot $SYSROOT -arch $TARGET_PLATFORM_ARCH -m${TARGET_PLATFORM_NAME_LOWER_CASE}-version-min=$TARGET_PLATFORM_VERS -Wl,-search_paths_first $LDFLAGS"

    ##############################################

    if [ "$LOG_LEVEL" -ge 3 ] ; then
        CCFLAGS="$CCFLAGS -v"
        XXFLAGS="$XXFLAGS -v"
        OCFLAGS="$OCFLAGS -v"
        OXFLAGS="$OXFLAGS -v"
        LDFLAGS="$LDFLAGS -Wl,-v"
    fi

    if [ "$BUILD_TYPE" = release ] ; then
        PPFLAGS="$PPFLAGS -DNDEBUG"
        CCFLAGS="$CCFLAGS -Os"
        XXFLAGS="$XXFLAGS -Os"
        OCFLAGS="$OCFLAGS -Os"
        OXFLAGS="$OXFLAGS -Os"
        LDFLAGS="$LDFLAGS -Wl,-S"
    fi

    ##############################################

    for DEPENDENT_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
    do
        DEPENDENT_PACKAGE_NAME_UNDERSCORE="$(printf '%s\n' "$DEPENDENT_PACKAGE_NAME" | tr '@+-.' '_')"

        DEPENDENT_PACKAGE_INSTALL_DIR="$XCPKG_PACKAGE_INSTALLED_ROOT/$TARGET_PLATFORM_SPEC/$DEPENDENT_PACKAGE_NAME"
        DEPENDENT_PACKAGE_BINARY__DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/bin"
        DEPENDENT_PACKAGE_INCLUDE_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/include"
        DEPENDENT_PACKAGE_LIBRARY_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/lib"
        DEPENDENT_PACKAGE_PKGCONF_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/lib/pkgconfig"

        eval "${DEPENDENT_PACKAGE_NAME_UNDERSCORE}_INSTALL_DIR='$DEPENDENT_PACKAGE_INSTALL_DIR'"
        eval "${DEPENDENT_PACKAGE_NAME_UNDERSCORE}_BINARY__DIR='$DEPENDENT_PACKAGE_BINARY__DIR'"
        eval "${DEPENDENT_PACKAGE_NAME_UNDERSCORE}_INCLUDE_DIR='$DEPENDENT_PACKAGE_INCLUDE_DIR'"
        eval "${DEPENDENT_PACKAGE_NAME_UNDERSCORE}_LIBRARY_DIR='$DEPENDENT_PACKAGE_LIBRARY_DIR'"

        if [ -d "$DEPENDENT_PACKAGE_INCLUDE_DIR" ] ; then
            PPFLAGS="-I$DEPENDENT_PACKAGE_INCLUDE_DIR $PPFLAGS"
        fi

        if [ -d "$DEPENDENT_PACKAGE_LIBRARY_DIR" ] ; then
            LDFLAGS="-L$DEPENDENT_PACKAGE_LIBRARY_DIR -Wl,-rpath,$DEPENDENT_PACKAGE_LIBRARY_DIR $LDFLAGS"
        fi
    done

    PPFLAGS="-I$PACKAGE_INSTALLING_INC_DIR $PPFLAGS"
    LDFLAGS="-L$PACKAGE_INSTALLING_LIB_DIR $LDFLAGS"
    LDFLAGS="-Wl,-rpath,$PACKAGE_INSTALL_DIR/lib $LDFLAGS"

    export    CFLAGS="$CCFLAGS"
    export OBJCFLAGS="$OCFLAGS"
    export  CXXFLAGS="$XXFLAGS"
    export  CPPFLAGS="$PPFLAGS"
    export   LDFLAGS="$LDFLAGS"

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CFLAGS"
    printf '%s\n' "$CFLAGS" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} OBJCFLAGS"
    printf '%s\n' "$OBJCFLAGS" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CXXFLAGS"
    printf '%s\n' "$CXXFLAGS" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CPPFLAGS"
    printf '%s\n' "$CPPFLAGS" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} LDFLAGS"
    printf '%s\n' "$LDFLAGS" | xargs printf '        %s\n'

    #########################################################################################

    step "list XDG_DATA_DIRS"

    # https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
    export XDG_DATA_DIRS

    for DEPENDENT_PACKAGE_INSTALL_DIR in $RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS
    do
        # https://gi.readthedocs.io/en/latest/tools/g-ir-scanner.html#environment-variables
        if [ -d "$DEPENDENT_PACKAGE_INSTALL_DIR/share/gir-1.0" ] ; then
            if [ -z "$XDG_DATA_DIRS" ] ; then
                XDG_DATA_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR/share"
            else
                XDG_DATA_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR/share:$XDG_DATA_DIRS"
            fi
        fi

        # https://help.gnome.org/admin//system-admin-guide/2.32/mimetypes-database.html.en
        if [ -d "$DEPENDENT_PACKAGE_INSTALL_DIR/share/mime" ] ; then
            if [ -z "$XDG_DATA_DIRS" ] ; then
                XDG_DATA_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR/share"
            else
                XDG_DATA_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR/share:$XDG_DATA_DIRS"
            fi
        fi
    done

    printf '%s\n' "$XDG_DATA_DIRS" | tr : '\n'

    #########################################################################################

    step "list ACLOCAL_PATH"

    # https://www.gnu.org/software/automake/manual/html_node/Macro-Search-Path.html
    export ACLOCAL_PATH

    for DEPENDENT_PACKAGE_INSTALL_DIR in $RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS
    do
        DEPENDENT_PACKAGE_ACLOCAL_PATH="$DEPENDENT_PACKAGE_INSTALL_DIR/share/aclocal"

        if [ -d "$DEPENDENT_PACKAGE_ACLOCAL_PATH" ] ; then
            if [ -z "$ACLOCAL_PATH" ] ; then
                ACLOCAL_PATH="$DEPENDENT_PACKAGE_ACLOCAL_PATH"
            else
                ACLOCAL_PATH="$DEPENDENT_PACKAGE_ACLOCAL_PATH:$ACLOCAL_PATH"
            fi
        fi
    done

    printf '%s\n' "$ACLOCAL_PATH" | tr : '\n'

    #########################################################################################

    step "list PATH"

    PATH="$PACKAGE_INSTALLING_BIN_DIR:$PATH"

    printf '%s\n' "$PATH" | tr : '\n'

    #########################################################################################

    step "config environment variables for pkg-config"

    # https://www.freedesktop.org/wiki/Software/pkg-config/CrossCompileProposal
    unset PKG_CONFIG_SYSROOT_DIR

    if [ "$LOG_LEVEL" -ge 3 ] ; then
        export PKG_CONFIG_DEBUG_SPEW='set'
    fi

    # override the default search directory (usually /usr/lib/pkgconfig:/usr/share/pkgconfig)
    # because we only want to use our own
    export PKG_CONFIG_LIBDIR="$PACKAGE_WORKING_DIR/lib/pkgconfig"

    if [ -z "$PKG_CONFIG_PATH" ] ; then
        export PKG_CONFIG_PATH="$PACKAGE_WORKING_DIR/lib/pkgconfig"
    else
        export PKG_CONFIG_PATH="$PACKAGE_WORKING_DIR/lib/pkgconfig:$PKG_CONFIG_PATH"
    fi

    for DEPENDENT_PACKAGE_INSTALL_DIR in $RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS
    do
        DEPENDENT_PACKAGE_PKGCONF_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/lib/pkgconfig"

        if [ -d "$DEPENDENT_PACKAGE_PKGCONF_DIR" ] ; then
            PKG_CONFIG_PATH="$DEPENDENT_PACKAGE_PKGCONF_DIR:$PKG_CONFIG_PATH"
        else
            DEPENDENT_PACKAGE_PKGCONF_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/share/pkgconfig"

            if [ -d "$DEPENDENT_PACKAGE_PKGCONF_DIR" ] ; then
                PKG_CONFIG_PATH="$DEPENDENT_PACKAGE_PKGCONF_DIR:$PKG_CONFIG_PATH"
            fi
        fi
    done

    printf 'PKG_CONFIG_DEBUG_SPEW = %s\n' "$PKG_CONFIG_DEBUG_SPEW"

    printf 'PKG_CONFIG          = %s\n' "$PKG_CONFIG"

    printf 'PKG_CONFIG_LIBDIR   = %s\n' "$PKG_CONFIG_LIBDIR"

    export IFS=':'

    FIRST=yes

    for item in $(printf '%s\n' "$PKG_CONFIG_PATH")
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
            printf 'PKG_CONFIG_PATH     = %s\n' "$item"
        else
            printf '%s\n' "                      $item"
        fi
    done

    unset IFS

    #########################################################################################

    if [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] ; then
        step "config environment variables for cmake"

        # https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html#manual:cmake-env-variables(7)

        unset CMAKE_PREFIX_PATH
        unset CMAKE_APPLE_SILICON_PROCESSOR
        unset CMAKE_BUILD_PARALLEL_LEVEL
        unset CMAKE_BUILD_TYPE
        unset CMAKE_CONFIGURATION_TYPES
        unset CMAKE_CONFIG_TYPE
        unset CMAKE_EXPORT_COMPILE_COMMANDS
        unset CMAKE_GENERATOR
        unset CMAKE_GENERATOR_INSTANCE
        unset CMAKE_GENERATOR_PLATFORM
        unset CMAKE_GENERATOR_TOOLSET
        unset CMAKE_INSTALL_MODE
        unset CMAKE_C_COMPILER_LAUNCHER
        unset CMAKE_C_LINKER_LAUNCHER
        unset CMAKE_CXX_COMPILER_LAUNCHER
        unset CMAKE_CXX_LINKER_LAUNCHER
        unset CMAKE_MSVCIDE_RUN_PATH
        unset CMAKE_NO_VERBOSE
        unset CMAKE_OSX_ARCHITECTURES
        unset CMAKE_TOOLCHAIN_FILE
        unset DESTDIR
        unset CTEST_INTERACTIVE_DEBUG_MODE
        unset CTEST_OUTPUT_ON_FAILURE
        unset CTEST_PARALLEL_LEVEL
        unset CTEST_PROGRESS_OUTPUT
        unset CTEST_USE_LAUNCHERS_DEFAULT
        unset DASHBOARD_TEST_FROM_CTEST

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_BUILD_PARALLEL_LEVEL.html
        export CMAKE_BUILD_PARALLEL_LEVEL="$BUILD_NJOBS"

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_GENERATOR.html
        if [ "$PACKAGE_BUILD_SYSTEM_NINJA" = yes ] ; then
            export CMAKE_GENERATOR='Ninja'
        else
            export CMAKE_GENERATOR='Unix Makefiles'
        fi

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_EXPORT_COMPILE_COMMANDS.html
        if [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] ; then
            export CMAKE_EXPORT_COMPILE_COMMANDS=ON
        else
            export CMAKE_EXPORT_COMPILE_COMMANDS=OFF
        fi

        case $BUILD_TYPE in
            debug)   CMAKE_BUILD_TYPE=Debug   ;;
            release) CMAKE_BUILD_TYPE=Release ;;
        esac

        if [ "$LOG_LEVEL" -eq 0 ] ; then
            CMAKE_VERBOSE_MAKEFILE=OFF
            CMAKE_COLOR_MAKEFILE=OFF
        else
            CMAKE_VERBOSE_MAKEFILE=ON
            CMAKE_COLOR_MAKEFILE=ON
        fi

        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_DEBUG_MODE.html
        if [ "$LOG_LEVEL" -ge 3 ] ; then
            CMAKE_FIND_DEBUG_MODE=ON
        else
            CMAKE_FIND_DEBUG_MODE=OFF
        fi

        # https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
        # https://cmake.org/cmake/help/latest/variable/CMAKE_IGNORE_PATH.html
        #
        # https://cmake.org/cmake/help/latest/variable/CMAKE_MODULE_PATH.html
        # https://cmake.org/cmake/help/latest/variable/CMAKE_INCLUDE_PATH.html
        # https://cmake.org/cmake/help/latest/variable/CMAKE_LIBRARY_PATH.html
        # https://cmake.org/cmake/help/latest/variable/CMAKE_PROGRAM_PATH.html
        #
        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
        #
        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH_MODE_PACKAGE.html
        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH_MODE_INCLUDE.html
        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH_MODE_LIBRARY.html
        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH_MODE_PROGRAM.html

        CMAKE_FIND_ROOT_PATH="$PACKAGE_WORKING_DIR"

        for DEPENDENT_PACKAGE_INSTALL_DIR in $RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS
        do
            if [ -z "$CMAKE_FIND_ROOT_PATH" ] ; then
                CMAKE_FIND_ROOT_PATH="$DEPENDENT_PACKAGE_INSTALL_DIR"
            else
                CMAKE_FIND_ROOT_PATH="$CMAKE_FIND_ROOT_PATH;$DEPENDENT_PACKAGE_INSTALL_DIR"
            fi
        done

        env | sed -n '/^CMAKE_/p'

        # https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling-for-ios-tvos-or-watchos
        case $TARGET_PLATFORM_NAME in
            iPhoneOS|iPhoneSimulator)
                CMAKE_SYSTEM_NAME=iOS
                ;;
            WatchOS|WatchSimulator)
                CMAKE_SYSTEM_NAME=watchOS
                ;;
            AppleTVOS|AppleTVSimulator)
                CMAKE_SYSTEM_NAME=tvOS
                ;;
            *)  CMAKE_SYSTEM_NAME=Darwin
        esac

        CMAKE_TOOLCHAIN_FILE="$PACKAGE_WORKING_DIR/toolchain.cmake"

        cat > "$CMAKE_TOOLCHAIN_FILE" <<EOF
message(STATUS "CMake command: \${CMAKE_COMMAND}")
message(STATUS "CMake version: \${CMAKE_VERSION}")

message(STATUS "CMAKE_HOST_SYSTEM_NAME: \${CMAKE_HOST_SYSTEM_NAME}")
message(STATUS "     CMAKE_SYSTEM_NAME: \${CMAKE_SYSTEM_NAME}")

set(CMAKE_BUILD_TYPE  $CMAKE_BUILD_TYPE)

EOF

        if [ "$CROSS_COMPILING" = yes ] ; then
            printf '%s\n' "set(CMAKE_SYSTEM_NAME      $CMAKE_SYSTEM_NAME)" >> "$CMAKE_TOOLCHAIN_FILE"
        fi

        cat >> "$CMAKE_TOOLCHAIN_FILE" <<EOF
set(CMAKE_SYSTEM_VERSION   $TARGET_PLATFORM_VERS)
set(CMAKE_SYSTEM_PROCESSOR $TARGET_PLATFORM_ARCH)

set(CMAKE_ASM_COMPILER "$CC")
set(CMAKE_ASM_FLAGS "-arch $TARGET_PLATFORM_ARCH")

set(CMAKE_C_COMPILER "$CC")
set(CMAKE_C_FLAGS "$CFLAGS $CPPFLAGS")

set(CMAKE_CXX_COMPILER "$CXX")
set(CMAKE_CXX_FLAGS "$CXXFLAGS $CPPFLAGS")

set(CMAKE_SHARED_LINKER_FLAGS "$LDFLAGS")
set(CMAKE_EXE_LINKER_FLAGS    "$LDFLAGS")

set(CMAKE_AR     "$AR")
set(CMAKE_RANLIB "$RANLIB")

set(CMAKE_LINKER "$LD")

set(CMAKE_NM     "$NM")

set(CMAKE_STRIP  "$STRIP")

set(CMAKE_OSX_SYSROOT "$SYSROOT")

# https://cmake.org/cmake/help/latest/variable/CMAKE_OSX_ARCHITECTURES.html
set(CMAKE_OSX_ARCHITECTURES "$TARGET_PLATFORM_ARCH" CACHE STRING "")

set(CMAKE_FIND_DEBUG_MODE $CMAKE_FIND_DEBUG_MODE)

set(CMAKE_FIND_ROOT_PATH "$CMAKE_FIND_ROOT_PATH")

set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
EOF
        [ "$LOG_LEVEL" -gt "$LOG_LEVEL_QUIET" ] && {
            if command -v bat > /dev/null ; then
                run bat --language=cmake --paging=never "$CMAKE_TOOLCHAIN_FILE"
            else
                run cat "$CMAKE_TOOLCHAIN_FILE"
            fi
        }

        # https://cmake.org/cmake/help/latest/variable/CMAKE_PROJECT_INCLUDE.html
        CMAKE_PROJECT_INCLUDE="$PACKAGE_WORKING_DIR/project-after.cmake"

        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_LIBRARY_SUFFIXES.html

        case $LINK_TYPE in
            static-only)     printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".a")\n'          > "$CMAKE_PROJECT_INCLUDE" ;;
            static-prefered) printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".a" ".dylib")\n' > "$CMAKE_PROJECT_INCLUDE" ;;
            shared-only)     printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".dylib")\n'      > "$CMAKE_PROJECT_INCLUDE" ;;
            shared-prefered) printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".dylib" ".a")\n' > "$CMAKE_PROJECT_INCLUDE" ;;
        esac

        if [ "$LOG_LEVEL" -gt 0 ] ; then
            run cat "$CMAKE_PROJECT_INCLUDE"
        fi
    fi

    #########################################################################################

    if [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] ; then
        step "config environment variables for rustc and cargo"

        # this environment variable is not defined by Rust, but it is widely used by third-party project.
        export RUST_TARGET=''

        case $TARGET_PLATFORM_NAME/$TARGET_PLATFORM_ARCH in
            MacOSX/x86_64)
                RUST_TARGET="x86_64-apple-darwin"
                ;;
            *Simulator/x86_64)
                RUST_TARGET="x86_64-apple-darwin"
                ;;
            MacOSX/arm64)
                RUST_TARGET="aarch64-apple-darwin"
                ;;
            *Simulator/arm64)
                RUST_TARGET="aarch64-apple-ios-sim"
                ;;
            */arm64*)
                RUST_TARGET="aarch64-apple-ios"
                ;;
            *)  RUST_TARGET="$TARGET_PLATFORM_ARCH-apple-ios"
        esac

        export CARGO_BUILD_TARGET="$RUST_TARGET"

        export CARGO_BUILD_TARGET_DIR='target'

        export CARGO_BUILD_JOBS="$BUILD_NJOBS"

        #################################################################

        # https://doc.rust-lang.org/cargo/commands/cargo-rustc.html
        # https://doc.rust-lang.org/rustc/codegen-options/index.html#link-arg
        export RUSTFLAGS="-Clinker=$CC"

        for LINKER_FLAG in $LDFLAGS
        do
            RUSTFLAGS="$RUSTFLAGS -Clink-arg=$LINKER_FLAG"
        done

        #################################################################

        RUST_TARGET_UPPERCASE_UNDERSCORE="$(printf '%s\n' "$RUST_TARGET" | tr a-z A-Z | tr - _)"

        # https://doc.rust-lang.org/cargo/reference/config.html#environment-variables
        # https://doc.rust-lang.org/cargo/reference/environment-variables.html
        # export "CARGO_TARGET_${RUST_TARGET_UPPERCASE_UNDERSCORE}_AR"="$AR"
        # export "CARGO_TARGET_${RUST_TARGET_UPPERCASE_UNDERSCORE}_LINKER"="$CC"

        #################################################################

        # https://docs.rs/backtrace/latest/backtrace/
        export RUST_BACKTRACE=1

        #################################################################

        # https://libraries.io/cargo/cc
        # https://crates.io/crates/cc
        # https://docs.rs/cc/latest/cc/
        # https://github.com/alexcrichton/cc-rs
        export HOST_CC="$CC"
        export HOST_CFLAGS="$CFLAGS $CPPFLAGS"

        export HOST_CXX="$CXX"
        export HOST_CXXFLAGS="$CXXFLAGS $CPPFLAGS"

        export HOST_AR="$AR"

        export TARGET_CC="$CC"
        export TARGET_CFLAGS="$CFLAGS $CPPFLAGS"

        export TARGET_CXX="$CXX"
        export TARGET_CXXFLAGS="$CXXFLAGS $CPPFLAGS"

        export TARGET_AR="$AR"

        #################################################################

        # https://libraries.io/cargo/pkg-config
        # https://crates.io/crates/pkg-config
        # https://docs.rs/pkg-config/latest/pkg_config/
        # https://github.com/rust-lang/pkg-config-rs
        export TARGET_PKG_CONFIG_ALLOW_CROSS=1

        #################################################################

        # https://libraries.io/cargo/cmake
        # https://crates.io/crates/cmake
        # https://docs.rs/cmake/latest/cmake/
        # https://github.com/alexcrichton/cmake-rs
        # this variable is not motioned in their document. you must read the source code of cmake-rs crate.
        export TARGET_CMAKE_TOOLCHAIN_FILE="$PACKAGE_WORKING_DIR/toolchain.cmake"

        #################################################################

        for DEPENDENT_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
        do
            case $DEPENDENT_PACKAGE_NAME in
                openssl@1.1)
                    unset OPENSSL_DIR
                    # https://docs.rs/openssl/0.10.35/openssl/
                    export OPENSSL_DIR="$openssl_1_1_INSTALL_DIR"
                    ;;
                openssl)
                    unset OPENSSL_DIR
                    # https://docs.rs/openssl/0.10.35/openssl/
                    export OPENSSL_DIR="$openssl_INSTALL_DIR"
                    ;;
            esac
        done

        #################################################################

        env | grep CARGO_
        env | grep RUST_

        printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} RUSTFLAGS"
        printf '%s\n' "$RUSTFLAGS" | xargs printf '        %s\n'
    fi

    #########################################################################################

    if [ "$PACKAGE_BUILD_SYSTEM_GO" = yes ] ; then
        step "config environment variables for go"

        # https://golang.org/doc/install/source#environment

        export CGO_ENABLED=0
        export CGO_CFLAGS="$CFLAGS"
        export CGO_CXXFLAGS="$CXXFLAGS"
        export CGO_CPPFLAGS="$CPPFLAGS"
        export CGO_LDFLAGS="$LDFLAGS"

        export GO111MODULE='auto'

        if [ "$COUNTRY" = china ] ; then
            export GOPROXY='https://goproxy.cn'
        fi

        export GOOS="darwin"

        case $TARGET_PLATFORM_ARCH in
            armv7*)  export GOARCH=arm   ;;
            arm64*)  export GOARCH=arm64 ;;
            aarch64) export GOARCH=arm64 ;;
            i386)    export GOARCH=386   ;;
            i686)    export GOARCH=386   ;;
            x86_64)  export GOARCH=amd64 ;;
        esac
    fi

    #########################################################################################

    [ "$LOG_LEVEL" -ge 3 ] && {
        step "show export variables"
        run export -p
        printf '\n'
    }

    #########################################################################################

    step "create symbolic links named as the C/C++ compiler point to ccache"

    if [ "$CCACHE_ENABLED" = yes ] ; then
        run ln -sf "$CCACHE" "$PACKAGE_INSTALLING_BIN_DIR/$(basename "$CC")"
        run ln -sf "$CCACHE" "$PACKAGE_INSTALLING_BIN_DIR/$(basename "$CXX")"

        "$CCACHE" -s > "$PACKAGE_WORKING_DIR/ccache-s.txt"
    else
        note "ccache is disabled, skipped."
    fi

    #########################################################################################

    [ -n "$PACKAGE_DEP_PKG" ] && {
        step "create symbolic links for dependent libraries"

        unset libFileNameSuffix

        case $LINK_TYPE in
            static-only|static-prefered)
                libFileNameSuffix='.a'
                ;;
            shared-only|shared-prefered)
                libFileNameSuffix='.dylib'
                ;;
            *)  abort 1 "unrecognized link type: $LINK_TYPE"
        esac

        for DEPENDENT_PACKAGE_INSTALL_DIR in $RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS
        do
            DEPENDENT_PACKAGE_LIBRARY_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/lib"

            if [ -d "$DEPENDENT_PACKAGE_LIBRARY_DIR" ] ; then
                for libFileName in $(find "$DEPENDENT_PACKAGE_LIBRARY_DIR" -maxdepth 1 -mindepth 1 -name "lib*$libFileNameSuffix" -exec basename {} \;)
                do
                    if [ ! -e "$PACKAGE_INSTALLING_LIB_DIR/$libFileName" ] ; then
                        run ln -s "$DEPENDENT_PACKAGE_LIBRARY_DIR/$libFileName" "$PACKAGE_INSTALLING_LIB_DIR/$libFileName"
                    fi
                done
            fi
        done
    }

    #########################################################################################

    step "dopatch for target"

    if [ "$PWD" != "$PACKAGE_BSCRIPT_DIR" ] ; then
        run cd "$PACKAGE_BSCRIPT_DIR"
    fi

    if [ -n "$PACKAGE_DOPATCH_ACTIONS" ] ; then
        eval "
dopatch() {
$PACKAGE_DOPATCH_ACTIONS
}"
        dopatch "$1"
    else
        case $PACKAGE_BUILD_SYSTEM in
            autogen)
                note "dopatch mapping was not found in formula."
                run NOCONFIGURE=yes ./autogen.sh
                ;;
            autotools)
                note "dopatch mapping was not found in formula."
                run autoreconf -ivf
                ;;
            *)  note "dopatch mapping was not found in formula, skipped."
        esac
    fi

    #########################################################################################

    step "install for target"

    if [ "$PACKAGE_BUILD_IN_BSCRIPT_DIR" = yes ] ; then
        if [ "$PWD" != "$PACKAGE_BSCRIPT_DIR" ] ; then
            run cd "$PACKAGE_BSCRIPT_DIR"
        fi
    else
            run cd "$PACKAGE_BCACHED_DIR"
    fi

    if [ -d "$PACKAGE_INSTALL_DIR" ] ; then
        run rm -rf "$PACKAGE_INSTALL_DIR"
    fi

    eval "
dobuild() {
$PACKAGE_DOBUILD_ACTIONS
}"

    dobuild "$1"

    #########################################################################################

    [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] && {
        rm -f "$PACKAGE_INSTALL_DIR/.crates.toml"
        rm -f "$PACKAGE_INSTALL_DIR/.crates2.json"
    }

    #########################################################################################

    cd "$PACKAGE_INSTALL_DIR" || abort 1 "nothing is installed."

    [ -z "$(ls)" ]            && abort 1 "nothing is installed."

    #########################################################################################

    # reassigned to make sure it has the right value, becsuse it may be changed in dopatch and install block.

    PACKAGE_INSTALLING_SRC_DIR="$PACKAGE_WORKING_DIR/src"
    PACKAGE_INSTALLING_FIX_DIR="$PACKAGE_WORKING_DIR/fix"
    PACKAGE_INSTALLING_RES_DIR="$PACKAGE_WORKING_DIR/res"
    PACKAGE_INSTALLING_BIN_DIR="$PACKAGE_WORKING_DIR/bin"
    PACKAGE_INSTALLING_LIB_DIR="$PACKAGE_WORKING_DIR/lib"
    PACKAGE_INSTALLING_INC_DIR="$PACKAGE_WORKING_DIR/include"

    #########################################################################################

    PACKAGE_METAINF_DIR="$PACKAGE_INSTALL_DIR/.xcpkg"

    PACKAGE_MANIFEST_FILEPATH="$PACKAGE_METAINF_DIR/manifest.txt"
    PACKAGE_RECEIPT_FILEPATH="$PACKAGE_METAINF_DIR/receipt.yml"

    install -d "$PACKAGE_METAINF_DIR"

    #########################################################################################

    step "install COPYING"

    COPYING_FOUND=0

    for item in $(find "$PACKAGE_INSTALLING_SRC_DIR" -mindepth 1 -maxdepth 1 -name "COPYING*")
    do
        if [ -f "$item" ] ; then
            COPYING_FOUND=1
            install -v -m 644 "$item" "$PACKAGE_METAINF_DIR/"
        fi
    done

    if [ "$COPYING_FOUND" = 0 ] ; then
        note "'COPYING' named file was not found, skipped."
    fi

    #########################################################################################

    step "install LICENSE"

    if [ -f "$PACKAGE_INSTALLING_SRC_DIR/LICENSE" ] ; then
        install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/LICENSE" "$PACKAGE_METAINF_DIR/"
    else
        note "'LICENSE' named file was not found, skipped."
    fi

    #########################################################################################

    step "install AUTHORS"

    if [ -f "$PACKAGE_INSTALLING_SRC_DIR/AUTHORS" ] ; then
        install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/AUTHORS" "$PACKAGE_METAINF_DIR/"
    else
        note "'AUTHORS' named file was not found, skipped."
    fi

    #########################################################################################

    step "install CONTRIBUTORS"

    CONTRIBUTORS_FOUND=0

    for item in CONTRIBUTORS CONTRIBUTORS.md CONTRIBUTORS.rst
    do
        if [ -f "$PACKAGE_INSTALLING_SRC_DIR/$item" ] ; then
            CONTRIBUTORS_FOUND=1
            install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/$item" "$PACKAGE_METAINF_DIR/"
        fi
    done

    if [ "$CONTRIBUTORS_FOUND" = 0 ] ; then
        note "none of 'CONTRIBUTORS' 'CONTRIBUTORS.md' 'CONTRIBUTORS.rst' named files was found, skipped."
    fi

    #########################################################################################

    step "install README"

    README_FOUND=0

    for item in README README.md README.rst
    do
        if [ -f "$PACKAGE_INSTALLING_SRC_DIR/$item" ] ; then
            README_FOUND=1
            install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/$item" "$PACKAGE_METAINF_DIR/"
        fi
    done

    if [ "$README_FOUND" = 0 ] ; then
        note "none of 'README' 'README.md' 'README.rst' named files was found, skipped."
    fi

    #########################################################################################

    step "install CONTRIBUTING"

    CONTRIBUTING_FOUND=0

    for item in CONTRIBUTING CONTRIBUTING.md CONTRIBUTING.rst
    do
        if [ -f "$PACKAGE_INSTALLING_SRC_DIR/$item" ] ; then
            CONTRIBUTING_FOUND=1
            install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/$item" "$PACKAGE_METAINF_DIR/"
        fi
    done

    if [ "$CONTRIBUTING_FOUND" = 0 ] ; then
        note "none of 'CONTRIBUTING' 'CONTRIBUTING.md' 'CONTRIBUTING.rst' named files was found, skipped."
    fi

    #########################################################################################

    step "install CHANGELOG"

    CHANGELOG_FOUND=0

    for item in CHANGELOG CHANGELOG.md CHANGES
    do
        if [ -f "$PACKAGE_INSTALLING_SRC_DIR/$item" ] ; then
            install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/$item" "$PACKAGE_METAINF_DIR/"
            CHANGELOG_FOUND=1
            break;
        fi
    done

    if [ "$CHANGELOG_FOUND" = 0 ] ; then
        note "none of 'CHANGELOG' 'CHANGELOG.md' 'CHANGES' named files was found, skipped."
    fi

    #########################################################################################

    step "install NEWS"

    if [ -f "$PACKAGE_INSTALLING_SRC_DIR/NEWS" ] ; then
        install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/NEWS" "$PACKAGE_METAINF_DIR/"
    else
        note "'NEWS' named file was not found, skipped."
    fi

    #########################################################################################

    step "install TODO"

    if [ -f "$PACKAGE_INSTALLING_SRC_DIR/TODO" ] ; then
        install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/TODO" "$PACKAGE_METAINF_DIR/"
    else
        note "'TODO' named file was not found, skipped."
    fi

    #########################################################################################

    step "install FAQ"

    if [ -f "$PACKAGE_INSTALLING_SRC_DIR/FAQ" ] ; then
        install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/FAQ" "$PACKAGE_METAINF_DIR/"
    else
        note "'FAQ' named file was not found, skipped."
    fi

    #########################################################################################

    step "install THANKS"

    if [ -f "$PACKAGE_INSTALLING_SRC_DIR/THANKS" ] ; then
        install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/THANKS" "$PACKAGE_METAINF_DIR/"
    else
        note "'THANKS' named file was not found, skipped."
    fi

    #########################################################################################

    step "install config.log"

    for dir in "$PACKAGE_BCACHED_DIR" "$PACKAGE_BSCRIPT_DIR"
    do
        if [ -f "$dir/config.log" ] ; then
            install -v -m 644 "$dir/config.log" "$PACKAGE_METAINF_DIR"
        fi
    done

    #########################################################################################

    step "install compile_commands.json"

    for dir in "$PACKAGE_BCACHED_DIR" "$PACKAGE_BSCRIPT_DIR"
    do
        if [ -f "$dir/compile_commands.json" ] ; then
            install -v -m 644 "$dir/compile_commands.json" "$PACKAGE_METAINF_DIR"
        fi
    done

    #########################################################################################

    step "install dependency graph files"

    find "$PACKAGE_WORKING_DIR" -mindepth 1 -maxdepth 1 \( -name dependencies.dot -o -name dependencies.box -o -name dependencies.svg -o -name dependencies.png \) -exec install -v -m 644 {} "$PACKAGE_METAINF_DIR" \;

    #########################################################################################

    [ -n "$PACKAGE_DEP_PKG" ] && {
        step "install dependency formulas"

        install -v -d "$PACKAGE_METAINF_DIR/formula"

        for DEPENDENT_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
        do
            install -v -m 644 "$SESSION_DIR/$DEPENDENT_PACKAGE_NAME.yml" "$PACKAGE_METAINF_DIR/formula"
        done
    }

    #########################################################################################

    step "adjust Mach-O files for ${COLOR_GREEN}$*${COLOR_OFF}"
    __adjust_mach_o_files_for_the_given_target "$@"

    if [ -d "$PACKAGE_INSTALL_DIR/lib" ] ; then
        step "adjust .la files for ${COLOR_GREEN}$*${COLOR_OFF}"
        __adjust_la_files_for_the_given_target "$@"

        step "adjust .pc files for ${COLOR_GREEN}$*${COLOR_OFF}"
        __adjust_pc_files_for_the_given_target "$@"
    fi

    #########################################################################################

    step "generate manifest.txt"
    __generate_manifest_of_the_given_package "$1"

    step "generate receipt.yml"
    __generate_receipt_of_the_given_package "$1"

    [ "$PACKAGE_SYMLINK" = yes ] && {
        step "symlink installed files to $XCPKG_PACKAGE_SYMLINKED_ROOT"
        __symlink_installed_files_of_the_given_package "$1"
    }

    #########################################################################################

    [ "$CCACHE_ENABLED" = yes ] && {
        step "show ccache statistics summary"
        note "Before Build:"
        run  cat "$PACKAGE_WORKING_DIR/ccache-s.txt"
        note "After  Build:"
        run  ccache -s
    }

    [ "$KEEP_INSTALLING_DIR" != yes ] && {
        step "delete the installing directory"
        run rm -rf "$PACKAGE_WORKING_DIR"
    }

    printf '\n'
    success "$1 have been successfully installed."

    step "show installed files in tree-like format"
    __tree_the_given_installed_package "$1" --dirsfirst -a
}


__adjust_mach_o_files_for_the_given_target() {
    unset BASE64_COMMAND; export BASE64_COMMAND="$(command -v base64)"

    BASE64_ENCODE_STRING_COMMAND="$XCPKG_CORE_BIN_DIR/base64-encode-string"

    for x in bin sbin lib libexec
    do
        [ -d "$PACKAGE_INSTALL_DIR/$x" ] || continue

        for BASE64_ENCODED_RELATIVE_FILEPATH in $(cd "$PACKAGE_INSTALL_DIR/$x" && find . -not -name . -type f -exec $BASE64_ENCODE_STRING_COMMAND {} \;)
        do
            unset BASE64_DECODED_RELATIVE_FILEPATH
            BASE64_DECODED_RELATIVE_FILEPATH="$(printf '%s\n' "$BASE64_ENCODED_RELATIVE_FILEPATH" | base64 -d)"

            FILEPATH="$PACKAGE_INSTALL_DIR/$x/${BASE64_DECODED_RELATIVE_FILEPATH#./}"

            unset FILE_HEADER_ACTUAL
            FILE_HEADER_ACTUAL="$(hexdump -n 16 -v -e '1/1 "%02X" ""' "$FILEPATH")"

            # https://github.com/aidansteele/osx-abi-macho-file-format-reference
            case $FILE_HEADER_ACTUAL in
                CFFAEDFE0C000001000000000[26]000000)
                    # arm64
                    ;;
                CFFAEDFE07000001030000000[26]000000)
                    # x86_64
                    ;;
                *)  continue
            esac

            unset DT_SONAME
            DT_SONAME=$( otool -l "$FILEPATH" | grep LC_ID_DYLIB   -A2 | grep name | sed 's|^[[:space:]]*||' | cut -d ' ' -f2)

            unset DT_NEEDED
            DT_NEEDED=$( otool -l "$FILEPATH" | grep LC_LOAD_DYLIB -A2 | grep name | sed 's|^[[:space:]]*||' | cut -d ' ' -f2)

            unset DT_RUNPATH
            DT_RUNPATH=$(otool -l "$FILEPATH" | grep LC_RPATH      -A2 | grep path | sed 's|^[[:space:]]*||' | cut -d ' ' -f2)

            if [ -z "$DT_NEEDED" ] ; then
                abort 1 "no dependent shared libraries found in $FILEPATH"
            fi

            printf '%s\n' "DT_SONAME=\n$DT_SONAME"
            printf '%s\n' "DT_NEEDED=\n$DT_NEEDED"
            printf '%s\n' "DT_RUNPATH=\n$DT_RUNPATH"

            case $DT_SONAME in
                '') ;;
                @*) ;;
                /*) ;;
                lib*.dylib) run install_name_tool -id "@rpath/$DT_SONAME" "$FILEPATH"
            esac

            for NEEDED in $DT_NEEDED
            do
                case $NEEDED in
                    lib*.dylib)
                        run install_name_tool -change "$NEEDED" "@rpath/$NEEDED" "$FILEPATH"
                esac
            done

            if [ "$BUILD_TYPE" = release ] ; then
                if [ "$x" != lib ] ; then
                    run "$STRIP" $STRIP_ARG "$FILEPATH" || true
                fi
            fi
        done
    done
}

__adjust_la_files_for_the_given_target() {
    [ -d "$PACKAGE_INSTALL_DIR/lib" ] || {
        note "no .la files installed, skipped"
        return 0
    }

    LA_FILES="$(find "$PACKAGE_INSTALL_DIR/lib" -name "*.la")"

    [ -z "$LA_FILES" ] && {
        note "no .la files installed, skipped"
        return 0
    }

    for lafile in $LA_FILES
    do
        sed_in_place 's|-Wl,--strip-debug||g'      "$lafile"
        sed_in_place "s|-L$XCPKG_HOME[^' ]*||g"    "$lafile"
        sed_in_place "s|-R[^' ]*||g"               "$lafile"
        #sed_in_place "s|-L$SYSTEM_LIBRARY_DIR||g"  "$lafile"
        #sed_in_place "s|--sysroot $SYSROOT||g"     "$lafile"
    done
}

__adjust_pc_files_for_the_given_target() {
    [ -d "$PACKAGE_INSTALL_DIR/lib/pkgconfig" ] || {
        note "no .pc files installed, skipped"
        return 0
    }

    PC_FILES="$(find "$PACKAGE_INSTALL_DIR/lib/pkgconfig" -name "*.pc")"

    [ -z "$PC_FILES" ] && {
        note "no .pc files installed, skipped"
        return 0
    }

    # cc: error: unrecognized command line option â€˜-Râ€™
    for pcfile in $PC_FILES
    do
        sed_in_place "s|$PACKAGE_INSTALL_DIR|\${pcfiledir}/../..|g" "$pcfile"
        sed_in_place 's|-Wl,--strip-debug||g'      "$pcfile"
        sed_in_place "s|-L$XCPKG_HOME[^' ]*||g"    "$pcfile"
        sed_in_place "s|-R[^' ]*||g"               "$pcfile"
        #sed_in_place "s|-L$SYSTEM_LIBRARY_DIR||g"  "$pcfile"
        #sed_in_place "s|--sysroot $SYSROOT||"      "$pcfile"

        if grep 'Libs.private:' "$pcfile" > /dev/null ; then
            if grep 'Libs:' "$pcfile" > /dev/null ; then
                LIBS_PRIVATE_CONTENT=$(sed -n '/Libs.private:/p' "$pcfile" | cut -c14-)
                sed_in_place "/Libs:/s|\$|$LIBS_PRIVATE_CONTENT|" "$pcfile"
                sed_in_place '/Libs.private:/d' "$pcfile"
            else
                sed_in_place 's|Libs.private:|Libs:|' "$pcfile"
            fi
        fi

        if grep 'Requires.private:' "$pcfile" > /dev/null ; then
            if grep 'Requires:' "$pcfile" > /dev/null ; then
                REQUIRES_PRIVATE_CONTENT=$(sed -n '/Requires.private:/p' "$pcfile" | cut -c18-)
                sed_in_place "/Requires:/s|\$|$REQUIRES_PRIVATE_CONTENT|" "$pcfile"
                sed_in_place '/Requires.private:/d' "$pcfile"
            else
                sed_in_place 's|Requires.private:|Requires:|' "$pcfile"
            fi
        fi
    done
}


__install_pc_file_if_needed_for_the_given_target() {
    if [ -d "$PACKAGE_INSTALL_DIR/lib" ] ; then
        if [ ! -d "$PACKAGE_INSTALL_DIR/lib/pkgconfig" ] ; then
            cat > "$PACKAGE_BCACHED_DIR/$1.pc" << EOF
EOF
            run install_pcfs "$PACKAGE_BCACHED_DIR/$1.pc"
        fi
    fi
}

install_incs() {
    while [ -n "$1" ]
    do
        unset X1
        unset X2
        X1=$(printf '%s\n' "$1" | cut -d: -f1)
        X2=$(printf '%s\n' "$1" | cut -d: -f2)

        if [ "$X1" = "$X2" ] ; then
            unset X2
        fi

        install -v -d         "$PACKAGE_INSTALL_DIR/include/$X2" || return 1
        install -v -m 644 $X1 "$PACKAGE_INSTALL_DIR/include/$X2" || return 1

        shift
    done
}

install_libs() {
    install -v -d "$PACKAGE_INSTALL_DIR/lib" || return 1
    for item in "$@"
    do
        case $item in
            *.a) install -v -m 644 "$item" "$PACKAGE_INSTALL_DIR/lib" || return 1 ;;
            *)   install -v -m 755 "$item" "$PACKAGE_INSTALL_DIR/lib" || return 1 ;;
        esac
    done
}

install_pcfs() {
    install -v -d          "$PACKAGE_INSTALL_DIR/lib/pkgconfig" &&
    install -v -m 644 "$@" "$PACKAGE_INSTALL_DIR/lib/pkgconfig"
}

install_bins() {
    install -v -d          "$PACKAGE_INSTALL_DIR/bin" &&
    install -v -m 755 "$@" "$PACKAGE_INSTALL_DIR/bin"
}

install_etcs() {
    install -v -d          "$PACKAGE_INSTALL_DIR/etc" &&
    install -v -m 644 "$@" "$PACKAGE_INSTALL_DIR/etc"
}

install_mans() {
    for item in "$@"
    do
        unset NUMBER
        NUMBER=$(printf '%s\n' "$item" | cut -c ${#item}-${#item})
        case $NUMBER in
            [1-8]);;
            *)    abort 1 "$item: not a manpage."
        esac
        install -v -d           "$PACKAGE_INSTALL_DIR/share/man/man$NUMBER" &&
        install -v -m 644 $item "$PACKAGE_INSTALL_DIR/share/man/man$NUMBER"
    done
}

# install_completion <fish|bash|zsh> <COMMAND> <FILE-PATH>
  install_completion() {
    case $1 in
        bash)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/bash/completions" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/bash/completions/$2"
            ;;
        fish)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/fish/vendor_completions.d" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/fish/vendor_completions.d/$2.fish"
            ;;
        zsh)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/zsh/site-functions" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/zsh/site-functions/_$2"
            ;;
        *)  abort 1 "install_completion unsupported shell: $1"
    esac
}

install_pc_file() {
    install -v -d "$PACKAGE_INSTALL_DIR/lib/pkgconfig" &&
    cat >         "$PACKAGE_INSTALL_DIR/lib/pkgconfig/$1.pc"
}

# __symlink_installed_files_of_the_given_package <PACKAGE-NAME>
  __symlink_installed_files_of_the_given_package() {
      return 0
    # while read -r item
    # do
    #     X=$(printf '%s\n' "$item" | cut -d '|' -f1)
    #     Y=$(printf '%s\n' "$item" | cut -d '|' -f3)

    #     case $X in
    #         d)  ;;
    #         D)  ;;
    #         *)  case $Y in
    #                 share/info/dir) ;;
    #                 *)  if [ -L "$XCPKG_PACKAGE_SYMLINKED_ROOT/$Y" ] || [ -e "$XCPKG_PACKAGE_SYMLINKED_ROOT/$Y" ] ; then
    #                         abort 1 "$XCPKG_PACKAGE_SYMLINKED_ROOT/$Y already exists."
    #                     # else
    #                     #     echo "$XCPKG_PACKAGE_SYMLINKED_ROOT/$Y"
    #                     fi
    #             esac
    #     esac
    # done < "$PACKAGE_MANIFEST_FILEPATH"

    # ############################################################################

    if [ !      -d "$XCPKG_PACKAGE_SYMLINKED_ROOT/.registry" ] ; then
        install -d "$XCPKG_PACKAGE_SYMLINKED_ROOT/.registry"
    fi

    exec 7> "$XCPKG_PACKAGE_SYMLINKED_ROOT/.registry/$1"

    while read -r item
    do
        X=$(printf '%s\n' "$item" | cut -d '|' -f1)
        Y=$(printf '%s\n' "$item" | cut -d '|' -f3)

        case $X in
            d|D)
                if [ !      -d "$XCPKG_PACKAGE_SYMLINKED_ROOT/$Y" ] ; then
                    install -d "$XCPKG_PACKAGE_SYMLINKED_ROOT/$Y"
                fi
                ;;
            *)  case $Y in
                    share/info/dir) ;;
                    *)  run ln -sfr "\"$XCPKG_PACKAGE_INSTALLED_ROOT/$1/$Y\"" "\"$XCPKG_PACKAGE_SYMLINKED_ROOT/$Y\""
                        printf '%s\n' "$Y" >&7
                esac
        esac
    done < "$PACKAGE_MANIFEST_FILEPATH"

    exec 7>&-
}

# }}}
##############################################################################
# {{{ configure

configure_only() {
    export FORCE_UNSAFE_CONFIGURE=1

    export ac_cv_func_malloc_0_nonnull=yes
    export ac_cv_func_calloc_0_nonnull=yes
    export ac_cv_func_realloc_0_nonnull=yes


    if [ "$STEP_MESSAGE" = 'build for native' ] ; then
        if run "$PACKAGE_BSCRIPT_DIR"/configure \
            --prefix="$NATIVE_INSTALL_DIR" \
            "$@" ; then
            printf '\n'
        else
            if [ -f "$PACKAGE_BCACHED_DIR/config.log" ] ; then
                run cat "$PACKAGE_BCACHED_DIR/config.log"
            elif [ -f "$PACKAGE_BSCRIPT_DIR/config.log" ] ; then
                run cat "$PACKAGE_BSCRIPT_DIR/config.log"
            fi
            return 1
        fi
    else
        unset TARGET_TRIPLE

        if [ 'arm64' = "$TARGET_PLATFORM_ARCH" ] ; then
            if [ "$PACKAGE_IOS_IOS" = yes ] ; then
                TARGET_TRIPLE='aarch64-apple-ios'
            else
                TARGET_TRIPLE='aarch64-apple-darwin'
            fi
        else
            if [ "$PACKAGE_IOS_IOS" = yes ] ; then
                TARGET_TRIPLE="$TARGET_PLATFORM_ARCH-apple-ios"
            else
                TARGET_TRIPLE="$TARGET_PLATFORM_ARCH-apple-darwin"
            fi
        fi

        CONFIGURE_ARGS="--prefix=$PACKAGE_INSTALL_DIR"

        if [ "$CROSS_COMPILING" = yes ] ; then
            CONFIGURE_ARGS="$CONFIGURE_ARGS --host=$TARGET_TRIPLE"
        fi

        if [ "$BUILD_TYPE" = release ] ; then
            CONFIGURE_ARGS="$CONFIGURE_ARGS --disable-debug"
        else
            CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-debug"
        fi

        case $INSTALL_LIB in
            static) CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-static --disable-shared" ;;
            shared) CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-shared --disable-static" ;;
            both)   CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-static --enable-shared"  ;;
            no)     CONFIGURE_ARGS="$CONFIGURE_ARGS --disable-static --disable-shared";;
        esac

        CONFIGURE_ARGS="$CONFIGURE_ARGS --disable-option-checking --enable-rpath --disable-nls --enable-largefile"

        if [ -n "$XCPKG_XTRACE" ] ; then
            sed_in_place '1a set -x' "$PACKAGE_BSCRIPT_DIR/configure"
        fi

        if run "$PACKAGE_BSCRIPT_DIR/configure" "$CONFIGURE_ARGS" "$@" ; then
            printf '\n'
        else
            if [ -f "$PACKAGE_BCACHED_DIR/config.log" ] ; then
                run cat "$PACKAGE_BCACHED_DIR/config.log"
            elif [ -f "$PACKAGE_BSCRIPT_DIR/config.log" ] ; then
                run cat "$PACKAGE_BSCRIPT_DIR/config.log"
            fi

            return 1
        fi
    fi

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
        for Makefile in $(find "$PACKAGE_BSCRIPT_DIR" -name Makefile)
        do
            sed_in_place 's|\t@|\t|g'     "$Makefile" || return 1
            sed_in_place 's|@echo|echo|g' "$Makefile" || return 1
        done
        unset Makefile
    fi
}

configure() {
    configure_only "$@" &&
    gmakew clean &&
    gmakew V=1   &&
    gmakew install
}

# }}}
##############################################################################
# {{{ gmakew

gmakew() {
    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERY_VERBOSE" ] ; then
        run "$GMAKE -w -j$BUILD_NJOBS --debug V=1 $*"
    else
        run "$GMAKE -w -j$BUILD_NJOBS $*"
    fi
}

# https://cmake.org/cmake/help/latest/command/enable_testing.html?highlight=build_testing
# https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling
#
# https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html
# https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
#
# https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
#
# run in a subshell
cmakew() {
    if [ "$STEP_MESSAGE" = 'build for native' ] ; then
        if [ "$PACKAGE_BUILD_SYSTEM_NINJA" = yes ] ; then
            CMAKE_GENERATOR='Ninja'
        else
            CMAKE_GENERATOR='Unix Makefiles'
        fi

        if [ "$LOG_LEVEL" -eq 0 ] ; then
            CMAKE_VERBOSE_MAKEFILE=OFF
            CMAKE_COLOR_MAKEFILE=OFF
        else
            CMAKE_VERBOSE_MAKEFILE=ON
            CMAKE_COLOR_MAKEFILE=ON
        fi

        if [ "$LOG_LEVEL" -ge 3 ] ; then
            CMAKE_FIND_DEBUG_MODE=ON
        else
            CMAKE_FIND_DEBUG_MODE=OFF
        fi

        run "$CMAKE" \
            -Wno-dev \
            -G "'$CMAKE_GENERATOR'" \
            -S "$PACKAGE_BSCRIPT_DIR" \
            -B "$NATIVE_BCACHED_DIR" \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_INSTALL_PREFIX="$NATIVE_INSTALL_DIR" \
            -DCMAKE_FIND_DEBUG_MODE="$CMAKE_FIND_DEBUG_MODE" \
            -DCMAKE_VERBOSE_MAKEFILE="$CMAKE_VERBOSE_MAKEFILE" \
            -DCMAKE_COLOR_MAKEFILE="$CMAKE_COLOR_MAKEFILE" \
            -DBUILD_SHARED_LIBS=OFF \
            -DBUILD_TESTING=OFF \
            "$@" &&
        run "$CMAKE" --build   "$NATIVE_BCACHED_DIR" -- "-j$BUILD_NJOBS" &&
        run "$CMAKE" --install "$NATIVE_BCACHED_DIR"
    else
        BUILD_SHARED_LIBS_IS_SPECIFIED=no

        for OPT in "$@"
        do
            case $OPT in
                -DBUILD_SHARED_LIBS=*) BUILD_SHARED_LIBS_IS_SPECIFIED=yes; break
            esac
        done

        CMAKE_CONFIG_OPTIONS_EXTRA=

        [ "$BUILD_SHARED_LIBS_IS_SPECIFIED" = no ] && {
            case $INSTALL_LIB in
                static)  CMAKE_CONFIG_OPTIONS_EXTRA=-DBUILD_SHARED_LIBS=OFF ;;
                *)       CMAKE_CONFIG_OPTIONS_EXTRA=-DBUILD_SHARED_LIBS=ON  ;;
            esac
        }

        run "$CMAKE" \
            -Wno-dev \
            -S "$PACKAGE_BSCRIPT_DIR" \
            -B "$PACKAGE_BCACHED_DIR" \
            -DBUILD_TESTING=OFF \
            -DCMAKE_INSTALL_PREFIX="$PACKAGE_INSTALL_DIR" \
            -DCMAKE_TOOLCHAIN_FILE="$CMAKE_TOOLCHAIN_FILE" \
            -DCMAKE_PROJECT_INCLUDE="$CMAKE_PROJECT_INCLUDE" \
            -DCMAKE_VERBOSE_MAKEFILE="$CMAKE_VERBOSE_MAKEFILE" \
            -DCMAKE_COLOR_MAKEFILE="$CMAKE_COLOR_MAKEFILE" \
            "$CMAKE_CONFIG_OPTIONS_EXTRA" "$@" &&
        run "$CMAKE" --build   "$PACKAGE_BCACHED_DIR" -- "-j$BUILD_NJOBS" &&
        run "$CMAKE" --install "$PACKAGE_BCACHED_DIR"
    fi
}

# }}}
##############################################################################
# {{{ xmakew

# run in a subshell
xmakew() {
    XMAKE_CONFIG_OPTIONS="$*"

    XMAKE_CONFIG_OPTION_CLEAN=
    XMAKE_CONFIG_OPTION_MODE=
    XMAKE_CONFIG_OPTION_vD=

    for arg in "$@"
    do
        case $arg in
            -c|--clean)  XMAKE_CONFIG_OPTION_CLEAN='set' ;;
            -m|--mode=*) XMAKE_CONFIG_OPTION_MODE='set'  ;;
            -vD)         XMAKE_CONFIG_OPTION_vD='set' ;;
        esac
    done

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERY_VERBOSE" ] && [ -z "$XMAKE_CONFIG_OPTION_vD" ]; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTION_vD -vD"
    fi

    if [ -z "$XMAKE_CONFIG_OPTION_CLEAN" ] ; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --clean"
    fi

    if [ -z "$XMAKE_CONFIG_OPTION_MODE" ] ; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --mode=$BUILD_TYPE"
    fi

    if [ "$STEP_MESSAGE" = 'build for native' ] ; then
        run $XMAKE config $XMAKE_CONFIG_OPTIONS --project=$PACKAGE_BSCRIPT_DIR --buildir=$NATIVE_BCACHED_DIR &&
        run $XMAKE --jobs=$BUILD_NJOBS &&
        run $XMAKE install -o "$NATIVE_INSTALL_DIR"
    else
        unset XMAKE_PLATFORM
        XMAKE_PLATFORM="$(printf '%s\n' "$TARGET_PLATFORM_NAME_LOWER_CASE" | sed 's|simulator|os|')"
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --plat=$XMAKE_PLATFORM"

        case $TARGET_PLATFORM_NAME in
            *Simulator) XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --appledev=simulator"
        esac

        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --arch=$TARGET_PLATFORM_ARCH --buildir=$PACKAGE_BCACHED_DIR"

        run $XMAKE config $XMAKE_CONFIG_OPTIONS &&
        run $XMAKE --jobs=$BUILD_NJOBS &&
        run $XMAKE install -o "$PACKAGE_INSTALL_DIR"
    fi
}

# }}}
##############################################################################
# {{{ mesonw

# https://mesonbuild.com/Cross-compilation.html
# run in a subshell
mesonw() {
    case $TARGET_PLATFORM_ARCH in
        armv7*)
            HOST_MACHINE_CPU_FAMILY='arm'
            HOST_MACHINE_CPU_NAME="$TARGET_PLATFORM_ARCH"
            ;;
        arm64*|aarch64)
            HOST_MACHINE_CPU_FAMILY='aarch64'
            HOST_MACHINE_CPU_NAME='armv8a'
            ;;
        i386|i686)
            HOST_MACHINE_CPU_FAMILY='x86'
            HOST_MACHINE_CPU_NAME="$TARGET_PLATFORM_ARCH"
            ;;
        x86_64)
            HOST_MACHINE_CPU_FAMILY='x86_64'
            HOST_MACHINE_CPU_NAME="$TARGET_PLATFORM_ARCH"
            ;;
    esac

    MESON_CROSS_FILE="$PACKAGE_BCACHED_DIR/cross-file"

    cat > "$MESON_CROSS_FILE" <<EOF
[host_machine]
system = 'darwin'
endian = 'little'
cpu_family = '$HOST_MACHINE_CPU_FAMILY'
cpu = '$HOST_MACHINE_CPU_NAME'

[binaries]
c = '$CC'
cpp = '$CXX'
ar = '$AR'
strip = '$STRIP'
cmake = '$CMAKE'
pkgconfig = '$PKG_CONFIG'

# https://mesonbuild.com/Machine-files.html#meson-builtin-options
[built-in options]
c_args = $(to_meson_array $CFLAGS $CPPFLAGS)
c_link_args = $(to_meson_array $LDFLAGS)
cpp_args = $(to_meson_array $CXXFLAGS $CPPFLAGS)
cpp_link_args = $(to_meson_array $LDFLAGS)
EOF
    if [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] ; then
        cat >> "$MESON_CROSS_FILE" <<EOF

[properties]
cmake_toolchain_file='$CMAKE_TOOLCHAIN_FILE'
EOF
    fi

    unset MESON_ARGUMENT_DEFAULT_LIBRARY

    case $INSTALL_LIB in
        static|shared|both) MESON_ARGUMENT_DEFAULT_LIBRARY="-Ddefault_library=$INSTALL_LIB"
    esac

    run "$MESON" setup \
        --prefix="$PACKAGE_INSTALL_DIR" \
        --buildtype=$BUILD_TYPE \
        --backend=ninja \
        --pkg-config-path="$PKG_CONFIG_PATH" \
        --build.pkg-config-path="$PKG_CONFIG_PATH_FOR_BUILD" \
        --cross-file="$MESON_CROSS_FILE" \
        $MESON_ARGUMENT_DEFAULT_LIBRARY \
        "$@" "$PACKAGE_BCACHED_DIR" "$PACKAGE_BSCRIPT_DIR" &&
    run ninja -C "$PACKAGE_BCACHED_DIR" &&
    run ninja -C "$PACKAGE_BCACHED_DIR" install
}

to_meson_array() {
    RESULT="[''"
    for item in "$@"
    do
        RESULT="$RESULT, '$item'"
    done
    RESULT="$RESULT]"
    printf '%s\n' "$RESULT"
}

# }}}
##############################################################################
# {{{ cargow

cargow() {
    run rustup target add "$RUST_TARGET"

    case $1 in
        build)
            # https://doc.rust-lang.org/cargo/commands/cargo-clean.html
            # https://doc.rust-lang.org/cargo/commands/cargo-build.html

            unset CARGO_BUILD_ARGS
            unset CARGO_BUILD_ARG_VV
            unset CARGO_BUILD_ARG_TARGET
            unset CARGO_BUILD_ARG_RELEASE

            for arg in "$@"
            do
                case $arg in
                    --vv)      CARGO_BUILD_ARG_VV='set'      ;;
                    --target)  CARGO_BUILD_ARG_TARGET='set'  ;;
                    --release) CARGO_BUILD_ARG_RELEASE='set' ;;
                esac
            done

            CARGO_BUILD_ARGS="$@"

            if [ -z "$CARGO_BUILD_ARG_VV" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS -vv"
            fi

            if [ -z "$CARGO_BUILD_ARG_RELEASE" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS --release"
            fi

            if [ -z "$CARGO_BUILD_ARG_TARGET" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS --target $RUST_TARGET"
            fi

            run cargo clean && run cargo $CARGO_BUILD_ARGS
            ;;
        install)
            # https://doc.rust-lang.org/cargo/commands/cargo-clean.html
            # https://doc.rust-lang.org/cargo/commands/cargo-install.html

            unset CARGO_INSTALL_ARGS
            unset CARGO_INSTALL_ARG_TARGET
            unset CARGO_INSTALL_ARG_PATH
            unset CARGO_INSTALL_ARG_ROOT
            unset CARGO_INSTALL_ARG_VV

            for arg in "$@"
            do
                case $arg in
                    --target) CARGO_INSTALL_ARG_TARGET='set' ;;
                    --path)   CARGO_INSTALL_ARG_PATH='set'   ;;
                    --root)   CARGO_INSTALL_ARG_ROOT='set'   ;;
                    --vv)     CARGO_INSTALL_ARG_VV='set'     ;;
                esac
            done

            CARGO_INSTALL_ARGS="$@"

            if [ -z "$CARGO_INSTALL_ARG_VV" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS -vv"
            fi

            if [ -z "$CARGO_INSTALL_ARG_TARGET" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --target $RUST_TARGET"
            fi

            if [ -z "$CARGO_INSTALL_ARG_PATH" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --path $PACKAGE_BSCRIPT_DIR"
            fi

            if [ -z "$CARGO_INSTALL_ARG_ROOT" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --root=$PACKAGE_INSTALL_DIR"
            fi

            run cargo clean && run cargo $CARGO_INSTALL_ARGS
            ;;
        cbuild|cinstall)
            unset CARGO_CINSTALL_ARGS
            unset CARGO_CINSTALL_ARG_Q
            unset CARGO_CINSTALL_ARG_V
            unset CARGO_CINSTALL_ARG_VV
            unset CARGO_CINSTALL_ARG_DEBUG
            unset CARGO_CINSTALL_ARG_RELEASE
            unset CARGO_CINSTALL_ARG_TARGET
            unset CARGO_CINSTALL_ARG_PREFIX

            for arg in "$@"
            do
                case $arg in
                    -q|--quiet)   CARGO_CINSTALL_ARG_Q='set'       ;;
                    -v|--verbose) CARGO_CINSTALL_ARG_V='set'       ;;
                    -vv)          CARGO_CINSTALL_ARG_VV='set'      ;;
                    --debug)      CARGO_CINSTALL_ARG_DEBUG='set'   ;;
                    --release)    CARGO_CINSTALL_ARG_RELEASE='set' ;;
                    --target)     CARGO_CINSTALL_ARG_TARGET='set'  ;;
                    --prefix)     CARGO_CINSTALL_ARG_PREFIX='set'  ;;
                esac
            done

            CARGO_CINSTALL_ARGS="$@"

            if [ -z "$CARGO_CINSTALL_ARG_Q" ] && [ -z "$CARGO_CINSTALL_ARG_V" ] && [ -z "$CARGO_CINSTALL_ARG_VV" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS -vv"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_DEBUG" ] && [ -z "$CARGO_CINSTALL_ARG_RELEASE" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --release"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_TARGET" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --target $RUST_TARGET"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_PREFIX" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --prefix $PACKAGE_INSTALL_DIR"
            fi

            run cargo $CARGO_CINSTALL_ARGS
            ;;
        *) cargo "$@"
    esac
}

# }}}
##############################################################################
# {{{ gow

gow() {
    if command -v bat > /dev/null ; then
        run "go env | bat --language=bash --paging=never --style=plain"
    else
        run "go env"
    fi

    printf '\n'

    # /Users/runner/go/pkg/mod/golang.org/x/sys@v0.0.0-20191028164358-195ce5e7f934/unix/syscall_darwin.1_13.go:25:3: //go:linkname must refer to declared function or variable
    GOMOD="$PACKAGE_BSCRIPT_DIR/go.mod"

    if [ -f "$GOMOD" ] && go mod graph | grep -q 'golang\.org/x/sys' ; then
        run go get -u golang.org/x/sys

        if [ -d "$PACKAGE_BSCRIPT_DIR/vendor" ] ; then
            unset GO_VERSION_MAJOR
            unset GO_VERSION_MINOR

            GO_VERSION_MAJOR=$(go env GOVERSION | cut -c3- | cut -d. -f1)
            GO_VERSION_MINOR=$(go env GOVERSION | cut -c3- | cut -d. -f2)

            sed_in_place "/^go[[:space:]]*[1-9]\.[0-9][0-9]/c go $GO_VERSION_MAJOR.$GO_VERSION_MINOR" "$GOMOD"

            run go mod tidy
            run go mod vendor
        fi
    fi

    # https://pkg.go.dev/cmd/go
    # https://pkg.go.dev/cmd/link

    unset GO_BUILD_ARGS
    unset GO_BUILD_ARGV_V
    unset GO_BUILD_ARGV_X
    unset GO_BUILD_ARGV_O
    unset GO_BUILD_ARGV_MOD
    unset GO_BUILD_ARGV_TAGS
    unset GO_BUILD_ARGV_LDFLAGS

    unset GO_BUILD_ARGS_EXTRA

    while [ -n "$1" ]
    do
        case $1 in
            -v) shift ; GO_BUILD_ARGV_V='-v' ;;
            -x) shift ; GO_BUILD_ARGV_X='-x' ;;
            -o) shift ; GO_BUILD_ARGV_O="$1" ; shift ;;
            -X) shift
                if [ -z "$GO_BUILD_ARGV_LDFLAGS" ] ; then
                    GO_BUILD_ARGV_LDFLAGS="-X $1"
                else
                    GO_BUILD_ARGV_LDFLAGS="$GO_BUILD_ARGV_LDFLAGS -X $1"
                fi
                shift
                ;;
            -ldflags)
                shift
                if [ -z "$GO_BUILD_ARGV_LDFLAGS" ] ; then
                    GO_BUILD_ARGV_LDFLAGS="$1"
                else
                    GO_BUILD_ARGV_LDFLAGS="$1 $GO_BUILD_ARGV_LDFLAGS"
                fi
                shift
                ;;
            *)  GO_BUILD_ARGS_EXTRA="$GO_BUILD_ARGS_EXTRA $1" ; shift
        esac
    done

    GO_BUILD_ARGS='-trimpath'

    if [ -z "$GO_BUILD_ARGV_V" ] ; then
        if [ "$LOG_LEVEL" -gt 0 ] ; then
            GO_BUILD_ARGS="$GO_BUILD_ARGS -v"
        fi
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -v"
    fi

    if [ -z "$GO_BUILD_ARGV_X" ] ; then
        if [ "$LOG_LEVEL" -ge 2 ] ; then
            GO_BUILD_ARGS="$GO_BUILD_ARGS -x"
        fi
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -x"
    fi

    if [ "$BUILD_TYPE" = release ] ; then
        GO_BUILD_ARGV_LDFLAGS="$GO_BUILD_ARGV_LDFLAGS -s -w"
    fi

    GO_BUILD_ARGS="$GO_BUILD_ARGS -ldflags '$GO_BUILD_ARGV_LDFLAGS'"

    if [ -z "$GO_BUILD_ARGV_O" ] ; then
        GO_BUILD_ARGS="$GO_BUILD_ARGS -o $PACKAGE_BCACHED_DIR/"
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -o $PACKAGE_BCACHED_DIR/$GO_BUILD_ARGV_O"
    fi

    GO_BUILD_ARGS="$GO_BUILD_ARGS $GO_BUILD_ARGS_EXTRA"

    # shellcheck disable=SC2086
    run go build $GO_BUILD_ARGS

    for item in $(ls "$PACKAGE_BCACHED_DIR")
    do
        case $item in
            *.a)     run install_libs "$PACKAGE_BCACHED_DIR/$item" ;;
            *.dylib) run install_libs "$PACKAGE_BCACHED_DIR/$item" ;;
            *)       run install_bins "$PACKAGE_BCACHED_DIR/$item" ;;
        esac
    done
}


# }}}
##############################################################################
# {{{ system(3) stub

inject_stub_system() {
    cat > "$PACKAGE_BSCRIPT_DIR/stub-system.c" <<EOF
#ifndef SYSTEM_STUB_C
#define SYSTEM_STUB_C

#include <stdlib.h>
#include <unistd.h>
#include <spawn.h>
#include <sys/wait.h>

extern char **environ;

#ifdef __cplusplus
    extern "C" {
#endif

__attribute__((unused))
static int stub_system(char* cmd) {
    char argv0[] = "sh";
    char argv1[] = "-c";
    char* const argv[4] = {argv0, argv1, cmd, NULL};
    pid_t pid;
    int status;
    status = posix_spawn(&pid, "/bin/sh", NULL, NULL, argv, environ);
    if (0 == status) {
        return waitpid(pid, &status, 0);
    }
    return status;
}

#define system(x) stub_system(x)

#ifdef __cplusplus
    }
#endif

#endif
EOF
    for item in "$@"
    do
        printf '%s\n' "inject $PACKAGE_BSCRIPT_DIR/stub-system.c -> $item"
        cat "$PACKAGE_BSCRIPT_DIR/stub-system.c" "$item" > "$item.bak" || return 1
        mv "$item.bak" "$item" || return 1
    done
}

# }}}
##############################################################################
# {{{ xcpkg xcinfo [ --developer-dir=<DEVELOPER_DIR> --list-supported-platform-names-only]

xcinfo() {
    unset USER_SPECIFIED_DEVELOPER_DIR
    unset LIST_SUPPORTED_PLATFORM_NAMES_ONLY

    for arg in "$@"
    do
        case "$arg" in
            --list-supported-platform-names-only)
                LIST_SUPPORTED_PLATFORM_NAMES_ONLY=yes
                ;;
            --developer-dir=*)
                USER_SPECIFIED_DEVELOPER_DIR="${arg#'--developer-dir='}"
                ;;
            *)  abort 1 "unrecognized option: $arg"
        esac
    done

    if [ -z "$USER_SPECIFIED_DEVELOPER_DIR" ] ; then
        if [ -z "$DEVELOPER_DIR" ] ; then
            DEVELOPER_DIR="$(xcode-select -p)"
            [ -z "$DEVELOPER_DIR" ] && abort 1 "Xcode developer dir can't be located.\nThere're 3 ways to resolve this problem:\n1. run command 'xcode-select --switch DEVELOPER_DIR', then try again.\n2. set system-wide environment variable DEVELOPER_DIR\3. set process-wide environment variable DEVELOPER_DIR, you can run xcpkg command as 'DEVELOPER_DIR=/some/path xcpkg'"
        else
            note "you have set DEVELOPER_DIR=$DEVELOPER_DIR, it will be used as the xcode developer directory."
        fi
    else
        DEVELOPER_DIR="$USER_SPECIFIED_DEVELOPER_DIR"
    fi

    [ -e "$DEVELOPER_DIR" ] || abort 1 "$DEVELOPER_DIR was expected to be exist, but it was not."
    [ -d "$DEVELOPER_DIR" ] || abort 1 "$DEVELOPER_DIR was expected to be a directory, but it was not."

    XCODE_DEFAULT_TOOLCHAIN_BIN_DIR="$DEVELOPER_DIR/Toolchains/XcodeDefault.xctoolchain/usr/bin"

    [ -e "$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR" ] || abort 1 "$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR was expected to be exist, but it was not."
    [ -d "$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR" ] || abort 1 "$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR was expected to be a directory, but it was not."

    export       CC="$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR/clang"
    export      CXX="$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR/clang++"
    export      CPP="$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR/cpp"
    export       AS="$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR/as"
    export       AR="$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR/ar"
    export   RANLIB="$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR/ranlib"
    export       LD="$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR/ld"
    export       NM="$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR/nm"
    export    STRIP="$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR/strip"
    export     SIZE="$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR/size"
    export  STRINGS="$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR/strings"
    export  OBJDUMP="$XCODE_DEFAULT_TOOLCHAIN_BIN_DIR/objdump"

    XCODE_SUPPORT_PLATFORM_NAMES=

    XCODE_PLATFORMS_DIR="$DEVELOPER_DIR/Platforms"

    if [ -d "$XCODE_PLATFORMS_DIR" ] ; then
        for item in $(cd "$XCODE_PLATFORMS_DIR" && ls)
        do
            case $item in
                *.platform)
                    if [ -z "$XCODE_SUPPORT_PLATFORM_NAMES" ] ; then
                        XCODE_SUPPORT_PLATFORM_NAMES="${item%.platform}"
                    else
                        XCODE_SUPPORT_PLATFORM_NAMES="$XCODE_SUPPORT_PLATFORM_NAMES
${item%.platform}"
                    fi
            esac
        done

        if [ -z "$XCODE_SUPPORT_PLATFORM_NAMES" ] ; then
            abort 1 "no any platforms found in $XCODE_PLATFORMS_DIR"
        fi
    else
        [ -e "$XCODE_PLATFORMS_DIR" ] || abort 1 "$XCODE_PLATFORMS_DIR was expected to be exist, but it was not."
        [ -d "$XCODE_PLATFORMS_DIR" ] || abort 1 "$XCODE_PLATFORMS_DIR was expected to be a directory, but it was not."
    fi

    unset XCODE_VERSION; XCODE_VERSION=$(system_profiler SPDeveloperToolsDataType | grep Version | head -n 1 | cut -d: -f2 | sed 's/^ //g')

    if [ "$LIST_SUPPORTED_PLATFORM_NAMES_ONLY" = yes ] ; then
        printf '%s\n' "$XCODE_SUPPORT_PLATFORM_NAMES"
        return 0
    fi

    cat <<EOF
DEVELOPER_DIR: $DEVELOPER_DIR
XCODE_VERSION: $XCODE_VERSION

toolchains:
    default:
        CC:      $CC
        CXX:     $CXX
        CPP:     $CPP
        AS:      $AS
        AR:      $AR
        RANLIB:  $RANLIB
        LD:      $LD
        NM:      $NM
        SIZE:    $SIZE
        STRIP:   $STRIP
        STRINGS: $STRINGS
        OBJDUMP: $OBJDUMP

platforms:
EOF

    for TARGET_PLATFORM_NAME in $XCODE_SUPPORT_PLATFORM_NAMES
    do
        SDKNAME="$(printf '%s\n' "$TARGET_PLATFORM_NAME" | tr A-Z a-z)"
        SDKROOT="$(xcrun --sdk "$SDKNAME" --show-sdk-path)"
        SDK_SUPPORT_ARCHS="$(jq -r ".SupportedTargets.$SDKNAME.Archs | join(\" \")" "$SDKROOT/SDKSettings.json")"
        SDK_SUPPORT_VERSIONS="$(jq -r ".SupportedTargets.$SDKNAME.ValidDeploymentTargets | reverse | join(\" \")" "$SDKROOT/SDKSettings.json")"

        cat <<EOF

    $TARGET_PLATFORM_NAME:
        SDKROOT: $SDKROOT
        supported-archs: $SDK_SUPPORT_ARCHS
        supported-versions: $SDK_SUPPORT_VERSIONS
EOF
    done
}

# }}}
##############################################################################
# {{{ xcpkg setup

__setup() {
    if [ -d    "$XCPKG_CORE_DIR" ] ; then
        rm -rf "$XCPKG_CORE_DIR"
    fi

    install -d "$XCPKG_CORE_BIN_DIR"

    #################################################################################

    if [ "$1" = '--use-brew' ] ; then
        __setup_homebrew
    else
        __setup_uppm
    fi

    #################################################################################

    cat > "$XCPKG_CORE_BIN_DIR/base64-encode-string" <<EOF
#!/bin/sh
set -e

if [ -z "\$BASE64_COMMAND" ] ; then
    BASE64_COMMAND=base64
fi

printf '%s\n' "\$@" | "\$BASE64_COMMAND" -w 0
printf '\n'
EOF

    chmod +x "$XCPKG_CORE_BIN_DIR/base64-encode-string"

    success "xcpkg have been successfully setup."
}

__setup_homebrew() {
    BREW="$(command -v brew || true)"

    if [ -z "$BREW" ] ; then
        SETUP_WORKING_DIR="$(mktemp -d)"

        run curl -L -o "$SETUP_WORKING_DIR/homebrew-install.sh" 'https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh'
        run "yes | bash $SETUP_WORKING_DIR/homebrew-install.sh"

        BREW="$(command -v brew || true)"
    else
        run "$BREW" update
    fi

    BREW_PACKAGE_EXEFIND_PATH=

    for item in coreutils findutils util-linux gawk gsed grep gnu-tar gzip lzip unzip zip jq yq git curl tree
    do
        run "$BREW" install "$item"

        BREW_PACKAGE_INSTALLED_DIR="$(brew --prefix "$item")"

        if [ -d "$BREW_PACKAGE_INSTALLED_DIR/bin" ] ; then
            BREW_PACKAGE_EXEFIND_PATH="$BREW_PACKAGE_EXEFIND_PATH:$BREW_PACKAGE_INSTALLED_DIR/bin"
        fi

        if [ -d "$BREW_PACKAGE_INSTALLED_DIR/sbin" ] ; then
            BREW_PACKAGE_EXEFIND_PATH="$BREW_PACKAGE_EXEFIND_PATH:$BREW_PACKAGE_INSTALLED_DIR/sbin"
        fi

        if [ -d "$BREW_PACKAGE_INSTALLED_DIR/libexec/gnubin" ] ; then
            BREW_PACKAGE_EXEFIND_PATH="$BREW_PACKAGE_EXEFIND_PATH:$BREW_PACKAGE_INSTALLED_DIR/libexec/gnubin"
        fi
    done

    BREW_PACKAGE_EXEFIND_PATH="${BREW_PACKAGE_EXEFIND_PATH#':'}"

    run ln -sf /usr/local/bin/gln      "$XCPKG_CORE_BIN_DIR/ln"
    run ln -sf /usr/local/bin/gtar     "$XCPKG_CORE_BIN_DIR/tar"
    run ln -sf /usr/local/bin/gsed     "$XCPKG_CORE_BIN_DIR/sed"
    run ln -sf /usr/local/bin/gawk     "$XCPKG_CORE_BIN_DIR/awk"
    run ln -sf /usr/local/bin/ggrep    "$XCPKG_CORE_BIN_DIR/grep"
    run ln -sf /usr/local/bin/gfind    "$XCPKG_CORE_BIN_DIR/find"
    run ln -sf /usr/local/bin/gbase64  "$XCPKG_CORE_BIN_DIR/base64"
    run ln -sf /usr/local/bin/gunlink  "$XCPKG_CORE_BIN_DIR/unlink"
    run ln -sf /usr/local/bin/ginstall "$XCPKG_CORE_BIN_DIR/install"
    run ln -sf /usr/local/bin/gsha256sum "$XCPKG_CORE_BIN_DIR/sha256sum"

    ##################################################################################

    cat > "$XCPKG_CORE_DIR/env" <<EOF
XCPKG_USE_EXTERNAL_PACKAGE_MANAGER=brew

export ACLOCAL_PATH=/usr/local/share/aclocal
export PATH="$BREW_PACKAGE_EXEFIND_PATH:\$PATH"
EOF
}

# use commands: uname curl tar xz cut
__setup_uppm() {
    unset FETCH_TOOL

    for FETCH_TOOL in curl wget http lynx aria2c axel
    do
        if command -v "$FETCH_TOOL" > /dev/null ; then
            break
        else
            unset FETCH_TOOL
        fi
    done

    if [ -z "$FETCH_TOOL" ] ; then
        error "no any fetch tool[curl, wget, http, lynx, aria2c, axel] found."
        return 1
    else
        unset FETCH_TOOL
    fi

    ##################################################################################

    SETUP_WORKING_DIR="$(mktemp -d)"

    run cd "$SETUP_WORKING_DIR"

    ##################################################################################

    wfetch 'https://raw.githubusercontent.com/leleliu008/uppm/master/latest-release' --output-name=uppm-latest-release

    ##################################################################################

    UPPM_LATEST_RELEASE_TAGNAME="$(cat uppm-latest-release)"
    UPPM_LATEST_RELEASE_VERSION="$(printf '%s\n' "$UPPM_LATEST_RELEASE_TAGNAME" | cut -d+ -f1)"

    case $(sw_vers -productVersion | cut -d. -f1) in
        10) X='10.15' ;;
        11) X='11.0'  ;;
        12) X='12.0'  ;;
        13) X='13.0'  ;;
        *)  X='13.0'  ;;
    esac

    NATIVE_OS_ARCH="$(uname -m)"

    UPPM_LATEST_RELEASE_ARCHIVE_FILENAME="uppm-${UPPM_LATEST_RELEASE_VERSION}-macos${X}-${NATIVE_OS_ARCH}.tar.xz"

    wfetch "https://github.com/leleliu008/uppm/releases/download/${UPPM_LATEST_RELEASE_TAGNAME}/${UPPM_LATEST_RELEASE_ARCHIVE_FILENAME}" --output-name="$UPPM_LATEST_RELEASE_ARCHIVE_FILENAME"

    run tar vxf "$UPPM_LATEST_RELEASE_ARCHIVE_FILENAME" --strip-components=1 --no-same-owner -C "$XCPKG_CORE_DIR"

    ##################################################################################

    # https://curl.se/docs/caextract.html
    wfetch 'https://curl.se/ca/cacert.pem' --output-dir="$SETUP_WORKING_DIR"

    run install -d                         "$XCPKG_CORE_DIR/etc/ssl/certs"
    run cp "$SETUP_WORKING_DIR/cacert.pem" "$XCPKG_CORE_DIR/etc/ssl/certs"

    ##################################################################################

    export SSL_CERT_FILE="$XCPKG_CORE_DIR/etc/ssl/certs/cacert.pem"

    UPPM="$XCPKG_CORE_BIN_DIR/uppm"

    run "$UPPM" env
    run "$UPPM" update

    UPPM_PACKAGE_EXEFIND_PATH=
    UPPM_PACKAGE_ACLOCAL_PATH=

    for item in coreutils findutils gawk gsed grep gtar gzip lzip unzip zip jq yq git curl tree
    do
        run "$UPPM" install "$item"

        unset UPPM_PACKAGE_INSTALLED_DIR
        UPPM_PACKAGE_INSTALLED_DIR="$("$UPPM" info "$item" installed-dir)"

        if [ -d "$UPPM_PACKAGE_INSTALLED_DIR/bin" ] ; then
            UPPM_PACKAGE_EXEFIND_PATH="$UPPM_PACKAGE_EXEFIND_PATH:$UPPM_PACKAGE_INSTALLED_DIR/bin"
        fi

        if [ -d "$UPPM_PACKAGE_INSTALLED_DIR/sbin" ] ; then
            UPPM_PACKAGE_EXEFIND_PATH="$UPPM_PACKAGE_EXEFIND_PATH:$UPPM_PACKAGE_INSTALLED_DIR/sbin"
        fi

        if [ -d "$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal" ] ; then
            UPPM_PACKAGE_ACLOCAL_PATH="$UPPM_PACKAGE_ACLOCAL_PATH:$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal"
        fi
    done

    UPPM_PACKAGE_EXEFIND_PATH="${UPPM_PACKAGE_EXEFIND_PATH#':'}"
    UPPM_PACKAGE_ACLOCAL_PATH="${UPPM_PACKAGE_ACLOCAL_PATH#':'}"

    cat > "$XCPKG_CORE_DIR/env" <<EOF
XCPKG_USE_EXTERNAL_PACKAGE_MANAGER=uppm

export ACLOCAL_PATH="$UPPM_PACKAGE_ACLOCAL_PATH:\$ACLOCAL_PATH"
export PATH="$UPPM_PACKAGE_EXEFIND_PATH:\$PATH"

# https://git-scm.com/book/en/v2/Git-Internals-Environment-Variables
if [ -d "\$HOME/.uppm/installed/git/libexec/git-core" ] ; then
    export GIT_EXEC_PATH="\$HOME/.uppm/installed/git/libexec/git-core"
    export GIT_TEMPLATE_DIR="\$HOME/.uppm/installed/git/share/git-core/templates"
fi
EOF
}

# }}}
##############################################################################
# {{{ xcpkg help

__help() {
    if command -v base64 > /dev/null ; then
        LOGO_BASE64_ENCODED='ICAgICAgICAgICAgICAgIF8gICAgICAgICAKX18gIF9fX19fIF8gX18gfCB8IF9fX18gXyAKXCBc
LyAvIF9ffCAnXyBcfCB8LyAvIF9gIHwKID4gIDwgKF9ffCB8XykgfCAgIDwgKF98IHwKL18vXF9c
X19ffCAuX18vfF98XF9cX18sIHwKICAgICAgICAgfF98ICAgICAgICB8X19fLyAK'

        if command -v lolcat > /dev/null ; then
            printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d | lolcat -S 350
        elif command -v awk > /dev/null ; then
            printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d | lolcat_implemented_in_awk
        else
            printf '%b\n' "${COLOR_BLUE}$(printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d)${COLOR_OFF}"
        fi
    fi

    printf '%b\n' "
A package manager for Xcode to build C/C++/Rust/Go project.${COLOR_OFF}

${COLOR_GREEN}xcpkg <ACTION> [ARGUMENT...]${COLOR_OFF}

${COLOR_GREEN}xcpkg --help${COLOR_OFF}
${COLOR_GREEN}xcpkg -h${COLOR_OFF}
    show help of this command.

${COLOR_GREEN}xcpkg --version${COLOR_OFF}
${COLOR_GREEN}xcpkg -V${COLOR_OFF}
    show version of this command.

${COLOR_GREEN}xcpkg sysinfo${COLOR_OFF}
    show your system information.

${COLOR_GREEN}xcpkg env [-v]${COLOR_OFF}
    show your system and Xcode information.

${COLOR_GREEN}xcpkg xcinfo [ --developer-dir=<DEVELOPER_DIR> --list-supported-platform-names-only]${COLOR_OFF}
    show current active Xcode information.

    when --developer-dir=<DEVELOPER_DIR> option is not specified, if ${COLOR_PURPLE}DEVELOPER_DIR${COLOR_OFF} environment variable is set, xcpkg will use it, otherwize, run command ${COLOR_PURPLE}xcode-select -p${COLOR_OFF} to determine.

${COLOR_GREEN}xcpkg integrate zsh [-v]${COLOR_OFF}
    download a zsh-completion script file to a approprivate location.

${COLOR_GREEN}xcpkg update${COLOR_OFF}
    update all available formula repositories.

${COLOR_GREEN}xcpkg cleanup${COLOR_OFF}
    delete the unused cached files.

${COLOR_GREEN}xcpkg ls-available${COLOR_OFF}
    list all available packages.

${COLOR_GREEN}xcpkg ls-installed${COLOR_OFF}
    list all installed packages.

${COLOR_GREEN}xcpkg ls-outdated${COLOR_OFF}
    list all outdated  packages.

${COLOR_GREEN}xcpkg is-available <PACKAGE-SPEC>${COLOR_OFF}
    check if the given package is available.

${COLOR_GREEN}xcpkg is-installed <PACKAGE-SPEC>${COLOR_OFF}
    check if the given package is installed.

${COLOR_GREEN}xcpkg is-outdated  <PACKAGE-SPEC>${COLOR_OFF}
    check if the given package is outdated.

${COLOR_GREEN}xcpkg search <REGULAR-EXPRESSION-PATTERN>${COLOR_OFF}
    search all available packages whose name matches the given regular expression pattern.

${COLOR_GREEN}xcpkg formula <PACKAGE-NAME> [--path] [--yaml] [--json] [<KEY>]${COLOR_OFF}
    show formula of the given available package.

${COLOR_GREEN}xcpkg receipt <PACKAGE-SPEC> [--path] [--yaml] [--json] [<KEY>]${COLOR_OFF}
    show receipt of the given installed package.

${COLOR_GREEN}xcpkg formula-edit <PACKAGE-NAME> --editor=<EDITOR>${COLOR_OFF}
    edit the formula of the given package.

${COLOR_GREEN}xcpkg formula-repo-init <FORMULA-REPO-NAME> <FORMULA-REPO-URL> [--branch=VALUE --pin/--unpin --enable/--disable]${COLOR_OFF}
    create a new empty formula repository.

${COLOR_GREEN}xcpkg formula-repo-add  <FORMULA-REPO-NAME> <FORMULA-REPO-URL> [--branch=VALUE --pin/--unpin --enable/--disable]${COLOR_OFF}
    create a new empty formula repository then sync with server.

${COLOR_GREEN}xcpkg formula-repo-del  <FORMULA-REPO-NAME>${COLOR_OFF}
    delete the given formula repository.

${COLOR_GREEN}xcpkg formula-repo-sync <FORMULA-REPO-NAME>${COLOR_OFF}
    update the given formula repository.

${COLOR_GREEN}xcpkg formula-repo-info <FORMULA-REPO-NAME>${COLOR_OFF}
    show information of the given formula repository.

${COLOR_GREEN}xcpkg formula-repo-conf <FORMULA-REPO-NAME> [--url=VALUE --branch=VALUE --pin/--unpin --enable/--disable]${COLOR_OFF}
    change the config of the given formula repository.

${COLOR_GREEN}xcpkg formula-repo-list${COLOR_OFF}
    list all available formula repositories.

${COLOR_GREEN}xcpkg tree <PACKAGE-SPEC> [--dirsfirst | -L N]${COLOR_OFF}
    list installed files of the given installed package in a tree-like format.

${COLOR_GREEN}xcpkg pack <PACKAGE-SPEC> [--keep-packing-dir] [-t <zip|tar.gz|tar.xz|tar.lz|tar.bz2>] [-o <OUTPUT-PATH>]${COLOR_OFF}
    pack the given installed package.

    <OUTPUT-PATH> can be either the filepath or directory where the packed archive will be written to. If <OUTPUT-PATH> is an existing directory or ends with slash, then it will be treated as a directory, otherwize, it will be treated as a filepath.

    If -t <OUTPUT-TYPE> option is not given but -o <OUTPUT-PATH> option is given, if <OUTPUT-PATH> is treated as a filepath, then <OUTPUT-PATH> must ends with one of .tar.gz|.tar.xz|.tar.lz|.tar.bz2|.tgz|.txz|.tlz|.tbz2|zip

    If -t <OUTPUT-TYPE> option is not given but -o <OUTPUT-PATH> option is given, if <OUTPUT-PATH> is treated as a directory, then <OUTPUT-TYPE> will be .tar.xz, OUTPUT-PATH will be expanded to <OUTPUT-PATH>/\$XCPKG_HOME/packed/\$PACKAGE_NAME-\$PACKAGE_VERSION-\$TARGET_PLATFORM_NAME-\$TARGET_PLATFORM_ARCH.tar.xz

    If -t <OUTPUT-TYPE> and -o <OUTPUT-PATH> options both are not given, <OUTPUT-TYPE> will be .tar.xz, OUTPUT-PATH will be \$XCPKG_HOME/packed/\$PACKAGE_NAME-\$PACKAGE_VERSION-\$TARGET_PLATFORM_NAME-\$TARGET_PLATFORM_ARCH.tar.xz

${COLOR_GREEN}xcpkg logs <PACKAGE-SPEC>${COLOR_OFF}
    show logs of the given installed package.

${COLOR_GREEN}xcpkg info <PACKAGE-NAME|PACKAGE-SPEC> [--json] [--yaml] [<KEY>]${COLOR_OFF}
    show information of the given package.

${COLOR_GREEN}xcpkg info @all [--json] [--yaml] [--shell]${COLOR_OFF}
    show information of all the available packages.

${COLOR_GREEN}xcpkg fetch <PACKAGE-NAME>${COLOR_OFF}
    download resources of the given package to the local cache.

${COLOR_GREEN}xcpkg depends <PACKAGE-NAME> [-t <dot|box|svg|png>] [-o <OUTPUT-PATH>]${COLOR_OFF}
    show the packages that are depended by the given package.

    <OUTPUT-PATH> can be either the filepath or directory where the file will be written to. If <OUTPUT-PATH> is an existing directory or ends with slash, then it will be treated as a directory, otherwize, it will be treated as a filepath.

    If -t <OUTPUT-TYPE> option is not given but -o <OUTPUT-PATH> option is given, if <OUTPUT-PATH> is treated as a directory, then <OUTPU-TYPE> will be box and <OUTPUT-PATH> will be expanded to <OUTPUT-PATH>/<PACKAGE-NAME>-dependencies.box

    If -t <OUTPUT-TYPE> option is not given but -o <OUTPUT-PATH> option is given, if <OUTPUT-PATH> is treated as a filepath, then <OUTPUT-PATH> must ends with one of .dot|.box|.svg|.png

    If -t <OUTPUT-TYPE> and -o <OUTPUT-PATH> options both are not given, <OUTPU-TYPE> will be box and output to stdout.

${COLOR_GREEN}xcpkg install   <PACKAGE-SPEC>... [--jobs=N -v -vv -q --dry-run --keep-working-dir]${COLOR_OFF}
    install the given packages.

${COLOR_GREEN}xcpkg reinstall <PACKAGE-SPEC>... [--jobs=N -v -vv -q --dry-run --keep-working-dir]${COLOR_OFF}
    reinstall the given packages.

${COLOR_GREEN}xcpkg upgrade   [PACKAGE-SPEC]... [--jobs=N -v -vv -q --dry-run --keep-working-dir]${COLOR_OFF}
    upgrade the given outdated packages.

${COLOR_GREEN}xcpkg upgrade-self${COLOR_OFF}
    upgrade this software.

${COLOR_GREEN}xcpkg uninstall <PACKAGE-SPEC>...${COLOR_OFF}
    uninstall the given packages.

${COLOR_GREEN}xcpkg create-framework <PACKAGE>...${COLOR_OFF}
    create framework for packages.

${COLOR_GREEN}xcpkg gen-url-transform-sample${COLOR_OFF}
    generate url-transform sample.



${COLOR_GREEN}PACKAGE-NAME${COLOR_OFF}
    must match regular expression pattern ^[A-Za-z0-9+-._]{1,50}$

${COLOR_GREEN}PACKAGE-SPEC${COLOR_OFF}
    a formatted srting that has form: <TARGET-PLATFORM-SPEC>/<PACKAGE-NAME>

${COLOR_GREEN}TARGET-PLATFORM-SPEC${COLOR_OFF}
    a formatted srting that has form: <PLATFORM-NAME>/<PLATFORM-VERSION>/<PLATFORM-ARCH>
    indicates which platform would be built for.

${COLOR_GREEN}PLATFORM-NAME${COLOR_OFF}
    'xcpkg xcinfo --list-supported-platform-names-only' command will list the supported platform names.

${COLOR_GREEN}PLATFORM-VERSION${COLOR_OFF}
    the minimum version of platform supported by this package. It usually matches regular expression pattern '[0-9][0-9]?.[0-9][0-9]?', e.g. 10.15, 11.0, 12.0, 12.6, etc.

${COLOR_GREEN}PLATFORM-ARCH${COLOR_OFF}
    indicates which ISA would be built for.
    "
}

# }}}
##############################################################################
# {{{ xcpkg main

main() {
    set -e

    [ -n "$XCPKG_XTRACE" ] && set -x

    [ "$(uname)" = 'Darwin' ] || abort 1 "this software can only be run on macOS."

    unset NATIVE_OS_KIND
    unset NATIVE_OS_TYPE
    unset NATIVE_OS_VERS
    unset NATIVE_OS_ARCH
    unset NATIVE_OS_NCPU

    NATIVE_OS_KIND=darwin
    NATIVE_OS_TYPE=macos
    NATIVE_OS_NAME=MacOSX
    NATIVE_OS_VERS="$(sw_vers -productVersion)"
    NATIVE_OS_ARCH="$(uname -m)"
    NATIVE_OS_NCPU="$(sysctl -n machdep.cpu.thread_count)"
    NATIVE_OS_EUID="$(id -u)"
    NATIVE_OS_EGID="$(id -g)"

    XCPKG="$CURRENT_SCRIPT_FILEPATH"

    XCPKG_VERSION=0.10.1

    XCPKG_OFFICAL_FORMULA_REPO_URL='https://github.com/leleliu008/xcpkg-formula-repository-offical-core'

    XCPKG_UPGRAGE_URL='https://raw.githubusercontent.com/leleliu008/xcpkg/master/xcpkg'

    [ -z "$XCPKG_HOME" ] && {
        if [ -z "$HOME" ] ; then
            abort 1 "HOME environment variable is not set."
        else
            XCPKG_HOME="$HOME/.xcpkg"
        fi
    }

    XCPKG_FORMULA_REPO_ROOT="$XCPKG_HOME/repos.d"

    XCPKG_PACKAGE_INSTALLED_ROOT="$XCPKG_HOME/installed"
    XCPKG_PACKAGE_SYMLINKED_ROOT="$XCPKG_HOME/symlinked"

    XCPKG_DOWNLOADS_DIR="$XCPKG_HOME/downloads"

    XCPKG_BACKUP_DIR="$XCPKG_HOME/backup.d"

    XCPKG_CORE_DIR="$XCPKG_HOME/core"
    XCPKG_CORE_BIN_DIR="$XCPKG_CORE_DIR/bin"

    unset TIMESTAMP_UNIX; TIMESTAMP_UNIX="$(date +%s)"

    case $1 in
        ''|--help|-h)
            __help
            return 0
            ;;
        --version|-V)
            printf '%s\n' "$XCPKG_VERSION"
            return 0
            ;;
        setup)
            shift
            __setup "$@"
            return 0
            ;;
        sysinfo)
            cat <<EOF
sysinfo.ncpu: $NATIVE_OS_NCPU
sysinfo.arch: $NATIVE_OS_ARCH
sysinfo.kind: $NATIVE_OS_KIND
sysinfo.type: $NATIVE_OS_TYPE
sysinfo.vers: $NATIVE_OS_VERS
sysinfo.euid: $NATIVE_OS_EUID
sysinfo.egid: $NATIVE_OS_EGID
EOF
            return 0;
            ;;
        xcinfo)
            shift
            xcinfo "$@"
            return 0;
            ;;
        gen-url-transform-sample)
            shift
            __gen_url_transform_sample "$@"
            return 0
            ;;
    esac

    #########################################################################################

    if [ -z "$CARGO_HOME" ] ; then
        bppend_to_PATH "$HOME/.cargo/bin"
    else
        bppend_to_PATH "$CARGO_HOME/bin"
    fi

    # pip install --user <PKG>
    bppend_to_PATH "$HOME/.local/bin"

    # cpan install to default local location
    bppend_to_PATH "$HOME/perl5/bin"

    #########################################################################################

    unset XCPKG_USE_EXTERNAL_PACKAGE_MANAGER

    unset ACLOCAL_PATH

    #########################################################################################

    if [ -f "$XCPKG_CORE_DIR/env" ] ; then
        .   "$XCPKG_CORE_DIR/env"
    else
        abort 1 "please run ${COLOR_GREEN}$_0 setup${COLOR_OFF} command first, then try again."
    fi

    #########################################################################################

    # https://www.gnu.org/software/automake/manual/html_node/Macro-Search-Path.html
    if [ -z "$ACLOCAL_PATH" ] ; then
        export ACLOCAL_PATH="$XCPKG_CORE_DIR/share/aclocal"
    else
        export ACLOCAL_PATH="$XCPKG_CORE_DIR/share/aclocal:$ACLOCAL_PATH"
    fi

    # https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_default_verify_paths.html
    if [ -f "$XCPKG_CORE_DIR/etc/ssl/certs/cacert.pem" ] ; then
        export SSL_CERT_FILE="$XCPKG_CORE_DIR/etc/ssl/certs/cacert.pem"
    fi

    bppend_to_PATH "$XCPKG_CORE_BIN_DIR"

    #########################################################################################

    case $1 in
        env)
            cat <<EOF
sysinfo.ncpu: $NATIVE_OS_NCPU
sysinfo.arch: $NATIVE_OS_ARCH
sysinfo.kind: $NATIVE_OS_KIND
sysinfo.type: $NATIVE_OS_TYPE
sysinfo.vers: $NATIVE_OS_VERS
sysinfo.euid: $NATIVE_OS_EUID
sysinfo.egid: $NATIVE_OS_EGID

xcpkg.vers : $XCPKG_VERSION
xcpkg.home : $XCPKG_HOME
xcpkg.path : $XCPKG
xcpkg.link : https://github.com/leleliu008/xcpkg
EOF
            if [ "$XCPKG_USE_EXTERNAL_PACKAGE_MANAGER" = brew ] ; then
                run brew --version
                run brew --env
            else
                run uppm env
            fi

            run xcinfo

            if [ "$2" = '-v' ] ; then
                echo "${COLOR_PURPLE}==>${COLOR_OFF} ${COLOR_GREEN}PATH${COLOR_OFF}"
                printf '%s\n' "$PATH" | tr : '\n'
            fi
            ;;

        ls-available) shift; __list_available_packages ;;
        ls-installed) shift; __list_installed_packages ;;
        ls-outdated)  shift; __list__outdated_packages ;;

        is-available) shift; is_package_available "$@" ;;
        is-installed) shift; is_package_installed "$@" ;;
        is-outdated)  shift; is_package__outdated "$@" ;;

        formula) shift; __show_formula_of_the_given_package "$@" ;;
        receipt) shift; __show_receipt_of_the_given_package "$@" ;;

        formula-edit) shift; __edit_formula_of_the_given_package "$@" ;;

        update)            shift; __sync_available_formula_repositories "$@" ;;
        formula-repo-list) shift; __list_available_formula_repositories "$@" ;;
        formula-repo-info) shift; __info_the_given_formula_repository "$@" ;;
        formula-repo-conf) shift; __conf_the_given_formula_repository "$@" ;;
        formula-repo-sync) shift; __sync_the_given_formula_repository "$@" ;;
        formula-repo-init)
            shift

            case $1 in
                offical-*) abort 1 "xcpkg formula repository name that starts with 'offical-' is reserved for xcpkg offical formula repository, please use other name."
            esac

            __create_a_formula_repository "$@"
            ;;
        formula-repo-add)
            shift

            case $1 in
                offical-*) abort 1 "xcpkg formula repository name that starts with 'offical-' is reserved for xcpkg offical formula repository, please use other name."
            esac

            __create_a_formula_repository_then_sync_it "$@"
            ;;
        formula-repo-del)
            shift
            __delete_a_formula_repository "$@"
            ;;

        cleanup) shift; __cleanup ;;

        search)  shift; __search_packages "$*" ;;

          install) shift;   __install_the_given_packages "$@" ;;
        reinstall) shift; __reinstall_the_given_packages "$@" ;;
        uninstall) shift; __uninstall_the_given_packages "$@" ;;

        upgrade)   shift; __upgrade_packages "$@" ;;
        upgrade-self)
            shift
            __upgrade_self "$XCPKG_UPGRAGE_URL" "$@"
            ;;
        integrate)
            shift
            case $1 in
                zsh) shift; __integrate_zsh_completions 'https://raw.githubusercontent.com/leleliu008/xcpkg/master/xcpkg-zsh-completion' "$@" ;;
                *)   abort 1 "xcpkg integrate $1: not support."
            esac
            ;;
        depends)
            shift
            __show_packages_depended_by_the_given_package "$@"
            ;;
        fetch)
            shift
            __fetch_resources_of_the_given_package "$@"
            ;;
        logs) shift; __logs_the_given_installed_package "$@" ;;
        pack) shift; __pack_the_given_installed_package "$@" ;;
        tree) shift; __tree_the_given_installed_package "$@" ;;

        info)
            shift
            __show_information_of_the_given_package "$@"
            ;;
        gen-github-workflows)
            shift
            __gen_github_workflows "$@"
            ;;
        compare-versions)
            shift
            case $1 in
                brew) __compare_versions_with_brew ;;
                ppkg) __compare_versions_with_ppkg ;;
                *)    abort 1 "unrecognized argument: $1"
            esac
            ;;
        *)  abort 1 "unrecognized argument: $1"
    esac
}

main "$@"

# }}}
##############################################################################
# {{{ vim operation
# last line mode :set foldmethod=marker
# command mode zM  fold close all
# command mode zR  fold open all

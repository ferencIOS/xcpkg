#!/bin/sh

# MY represents this software's
MY_VERSION=0.1.0
MY_HOME_PAGE='https://github.com/leleliu008/ipkg'

COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;34m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

msg() {
    printf "%b" "$*"
}

echo() {
    msg "$*\n"
}

info() {
    msg "${COLOR_PURPLE}$*\n${COLOR_OFF}"
}

success() {
    msg "${COLOR_GREEN}[✔] $*\n${COLOR_OFF}"
}

warn() {
    msg "${COLOR_YELLOW}🔥 $*\n${COLOR_OFF}"
}

error() {
    msg "${COLOR_RED}[✘] $*\n${COLOR_OFF}"
}

die() {
    msg "${COLOR_RED}[✘] $*\n${COLOR_OFF}"
    exit 1
}

print_list() {
    for item in $@
    do
        echo "$item"
    done
}

nproc() {
    if command -v nproc > /dev/null ; then
        command nproc
    elif command -v sysctl > /dev/null ; then
        sysctl -n machdep.cpu.thread_count
    elif test -f /proc/cpuinfo ; then
        grep -c processor /proc/cpuinfo
    else
        echo 4
    fi
}

sed_in_place() {
    if command -v gsed > /dev/null ; then
        gsed -i "$1" "$2"
    elif command -v sed  > /dev/null ; then
        sed -i    "$1" "$2" 2> /dev/null || 
        sed -i "" "$1" "$2"
    else
        die "please install sed utility."
    fi
}

format_unix_timestamp() {
   date -jf "%s" "$1" "$2" 2> /dev/null ||
   date -d      "@$1" "$2"
}

getvalue() {
    echo "$1" | cut -d= -f2
}

sha256sum() {
    if command -v openssl > /dev/null ; then
        openssl sha256 "$1" | awk '{print $2}'
    elif command -v sha256sum > /dev/null ; then
        sha256sum "$1" | awk '{print $1}'
    else
        die "please install openssl or GNU CoreUtils."
    fi
}

is_sha256sum_match() {
    [ "$(sha256sum $1)" = "$2" ]
}

die_from_sha256sum_mismatch() {
    die "sha256sum mismatch."
}

fetch_via_curl() {
    info "Fetching $FETCH_URL"
    
    if curl -L -o "$FETCH_OUTPUT_FILE_PATH" "$FETCH_URL" ; then
        success "Fetched $FETCH_URL success."
    else
        die "Fetched $FETCH_URL failed."
    fi
}

fetch_via_wget() {
    info "Fetching $FETCH_URL"
    
    if wget -O "$FETCH_OUTPUT_FILE_PATH" "$FETCH_URL" ; then
        success "Fetched $FETCH_URL success."
    else
        die "Fetched $FETCH_URL failed."
    fi
}

fetch_via_git() {
    info "Fetching $FETCH_URL"
    
    if [ -d "$FETCH_OUTPUT_DIR" ] ; then
        mkdir -p "$FETCH_OUTPUT_DIR"
    fi

    if [ -d "$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME" ] ; then
        if  git -C "$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME" rev-parse 2> /dev/null ; then
            git -C "$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME" pull
        else
            rm -rf "$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME" &&
            git -C "$FETCH_OUTPUT_DIR" clone "$FETCH_URL" "$FETCH_OUTPUT_NAME"
        fi
    else
        git -C "$FETCH_OUTPUT_DIR" clone "$FETCH_URL" "$FETCH_OUTPUT_NAME"
    fi
    
    if [ $? -eq 0 ] ; then
        success "Fetched to $FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME success."
    else
        die "Fetched to $FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME failed."
    fi
}

fetch_archive_via_tools() {
    if command -v curl > /dev/null ; then
        fetch_via_curl
    elif command -v wget > /dev/null ; then
        fetch_via_wget
    else
        die "please install curl or wget."
    fi
}

#fetch <URL> [--output-dir=DIR | --output-name=NAME --sha256=SHA256]
fetch() {
    unset FETCH_URL
    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_NAME
    unset FETCH_OUTPUT_FILE_PATH
    unset FETCH_OUTPUT_FILE_SHA256
    
    FETCH_URL="$1"
    if [ -z "$FETCH_URL" ] ; then
        die "please specify a fetch url."
    fi
    
    shift
    
    while [ -n "$1" ]
    do
        case $1 in
            --sha256=*)
                FETCH_OUTPUT_FILE_SHA256=$(getvalue "$1")
                ;;
            --output-dir=*)
                FETCH_OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                    die "--output-dir argument's value must be not empty."
                fi
                ;;
            --output-name=*)
                FETCH_OUTPUT_NAME=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                    die "--output-name argument's value must be not empty."
                fi
                ;;
        esac
        shift
    done
    
    [ -z "$FETCH_OUTPUT_DIR" ] && FETCH_OUTPUT_DIR="$PWD"
     
    case $FETCH_URL in
        *.git)
            if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                FETCH_OUTPUT_NAME=$(basename "$FETCH_URL" .git)
            fi
            fetch_via_git
            ;;
        *)
            if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                FETCH_OUTPUT_NAME=$(basename "$FETCH_URL")
            fi
             
            FETCH_OUTPUT_FILE_PATH="$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME"
             
            echo 
            info "FETCH_OUTPUT_FILE_PATH   = $FETCH_OUTPUT_FILE_PATH"
            info "FETCH_OUTPUT_FILE_SHA256 = $FETCH_OUTPUT_FILE_SHA256"
             
            if [ -f "$FETCH_OUTPUT_FILE_PATH" ] ; then
                if [ -n "$FETCH_OUTPUT_FILE_SHA256" ] ; then
                    if is_sha256sum_match "$FETCH_OUTPUT_FILE_PATH" "$FETCH_OUTPUT_FILE_SHA256" ; then
                        success "$FETCH_OUTPUT_FILE_PATH is already downloaded."
                        return 0
                    fi
                fi
                rm -f "$FETCH_OUTPUT_FILE_PATH"
            fi

            fetch_archive_via_tools
            
            if [ -n "$FETCH_OUTPUT_FILE_SHA256" ] ; then
                if ! is_sha256sum_match "$FETCH_OUTPUT_FILE_PATH" "$FETCH_OUTPUT_FILE_SHA256" ; then
                    die_from_sha256sum_mismatch
                fi
            fi
    esac
}

fetch_config_url() {
    echo "http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.$1;hb=HEAD"
}

fetch_config_xx() {
    if [ -z "$2" ] ; then
        fetch $(fetch_config_url $1) --output-name=config.$1
    else
        fetch $(fetch_config_url $1) --output-name=config.$1 --output-dir=$2
    fi
}

fetch_config_sub() {
    fetch_config_xx sub $1
}

fetch_config_guess() {
    fetch_config_xx guess $1
}

fetch_a_package() {
    load_formula_of_a_package "$1"
    fetch "$url" --sha256="$sha256" --output-dir="$DIR_DOWNLOAD"
}

unzip() {
    info "uncompressing $1"
    
    if command unzip "$1" ; then
        success "uncompressed in $2"
    else
        die "uncompress $1 failed!"
    fi
}

untar() {
    info "uncompressing $1"
    
    if tar xf "$1" --strip-components 1 ; then
        success "uncompressed in $2"
    else
        die "uncompress $1 failed!"
    fi
}

uncompress() {
    case $1 in
        *.zip)
            unzip "$1" "$2";;
        *.xz|*.gz|*.bz2|*.tgz|*.txz)
            untar "$1" "$2";;
        *)  die "$1 : extension isn't recognized. the supported extensions are .zip .xz .gz .bz2 .tgz .txz";;
    esac
}

is_exist_and_executable() {
    [ -f "$1" ] || die "$1 is not exist."
    [ -x "$1" ] || die "$1 is not executable."
}

is_package_available() {
    [ -z "$1" ] && die_from_package_is_not_specified
    [ -f "$DIR_FORMULA/$1.sh" ]
}

die_from_package_is_not_specified() {
    die "please provide a package name."
}

die_from_packages_is_not_specified() {
    die "please provide at least one package name."
}

die_from_package_is_not_available() {
    die "$1 is not available."
}

die_from_package_is_not_installed() {
    die "$1 is not installed."
}

list_available_packages() {
    unset SILENT

    case $# in
        0)  ;;
        1)  if [ "$1" = '-q' ] ; then
                SILENT=true
            else
                die "list available command only accept -q argument."
            fi
            ;;
        *)  die "list available command only accept -q argument."
    esac

    [ -d "$DIR_FORMULA" ] || {
        if [ "$SILENT" = 'true' ] ; then
            update_formula_repository >/dev/null 2>&1
        else
            update_formula_repository
        fi
    }
    
    if [ "$SILENT" = 'true' ] ; then
        cd "$DIR_FORMULA" 2>/dev/null || exit 1
    else
        cd "$DIR_FORMULA" || exit 1
    fi

    for item in $(ls *.sh | sed 's/\.sh//g')
    do
        echo "$item"
    done
}

list_installed_packages() {
    cd "$DIR_PKG" 2>/dev/null || exit 1

    for packageName in *
    do
        if is_package_installed "$packageName" ; then
            echo "$packageName"
        fi
    done
}

list_outdated_packages() {
    cd "$DIR_PKG" 2>/dev/null || exit 1

    for packageName in *
    do
        is_package_available "$packageName" || continue
        is_package_installed "$packageName" || continue
        if is_package_outdated "$packageName" ; then
            echo "$packageName"
        fi
    done
}

tree_a_installed_package() {
    DIR_INSTALL_PACKAGE="$DIR_PKG/$1"
    
    [ -d "$DIR_INSTALL_PACKAGE" ] || die_from_package_is_not_installed "$1"
    
    shift
    
    if command -v tree > /dev/null ; then    
        tree $@ --dirsfirst "$DIR_INSTALL_PACKAGE"
    else
        die "please install tree utility."
    fi
}

uninstall_packages() {
    [ -z "$1" ] && die_from_packages_is_not_specified
    
    for packageName in $@
    do
        uninstall_a_package "$packageName"
    done
}

uninstall_a_package() {
    [ -d "$DIR_PKG/$1" ] || die_from_package_is_not_installed "$1"
    info "uninstalling $1..." &&
    rm -rf "$DIR_PKG/$1" &&
    success "$1 uninstalled."
}

cat_formula_of_a_package() {
    [ -z "$1" ] && die_from_package_is_not_specified
    [ -z "$2" ] || warn "cat command accept only one parameter."
    
    is_package_available "$1" || die_from_package_is_not_available "$1"
    
    if command -v bat > /dev/null ; then
        bat "$DIR_FORMULA/$1.sh"
    else
        cat "$DIR_FORMULA/$1.sh"
        echo
        warn "if you want to have a better experience, I strongly recommend you install ${COLOR_RED}bat${COLOR_OFF} on your os. For more details, see ${COLOR_RED}https://github.com/sharkdp/bat${COLOR_OFF}"
    fi    
}

edit_formula_of_a_package() {
    [ -z "$1" ] && die_from_package_is_not_specified
    [ -z "$2" ] || warn "edit command accept only one parameter."
    
    is_package_available "$1" || die_from_package_is_not_available "$1"
   
    [ -z "$EDITOR" ] &&
    EDITOR=$(command -v vi) ||
    EDITOR=$(command -v vim) ||
    EDITOR=$(command -v nvim) ||
    EDITOR=$(command -v open) ||
    die "please config EDITOR environment." 

    "$EDITOR" "$DIR_FORMULA/$1.sh"
}

update_formula_repository() {
    info "Updating formula repository."

    FETCH_URL="$MY_FORMULA_REPO_URL"
    FETCH_OUTPUT_DIR="$MY_HOME_DIR"
    FETCH_OUTPUT_NAME=formula
    fetch_via_git
}

upgrade_packages() {
    [ -z "$TARGET_PACKAGE_LIST" ] && TARGET_PACKAGE_LIST=$(list_outdated_packages)
    [ -z "$TARGET_PACKAGE_LIST" ] && return 0

    reinstall_packages
}

reinstall_packages() {
    [ -z "$TARGET_PACKAGE_LIST" ] && die_from_packages_is_not_specified
     
    for packageName in $TARGET_PACKAGE_LIST
    do
        is_package_available "$packageName" || die_from_package_is_not_available "$packageName"
        is_package_installed "$packageName" || die_from_package_is_not_installed "$packageName"
    done
    
    for packageName in $TARGET_PACKAGE_LIST
    do
        {
            [ -d "$DIR_BACKUP" ] || mkdir -p "$DIR_BACKUP"
        } &&
        mv "$DIR_PKG/$packageName" "$DIR_BACKUP/$packageName" &&
        install_a_package "$packageName" &&
        rm -rf "$DIR_BACKUP/$packageName"
    done
}

cleanup() {
    success "Done."
}

search_packages() {
    [ -z "$1" ] && die "please specify a keyword."
    [ -d "$DIR_FORMULA" ] || update_formula_repository
    
    cd "$DIR_FORMULA" || exit 1

    for item in $(ls -1 *.sh | sed 's/\.sh//g')
    do
        echo "$item" | grep "$*" || true
    done
}

open_homepage_of_a_package() {
    if [ -z "$1" ] ; then
        homepage="$MY_HOME_PAGE"
    else
        load_formula_of_a_package "$1"
    fi
    
    if command -v open > /dev/null ; then
        open "$homepage"
    else
        echo "$homepage"
    fi
}

print_prefix_of_a_package() {
    if [ -z "$1" ] ; then
        echo "$MY_HOME_DIR"
    else
        if is_package_installed "$1" ; then
            echo "$DIR_PKG/$1"
        else
            die_from_package_is_not_installed "$1"
        fi
    fi
}

logs_a_package() {
    [ -z "$1" ] && die_from_package_is_not_specified
    is_package_installed "$1" || die_from_package_is_not_installed "$1"
    
    FILE_PATH_LOGS="$DIR_PKG/$1/logs"
    
    if [ -f "$FILE_PATH_LOGS" ] ; then
        success "$FILE_PATH_LOGS ===>"
        cat "$FILE_PATH_LOGS"
    else
        warn "no logs."
    fi
}

pack_a_package() {
    [ -z "$1" ] && die_from_package_is_not_specified
    is_package_installed "$1" || die_from_package_is_not_installed "$1"
    
    [ -d "$DIR_BOTTLE" ] || mkdir -p "$DIR_BOTTLE"
    
    if command -v tar > /dev/null ; then
        if command -v gzip > /dev/null ; then
            FILE_PATH_BOTTLE="$DIR_BOTTLE/$1-bottle.tar.gz"
            info "packing $1..." &&
            tar zvcf "$FILE_PATH_BOTTLE" -C "$DIR_PKG" "$1"
        elif command -v xz > /dev/null ; then
            FILE_PATH_BOTTLE="$DIR_BOTTLE/$1-bottle.tar.xz"
            info "packing $1..." &&
            tar zvcf "$FILE_PATH_BOTTLE" -C "$DIR_PKG" "$1"
        elif command -v bzip2 > /dev/null ; then
            FILE_PATH_BOTTLE="$DIR_BOTTLE/$1-bottle.tar.bz2"
            info "packing $1..." &&
            tar zvcf "$FILE_PATH_BOTTLE" -C "$DIR_PKG" "$1"
        fi
    elif command -v zip > /dev/null ; then
        FILE_PATH_BOTTLE="$DIR_BOTTLE/$1-bottle.zip"
        cd "$DIR_PKG" &&
        info "packing $1..." &&
        zip -r "$FILE_PATH_BOTTLE" "$1"
    fi
    
    if [ $? -eq 0 ] ; then
        success "packed success. $FILE_PATH_BOTTLE"
    else
        die "pack $1 failed."
    fi
}

get_direct_dependencies_of_a_package() {
    grep '^dependencies=".*"' "$DIR_FORMULA/$1.sh" | sed 's/dependencies="\(.*\)"/\1/'
}

get_dependencies_of_a_package() {
    for dependencyPkgName in $(get_direct_dependencies_of_a_package "$1")
    do
        is_package_available "$dependencyPkgName" || die_from_package_is_not_available "$dependencyPkgName"
        DEPENDENCY_PACKAGE_LIST="$dependencyPkgName $DEPENDENCY_PACKAGE_LIST"
        get_dependencies_of_a_package "$dependencyPkgName"
    done
}

install_packages() {
    [ -z "$TARGET_PACKAGE_LIST" ] && die_from_packages_is_not_specified
    
    for TARGET_PACKAGE in $TARGET_PACKAGE_LIST
    do
        get_dependencies_of_a_package "$TARGET_PACKAGE"
    done
    
    for TARGET_PACKAGE in $DEPENDENCY_PACKAGE_LIST $TARGET_PACKAGE_LIST
    do
        if is_target_package_platform_arch_installed ; then
            success "$TARGET_PACKAGE is already installed."
        else
            install_a_package "$TARGET_PACKAGE"
        fi
    done
}

install_a_package() {
    fetch_a_package "$1"
    
    is_sha256sum_match "$FETCH_OUTPUT_FILE_PATH" "$sha256" || die_from_sha256sum_mismatch 
    
    if DIR_SRC=$(mktemp -d) ; then
        cd "$DIR_SRC" || exit 1
    else
        die "create DIR_SRC directory failed."
    fi
     
    case $FETCH_URL in
        *.git)  cp -r $FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME/* "$DIR_SRC" ;;
        *)      uncompress "$FETCH_OUTPUT_FILE_PATH" "$DIR_SRC"
    esac
    
    if command -v prepare > /dev/null ; then
        prepare || die "install $1 failed! you can go to $DIR_SRC to see see."
    fi
     
    if install_a_package_for_real_device_and_simulator "$1" ; then
        install_a_package_success "$1"
        rm -rf "$DIR_SRC"
    else
        die "install $1 failed! you can go to $DIR_SRC to see see."
    fi
}

install_a_package_for_real_device_and_simulator() {
    unset FOR_SIMULATOR
    
    for TARGET_ARCH in $TARGET_ARCH_LIST
    do
        install_a_package_for_one_target_arch "$1"
    done
     
    if [ "$HAS_SIMULATOR" = 'true' ] ; then
        FOR_SIMULATOR=true 
        
        for TARGET_ARCH in i386 x86_64
        do
            install_a_package_for_one_target_arch "$1"
        done
    fi
}

install_a_package_for_one_target_arch() {
    make_env "$1" || die "install $1/$TARGET_PLATFORM/$TARGET_ARCH failed! you can go to $DIR_SRC to see see."
     
    [ -d "$DIR_INSTALL_PREFIX" ] && rm -rf "$DIR_INSTALL_PREFIX"
    
    if build ; then
        cat > "$DIR_INSTALL_PREFIX/installed" <<EOF
installed_time=$TIMESTAMP_UNIX
installed_pkg_version=$version
installed_min_version=$TARGET_PLATFORM_MIN_VERSION
installed_xc_version='$XCODE_VERSION'
EOF
    else
        die "install $1/$TARGET_PLATFORM/$TARGET_ARCH failed! you can go to $DIR_SRC to see see."
    fi
}

install_a_package_success() {
    [ -d "$DIR_INSTALL_PACKAGE" ] || die "$1 build failed. installed nothing."
    
    success "$1 installed success. in $DIR_INSTALL_PACKAGE directory."
    
    if command -v tree > /dev/null ; then
        tree -L 4 --dirsfirst "$DIR_INSTALL_PACKAGE"
    fi
}

info_packages() {
    unset INFO
    unset TARGET_PACKAGE
    unset TARGET_PACKAGE_LIST

    if [ -z "$1" ] ; then
        [ -d "$DIR_FORMULA" ] || update_formula_repository
        cd "$DIR_FORMULA" || exit 1
        TARGET_PACKAGE_LIST=$(ls *.sh | sed 's/\.sh//g')
    else
        TARGET_PACKAGE_LIST=$@
    fi

    for TARGET_PACKAGE in $TARGET_PACKAGE_LIST
    do
        if [ "$INFO" = 'true' ] ; then
            echo "============================================================"
        else
            INFO=true
        fi
        info_a_package "$TARGET_PACKAGE"
    done
}

info_a_package() {
    load_formula_of_a_package "$1"
    
    echo "name      : $1"
    echo "summary   : $summary"
    echo "homepage  : $homepage"
    echo "available : $version"
    
    [ -z "$dependencies" ] || {
        msg "depend_on :"
        unset DEPENDENCIES
        for dependencyPkgName in $dependencies
        do
            if [ -z "$DEPENDENCIES" ] ; then
                DEPENDENCIES=true
                msg " "
            else
                msg "            "
            fi

            if is_package_installed "$dependencyPkgName" ; then
                echo "$dependencyPkgName ${COLOR_GREEN}✔${COLOR_OFF}"
            else
                echo "$dependencyPkgName ${COLOR_RED}✘${COLOR_OFF}"
            fi
        done
    }
     
    if is_package_installed "$1" ; then
        for PLATFORM in $(list_support_platforms)
        do
            [ -d "$DIR_PKG/$1/$PLATFORM" ] || continue
            for ARCH in $(ls "$DIR_PKG/$1/$PLATFORM")
            do
                is_package_platform_arch_installed "$1" "$PLATFORM" "$ARCH" || continue
                load_installed_info_of_a_package "$1" "$PLATFORM" "$ARCH"
                echo
                echo "installed ${COLOR_PURPLE}==>${COLOR_OFF} $(du -sh "$DIR_PKG/$1/$PLATFORM/$ARCH" | awk '{print $2, $1}')"
                echo "install_time: $(format_unix_timestamp $installed_time '+%Y/%m/%d %H:%M:%S')"
                echo "pkg_version : $installed_pkg_version"
                echo "min_version : $installed_min_version"
                echo "using xcode : $installed_xc_version"
            done
        done
    else
        echo "installed : ${COLOR_RED}✘${COLOR_OFF}"
    fi
}

load_formula_of_a_package() {
    is_package_available "$1" || die_from_package_is_not_available "$1"

    unset -f prepare
    unset -f build
    unset url
    unset sha256
    unset version
    unset summary
    unset homepage
    unset dependencies
    
    FORMULA_FILE_PATH="$DIR_FORMULA/$1.sh"
     
    . "$FORMULA_FILE_PATH" || die "$FORMULA_FILE_PATH is broken."
    
    [ -z "$summary" ]  && die "summary variable must be specified in $FORMULA_FILE_PATH"
    [ -z "$homepage" ] && die "homepage variable must be specified in $FORMULA_FILE_PATH"
    [ -z "$sha256" ]   && die "sha256 variable must be specified in $FORMULA_FILE_PATH"
    [ -z "$url" ]      && die "url variable must be specified in $FORMULA_FILE_PATH"
    [ -z "$version" ]  && version="$(basename "$url" | awk '{str = tolower($0); gsub(".tar.xz", "", str); gsub(".tar.gz", "", str); gsub(".tar.bz2", "", str); gsub(".tgz", "", str); gsub(".txz", "", str); gsub(".zip", "", str); print(str)}' | awk -F- '{print $NF}')"
    [ -z "$version" ]  && die "version can't be parsed in $FORMULA_FILE_PATH"
}

load_installed_info_of_a_package() {
    unset installed_time
    unset installed_pkg_version
    unset installed_min_version
    unset installed_xc_version
     
    . "$DIR_PKG/$1/$2/$3/installed"
}

########################################################################

gen_system2_call() {
    if [ -z "$1" ] ; then
        SYSTEM2_CALL_DIR="$PWD"
    else
        SYSTEM2_CALL_DIR="$1"
    fi

    cat > "$SYSTEM2_CALL_DIR/system2.c" <<EOF
#ifndef SYSTEM2_C
#define SYSTEM2_C
#include <stdlib.h>
#include <unistd.h>
#include <spawn.h>
#include <sys/wait.h>

extern char **environ;

int system2(char *cmd) {
  char const *argv[] = {"sh", "-c", cmd, NULL};

  pid_t pid;
  int status;
  status = posix_spawn(&pid, "/bin/sh", NULL, NULL, argv, environ);
  if (0 == status) {
      return waitpid(pid, &status, 0);
  }
  return status;
}
#endif
EOF
}

die_from_platform_is_not_specified() {
    die "please provide a platform."
}

die_from_arch_is_not_specified() {
    die "please provide a arch."
}

is_package_installed() {
    [ -z "$1" ] && die_from_package_is_not_specified
    [ -d "$DIR_PKG/$1" ] || return 1
    
    for PLATFORM in $(list_support_platforms)
    do
        is_package_platform_installed "$1" "$PLATFORM" && return 0
    done
    
    return 1
}

is_package_platform_installed() {
    [ -z "$1" ] && die_from_package_is_not_specified
    [ -z "$2" ] && die_from_platform_is_not_specified
    [ -d "$DIR_PKG/$1/$2" ] || return 1
    
    for ARCH in $(ls $DIR_PKG/$1/$2)
    do
        is_package_platform_arch_installed "$1" "$2" "$ARCH" && return 0
    done

    return 1
}

is_package_platform_arch_installed() {
    [ -z "$1" ] && die_from_package_is_not_specified
    [ -z "$2" ] && die_from_platform_is_not_specified
    [ -z "$3" ] && die_from_arch_is_not_specified
    [ -d "$DIR_PKG/$1/$2/$3" ] &&
    [ -f "$DIR_PKG/$1/$2/$3/installed" ]
}

is_package_outdated() {
    [ -z "$1" ] && die_from_package_is_not_specified
    [ -z "$2" ] || warn "outdated? command accept only one parameter."
    
    is_package_available "$1" || die_from_package_is_not_available "$1"
    is_package_installed "$1" || die_from_package_is_not_installed "$1"
    
    load_formula_of_a_package "$1"
        
    for PLATFORM in $(list_support_platforms)
    do
        [ -d "$DIR_PKG/$1/$PLATFORM" ] || continue
        for ARCH in $(ls "$DIR_PKG/$1/$PLATFORM")
        do
            is_package_platform_arch_installed "$1" "$PLATFORM" "$ARCH" || continue
            load_installed_info_of_a_package "$1" "$PLATFORM" "$ARCH"
            [ "$version" = "$installed_pkg_version" ] || return 0
        done
    done
    return 1
}

is_target_package_platform_arch_installed() {
    TARGET_PLATFORM=$(get_target_platform_by_device false)
    for TARGET_ARCH in $TARGET_ARCH_LIST
    do
        is_package_platform_arch_installed "$TARGET_PACKAGE" "$TARGET_PLATFORM" "$TARGET_ARCH" || return 1
    done
    
    [ "$HAS_SIMULATOR" = 'true' ] && {
        TARGET_PLATFORM=$(get_target_platform_by_device true)
        for TARGET_ARCH in i386 x86_64
        do
            is_package_platform_arch_installed "$TARGET_PACKAGE" "$TARGET_PLATFORM" "$TARGET_ARCH" || return 1
        done
    }
}

check_DEVELOPER_DIR() {
    DEVELOPER_DIR="$(xcode-select -p)"
    [ -z "$DEVELOPER_DIR" ] && die "please set DEVELOPER_DIR environment variable, then try again."
    [ -d "$DEVELOPER_DIR" ] || die "$DEVELOPER_DIR directory is not exist."
    XCODE_VERSION=$(system_profiler SPDeveloperToolsDataType | grep Version | cut -d: -f2 | sed 's/^ //g')
}

list_support_devices() {
    case $# in
        0)  echo "tv mac watch phone";;
        1)  if [ "$1" = '--table' ] ; then
                cat <<EOF
┌────────┬───────────┬───────────────────────────┐
│ device │ platform  │ arch                      │
│        │           │                           │
│   tv   │ AppleTVOS │ arm64                     │
│  watch │ WatchOS   │ arm64_32 armv7k           │
│  phone │ iPhoneOS  │ armv7 armv7s arm64 arm64e │
│   mac  │ MacOSX    │ x86_64                    │
│        │ *Simulator│ x86_64 i386               │
└────────┴───────────┴───────────────────────────┘
EOF
            else
                die "list devices command only accept --table argument."
            fi
            ;;
        *)  die "list devices command only accept --table argument."
    esac
}

list_support_platforms() {
    #ls "$DEVELOPER_DIR/Platforms" | sed 's/.platform//g'
    print_list AppleTVOS AppleTVSimulator MacOSX iPhoneOS iPhoneSimulator WatchOS WatchSimulator
}

list_support_devices_archs() {
    if [ -z "$1" ] ; then
        for DEVICE in $(list_support_devices)
        do
            printf "%-5s : $(list_support_devices_archs "$DEVICE")\n" "$DEVICE"
        done
    else
        case $1 in
            phone)  echo "armv7 armv7s arm64 arm64e";;
            watch)  echo "arm64_32 armv7k";;
            tv)     echo "arm64";;
            mac)    echo "x86_64";;
            *)      die "$1 : device isn't recognized."
        esac
    fi
}

list_support_devices_versions() {
    if [ -z "$1" ] ; then
        for DEVICE in $(list_support_devices)
        do
            printf "%-5s : $(list_support_devices_versions "$DEVICE")\n" "$DEVICE"
        done
    else
        case $1 in
            phone)  echo "8.0 8.1 8.2 8.3 8.4 9.0 9.1 9.2 9.3 10.0 10.1 10.2 10.3 11.0 11.1 11.2 11.3 11.4 12.0 12.1 12.2 12.3 12.4 13.0 13.1 13.2 13.3 13.4 13.5";;
            watch)  echo "2.0 2.1 2.2 3.0 3.1 3.2 4.0 4.1 4.2 4.3 5.0 5.1 5.2 5.3 6.0 6.1 6.2";;
            tv)     echo "9.0 9.1 9.2 10.0 10.1 10.2 11.0 11.1 11.2 11.3 11.4 12.0 12.1 12.3 12.4 13.0 13.1 13.2 13.3";;
            mac)    echo "10.6 10.7 10.8 10.9 10.10 10.11 10.12 10.13 10.14 10.15";;
            *)      echo "$1 : device isn't recognized."
        esac
    fi
}

get_support_device_min_version() {
    if [ -z "$1" ] ; then
        for DEVICE in $(list_support_devices)
        do
            printf "%-5s : %s\n" "$DEVICE" $(get_support_device_min_version "$DEVICE")
        done
    else
        list_support_devices_versions "$1" | awk '{print $1}'
    fi
}

get_target_platform_by_device() {
    if [ "$1" = 'true' ] ; then
        case $TARGET_DEVICE in
            phone) echo iPhoneSimulator;;
            watch) echo WatchSimulator;;
            tv)    echo AppleTVSimulator;;
            mac)   die "mac no simulator";;
            *)     die "device must be one of tv|watch|phone|mac";;
        esac
    else 
        case $TARGET_DEVICE in
            phone) echo iPhoneOS;;
            watch) echo WatchOS;;
            tv)    echo AppleTVOS;;
            mac)   echo MacOSX;;
            *)     die "device must be one of tv|watch|phone|mac";;
        esac
    fi
}

make_env() {
    is_package_available "$1" || die_from_package_is_not_available "$1"
    
    TARGET_PLATFORM=$(get_target_platform_by_device "$FOR_SIMULATOR")
    
    if [ 'arm64' = "$TARGET_ARCH" ] ; then
        TARGET_HOST='arm-ios-darwin'
    else
        TARGET_HOST="${TARGET_ARCH}-ios-darwin"
    fi
     
    export TOOLCHAIN_DIR="$DEVELOPER_DIR/Toolchains/XcodeDefault.xctoolchain/usr/bin"
    export PATH=$TOOLCHAIN_DIR:$PATH
    export SYSROOT="$DEVELOPER_DIR/Platforms/${TARGET_PLATFORM}.platform/Developer/SDKs/${TARGET_PLATFORM}.sdk"
     
    DIR_INSTALL_PACKAGE="$DIR_PKG/$1"
    DIR_INSTALL_PREFIX="$DIR_INSTALL_PACKAGE/$TARGET_PLATFORM/$TARGET_ARCH"
    [ -z "$DIR_SRC" ] || DIR_BUILD="$DIR_SRC/$TIMESTAMP_UNIX/$TARGET_PLATFORM/$TARGET_ARCH"
    
    info "-------------------------------------------------------"
    info "  TARGET_PACKAGE = $1"
    info " TARGET_PLATFORM = $TARGET_PLATFORM"
    info "     TARGET_ARCH = $TARGET_ARCH"
    info "     TARGET_HOST = $TARGET_HOST"
    info "    DEPENDENCIES = $(get_direct_dependencies_of_a_package "$1")"
    info "   DEVELOPER_DIR = $DEVELOPER_DIR"
    info "   TOOLCHAIN_DIR = $TOOLCHAIN_DIR"

    CC="${TOOLCHAIN_DIR}/clang"
    is_exist_and_executable "$CC" && export CC="$CC"
    info "              CC = $CC"
    
    CXX="${TOOLCHAIN_DIR}/clang++"
    is_exist_and_executable "$CXX" && export CXX="$CXX"
    info "             CXX = $CXX"
    
    export CPP="$CC -E"
    info "             CPP = $CPP"
    
    AR="${TOOLCHAIN_DIR}/ar"
    is_exist_and_executable "$AR" && export AR="$AR"
    info "              AR = $AR"
    
    AS="${TOOLCHAIN_DIR}/as"
    is_exist_and_executable "$AS" && export AS="$AS"
    info "              AS = $AS"
    
    LD="${TOOLCHAIN_DIR}/ld"
    is_exist_and_executable "$LD" && export LD="$LD"
    info "              LD = $LD"
    
    NM="${TOOLCHAIN_DIR}/nm"
    is_exist_and_executable "$NM" && export NM="$NM"
    info "              NM = $NM"
     
    RANLIB="${TOOLCHAIN_DIR}/ranlib"
    is_exist_and_executable "$RANLIB" && export RANLIB="$RANLIB"
    info "          RANLIB = $RANLIB"
     
    STRIP="${TOOLCHAIN_DIR}/strip"
    is_exist_and_executable "$STRIP" && export STRIP="$STRIP"
    info "           STRIP = $STRIP"
    
    platformLower="$(printf "$TARGET_PLATFORM" | awk '{print(tolower($0))}')"
    CFLAGS="-arch $TARGET_ARCH -isysroot $SYSROOT -m${platformLower}-version-min=$TARGET_PLATFORM_MIN_VERSION -Os -pipe -Qunused-arguments"

    [ "$VERBOSE" = 'true' ] && {
        export CFLAGS="$CFLAGS -v"
        export PKG_CONFIG_DEBUG_SPEW=set
    }
    
    export CFLAGS="$CFLAGS"
    export CXXFLAGS="$CFLAGS"
    
    CPPFLAGS="-isysroot $SYSROOT"
    
    case $TARGET_ARCH in
        armv7*)
            CPPFLAGS="$CPPFLAGS -D__arm__"
            ;;
        arm64*)
            CPPFLAGS="$CPPFLAGS -D__arm64__"
            ;;
        i386)
            CPPFLAGS="$CPPFLAGS -D__i386__"
            ;;
        x86_64)
            CPPFLAGS="$CPPFLAGS -D__x86_64__"
            ;;
    esac
    
    LDFLAGS="-arch $TARGET_ARCH -isysroot $SYSROOT"
    PKG_CONFIG_PATH=''
     
    for item in $DEPENDENCY_PACKAGE_LIST
    do
        item2=$(printf "$item" | tr '-' '_')

        ITEM_DIR_INSTALL_PREFIX="$DIR_PKG/$item/$TARGET_PLATFORM/$TARGET_ARCH"
        ITEM_DIR_INCLUDE="$ITEM_DIR_INSTALL_PREFIX/include"
        ITEM_DIR_LIB="$ITEM_DIR_INSTALL_PREFIX/lib"

        eval "${item2}_DIR_INSTALL_PREFIX='$ITEM_DIR_INSTALL_PREFIX'"
        eval "${item2}_DIR_INCLUDE='$ITEM_DIR_INCLUDE'"
        eval "${item2}_DIR_LIB='$ITEM_DIR_LIB'"
        
        CPPFLAGS="-I$ITEM_DIR_INCLUDE $CPPFLAGS"
        LDFLAGS="-L$ITEM_DIR_LIB $LDFLAGS"
        PKG_CONFIG_PATH="$PKG_CONFIG_PATH:$ITEM_DIR_LIB/pkgconfig"
    done
    
    export CPPFLAGS="$CPPFLAGS -Qunused-arguments"
    export LDFLAGS="$LDFLAGS"
    export PKG_CONFIG_PATH="$PKG_CONFIG_PATH"
    
    info "        CFLAGS   = $CFLAGS"
    info "        CXXFLAGS = $CXXFLAGS"
    info "        CPPFLAGS = $CPPFLAGS"
    info "        LDFLAGS  = $LDFLAGS"
    info "        SYSROOT  = $SYSROOT"
    info "       DIR_SRC   = $DIR_SRC"
    info "       DIR_BUILD = $DIR_BUILD"
    info "DIR_INSTALL_PACKAGE = $DIR_INSTALL_PACKAGE"
    info "DIR_INSTALL_PREFIX  = $DIR_INSTALL_PREFIX"
    info "PKG_CONFIG_PATH = $PKG_CONFIG_PATH"
     
    [ -z "$DIR_BUILD" ] || {
        CMAKE_TOOLCHAIN_FILE="$DIR_BUILD/toolchain.cmake"
        
        info "CMAKE_TOOLCHAIN_FILE =$CMAKE_TOOLCHAIN_FILE"
        info "-------------------------------------------------------"
        
        mkdir -p "$DIR_BUILD"

        cat > "$CMAKE_TOOLCHAIN_FILE" <<EOF
set(CMAKE_SYSTEM_NAME Darwin)
set(CMAKE_SYSTEM_PROCESSOR $TARGET_ARCH)

set(CMAKE_ASM_COMPILER $AS)
set(CMAKE_ASM_FLAGS "-arch $TARGET_ARCH")

set(CMAKE_C_COMPILER "$CC")
set(CMAKE_C_FLAGS "$CFLAGS $CPPFLAGS")

set(CMAKE_CXX_COMPILER "$CXX")
set(CMAKE_CXX_FLAGS "$CXXFLAGS $CPPFLAGS")

set(CMAKE_AR "$AR")
set(CMAKE_RANLIB "$RANLIB")

set(CMAKE_NM "$NM")
set(CMAKE_STRIP "$STRIP")

set(CMAKE_OSX_SYSROOT "$SYSROOT")

set(BUILD_SHARED_LIBS OFF)
set(CMAKE_BUILD_TYPE Release)

set(CMAKE_INSTALL_PREFIX "$DIR_INSTALL_PREFIX")
EOF
    }
}

create_framework_for_packages() {
    [ -z "$1" ] && die_from_packages_is_not_specified
    
    for TARGET_PACKAGE in $@
    do
        create_framework_for_a_package "$TARGET_PACKAGE"
    done
}

create_framework_for_a_package() {
    is_package_installed "$1" || die_from_package_is_not_installed "$1"

    DIR_INSTALL_PACKAGE="$DIR_FORMULA/$TARGET_PACKAGE"
    unset -f create_framework
    load_formula_of_a_package "$1"
    
    if command -v create_framework > /dev/null ; then
        create_framework
    else
        die "not provide create_framework function in formula $DIR_FORMULA/$1.sh"
    fi
}

help() {
    cat << EOF
Usage: ipkg [COMMAND [ARGUMENT...]]
COMMAND:
    help | --help | -h     --show help information.
    version | --version -V --print version of ipkg and Xcode.
    
    list devices           --list the supported devices.
    list versions          --list the supported versions of devices.
    list platforms         --list the supported platforms.
    list available         --list the available packages.
    list installed         --list the installed packages.
    list outdated          --list the outdated packages.

    is available PACKAGE  --is PACKAGE available?
    is installed PACKAGE  --is PACKAGE installed?
    is outdated  PACKAGE  --is PACKAGE outdated?
    
    search KEYWORD         --search packages.
    
    cat  PACKAGE          --show the formula source code of a package.
    edit PACKAGE          --edit the formula source code of a package.
    tree PACKAGE          --list contents of a installed package directory in a tree-like format.
    pack PACKAGE          --pack a installed package.
    fetch PACKAGE         --download formula resources of a package to the cache.
    prefix PACKAGE        --show the installation direcotory of a formula or the ipkg home.
    homepage PACKAGE      --visit the homepage of a formula or the ipkg project.
    
    env DEVICE PACKAGE [--min-version=8.0 --arch=armv7s -v -x]
    
    install   DEVICE PACKAGE... [--min-version=8.0 --archs=armv7s,arm64 -v -x]     --install packages.
    reinstall DEVICE PACKAGE... [--min-version=8.0 --archs=armv7s,armv7 -v -x]     --reinstall packages.
    upgrade   DEVICE PACKAGE... [--min-version=10.13 --archs=x86_64,i386 -v -x]    --upgrade packages.

    uninstall PACKAGE...                          --uninstall packages.
    info      PACKAGE...                          --print the information of packages.
    
    create-framework PACKAGE...                   --create framework for packages.
    
    logs PACKAGE PLATFORM ARCH                    --print the logs of a installed package.
    
    min-version [phone|watch|mac|tv]              --print the supported min-version of devices.
    
    cleanup          --cleanup the unused cache.
    update           --update the formula repository.
EOF
    if [ -z "$1" ] ; then
        exit
    else
        exit "$1"
    fi
}

parse_params() {
    unset TARGET_PACKAGE_LIST
    unset TARGET_ARCH_LIST
    unset TARGET_ARCH
    unset TARGET_HOST
    unset TARGET_DEVICE
    unset TARGET_PLATFORM
    unset TARGET_PLATFORM_MIN_VERSION
    
    unset COMMAND
    unset VERBOSE
    unset XTRACE
    
    unset HAS_SIMULATOR
    unset FOR_SIMULATOR

    COMMAND="$1"
    TARGET_DEVICE="$2"
    
    case $TARGET_DEVICE in
        phone|watch|tv|mac);;
        *)  die "device must be one of tv|watch|phone|mac";;
    esac
    
    shift 2
    
    while [ -n "$1" ]
    do
        case $1 in
            --min-version=*)
                TARGET_PLATFORM_MIN_VERSION=$(getvalue "$1")
                ;;
            --simulator)
                if [ "$TARGET_DEVICE" = 'mac' ] ; then
                    warn "mac no simulator."
                else
                    HAS_SIMULATOR=true
                fi
                ;;
            --arch=*)
                if [ "$COMMAND" = 'env' ] ; then
                    TARGET_ARCH=$(getvalue "$1")
                else
                    die "$1 is a invalid param. do you want --archs argument?"
                fi
                ;;
            --archs=*)
                if [ "$COMMAND" = 'env' ] ; then
                    die "$1 is a invalid param. do you want --arch argument?"
                else
                    TARGET_ARCH_LIST=$(getvalue "$1")
                fi
                ;;
            --verbose|-v)
                VERBOSE=true
                ;;
            --xtrace|-x)
                XTRACE=true
                set -x
                ;;
            [a-z]*)
                if [ "$COMMAND" = 'env' ] ; then
                    if [ -z "$TARGET_PACKAGE" ] ; then
                        TARGET_PACKAGE="$1"
                    else
                        die "env command accept only one package name."
                    fi
                else
                    if [ -z "$TARGET_PACKAGE_LIST" ] ; then
                        TARGET_PACKAGE_LIST="$1"
                    else
                        TARGET_PACKAGE_LIST="$TARGET_PACKAGE_LIST $1"
                    fi
                fi
                ;;
            *)  die "$1 is a invalid param."
        esac
        shift
    done
     
    [ -z "$TARGET_PLATFORM_MIN_VERSION" ] && {
        TARGET_PLATFORM_MIN_VERSION=$(get_support_device_min_version "$TARGET_DEVICE")
        warn "--min-version=VALUE argument is not specified. use default value [$TARGET_PLATFORM_MIN_VERSION]."
    }
    
    if [ "$COMMAND" = 'env' ] ; then
        [ -z "$TARGET_ARCH" ] && {
            TARGET_ARCH=$(list_support_devices_archs "$TARGET_DEVICE" | cut -d' ' -f1)
            warn "--arch=VALUE argument is not specified. use the default value [$TARGET_ARCH]."
        }
    else
        if [ -z "$TARGET_ARCH_LIST" ] ; then
            TARGET_ARCH_LIST=$(list_support_devices_archs "$TARGET_DEVICE")
            warn "--archs=VALUE argument is not specified. use the default value [$TARGET_ARCH_LIST]."
        else
            TARGET_ARCH_LIST=$(printf "$TARGET_ARCH_LIST" | tr ',' ' ')
        fi
    fi
}

main() {
    if [ "$(uname -s)" != 'Darwin' ] ; then
        die "this software can only run on macOS."
    fi

    if [ -z "$IPKG_FORMULA_REPO_URL" ] ; then
        MY_FORMULA_REPO_URL='https://github.com/leleliu008/ipkg-formula.git'
    else
        MY_FORMULA_REPO_URL="$IPKG_FORMULA_REPO_URL"
    fi

    if [ -z "$IPKG_HOME_DIR" ] ; then
        MY_HOME_DIR="$HOME/.ipkg"
    else
        MY_HOME_DIR="$IPKG_HOME_DIR"
    fi

    DIR_FORMULA="$MY_HOME_DIR/formula"
    DIR_DOWNLOAD="$MY_HOME_DIR/downloads"
    DIR_BOTTLE="$MY_HOME_DIR/bottles"
    DIR_BACKUP="$MY_HOME_DIR/backup"
    DIR_PKG="$MY_HOME_DIR/pkg"

    TIMESTAMP_UNIX=$(date +%s)
     
    case $1 in
        --help|help|-h) 
            help
            ;;
        --version|version|-V)
            echo "ipkg  $MY_VERSION"
            check_DEVELOPER_DIR
            echo "Xcode $XCODE_VERSION"
            ;;
        list)
            shift
            case $1 in
                devices)
                    shift
                    list_support_devices "$@"
                    ;;
                platforms)
                    shift
                    list_support_platforms "$@"
                    ;;
                versions)
                    shift
                    list_support_devices_versions "$@"
                    ;;
                archs)
                    shift
                    list_support_devices_archs "$@"
                    ;;
                available)
                    shift
                    list_available_packages "$@"
                    ;;
                installed)
                    shift
                    list_installed_packages "$@"
                    ;;
                outdated)
                    shift
                    list_outdated_packages "$@"
                    ;;
                *) help 1
            esac
            ;;
        min-version)
            shift
            get_support_device_min_version "$1"
            ;;
        tree)
            shift
            tree_a_installed_package "$@"
            ;;
        search)
            shift
            search_packages "$*"
            ;;
        env) 
            check_DEVELOPER_DIR
            parse_params "$@"
            make_env "$TARGET_PACKAGE"
            ;;
        install)
            check_DEVELOPER_DIR
            parse_params "$@"
            install_packages
            ;;
        reinstall)
            check_DEVELOPER_DIR
            parse_params "$@"
            reinstall_packages
            ;;
        upgrade)
            check_DEVELOPER_DIR
            parse_params "$@"
            upgrade_packages
            ;;
        uninstall)
            shift
            uninstall_packages "$@"
            ;;
        info)
            shift
            info_packages "$@"
            ;;
        cat)
            shift
            cat_formula_of_a_package "$@"
            ;;
        edit)
            shift
            edit_formula_of_a_package "$@"
            ;;
        update)
            update_formula_repository;;
        cleanup)
            cleanup;;
        homepage)
            shift
            open_homepage_of_a_package "$@"
            ;;
        prefix)
            shift
            print_prefix_of_a_package "$@"
            ;;
        fetch)
            shift
            fetch_a_package "$@"
            ;;
        logs)
            shift
            logs_a_package "$@"
            ;;
        pack)
            shift
            pack_a_package "$@"
            ;;
        create-framework)
            shift
            create_framework_for_packages "$@"
            ;;
        is)
            shift
            case $1 in
                available)
                    shift
                    is_package_available "$@"
                    ;;
                installed)
                    shift
                    is_package_installed "$@"
                    ;;
                outdated)
                    shift
                    is_package_outdated "$@"
                    ;;
                *) help 1
            esac
            ;;
        *) help 1
    esac
}

main "$@"

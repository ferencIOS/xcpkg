#!/bin/sh

#------------------------------------------------------------------------------
# https://clang.llvm.org/docs/ClangCommandLineReference.html
# https://clang.llvm.org/docs/CrossCompilation.html
# https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art024
#------------------------------------------------------------------------------

COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;34m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

print() {
    printf "%b" "$*"
}

echo() {
    print "$*\n"
}

info() {
    echo "$COLOR_PURPLE==>$COLOR_OFF $COLOR_GREEN$@$COLOR_OFF"
}

success() {
    print "${COLOR_GREEN}[✔] $*\n${COLOR_OFF}"
}

warn() {
    print "${COLOR_YELLOW}🔥 $*\n${COLOR_OFF}"
}

error() {
    print "${COLOR_RED}[✘] $*\n${COLOR_OFF}"
}

die() {
    print "${COLOR_RED}[✘] $*\n${COLOR_OFF}"
    exit 1
}

list() {
    for item in $@
    do
        echo "$item"
    done
}

list_length() {
    echo $#
}

nproc() {
    if command nproc --version > /dev/null 2>&1 ; then
        command nproc
    elif test -f /proc/cpuinfo ; then
        grep -c processor /proc/cpuinfo
    elif command -v sysctl > /dev/null ; then
        sysctl -n machdep.cpu.thread_count
    else
        echo 4
    fi
}

sed_in_place() {
    if command -v gsed > /dev/null ; then
        gsed -i "$1" "$2"
    elif command -v sed  > /dev/null ; then
        sed -i    "$1" "$2" 2> /dev/null || 
        sed -i "" "$1" "$2"
    else
        die "please install sed utility."
    fi
}

trim() {
    if [ $# -eq 0 ] ; then
        sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
    else
        if [ -n "$*" ] ; then
            echo "$*" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
        fi
    fi
}

tolower() {
    if [ $# -eq 0 ] ; then
        if command -v tr > /dev/null ; then
            tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            gawk '{print(tolower($0))}'
        else
            die "please install GNU CoreUtils or awk."
        fi
    else
        if [ -z "$*" ] ; then
            return 0
        fi
        if command -v tr > /dev/null ; then
            echo "$*" | tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            echo "$*" | awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            echo "$*" | gawk '{print(tolower($0))}'
        elif command -v python > /dev/null ; then
            python  -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python3 > /dev/null ; then
            python3 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python2 > /dev/null ; then
            python2 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v perl > /dev/null ; then
            perl -e 'print @ARGV[0],"\n"' "$1"
        elif command -v node > /dev/null ; then
            node -e 'console.log(process.argv[2].toLowerCase())' - "$*"
        else
            die "please install GNU CoreUtils or awk."
        fi
    fi
}

format_unix_timestamp() {
   date -jf "%s" "$1" "$2" 2> /dev/null ||
   date -d      "@$1" "$2"
}

getvalue() {
    if [ $# -eq 0 ] ; then
        cut -d= -f2
    else
        echo "$1" | cut -d= -f2
    fi
}

run() {
    info "$*"
    eval "$*"
}

prompt_user_to_install_bat() {
    warn "if you want to have a better experience, I strongly recommend you install ${COLOR_RED}bat${COLOR_OFF} on your os. For more details, see ${COLOR_RED}https://github.com/sharkdp/bat${COLOR_OFF}"
}

__fetch_via_git() {
    if [ -d "$FETCH_OUTPUT_PATH" ] ; then
        if      git -C "$FETCH_OUTPUT_PATH" rev-parse 2> /dev/null ; then
            run git -C "$FETCH_OUTPUT_PATH" pull &&
            run git -C "$FETCH_OUTPUT_PATH" submodule update --recursive
        else
            run rm -rf "$FETCH_OUTPUT_PATH" &&
            run git -C "$FETCH_OUTPUT_DIR" clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME"
        fi
    else
        run git -C "$FETCH_OUTPUT_DIR" clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME"
    fi
}

__fetch_archive_via_tools() {
    if [ -f "$FETCH_OUTPUT_PATH" ] ; then
        if [ -n "$FETCH_SHA256" ] ; then
            if is_sha256sum_match "$FETCH_OUTPUT_PATH" "$FETCH_SHA256" ; then
                success "$FETCH_OUTPUT_PATH already have been downloaded."
                return 0
            fi
        fi
        rm -f "$FETCH_OUTPUT_PATH"
    fi

    if command -v curl > /dev/null ; then
        run curl --fail --retry 20 --retry-delay 30 --location -o "$FETCH_OUTPUT_PATH" "\"$FETCH_URL\""
    elif command -v wget > /dev/null ; then
        run wget --timeout=60 -O "$FETCH_OUTPUT_PATH" "\"$FETCH_URL\""
    elif command -v http > /dev/null ; then
        run http --timeout=60 -o "$FETCH_OUTPUT_PATH" "\"$FETCH_URL\""
    elif command -v lynx > /dev/null ; then
        run lynx -source "$FETCH_URL" > "\"$FETCH_OUTPUT_PATH\""
    elif command -v aria2c > /dev/null ; then
        run aria2c -d "$FETCH_OUTPUT_DIR" -o "$FETCH_OUTPUT_NAME" "\"$FETCH_URL\""
    elif command -v axel > /dev/null ; then
        run axel -o "$FETCH_OUTPUT_PATH" "\"$FETCH_URL\""
    else
        die "please install curl or wget."
    fi

    if [ $? -eq 0 ] ; then
        success "Fetched to $FETCH_OUTPUT_PATH success."
    else
        die "Fetched to $FETCH_OUTPUT_PATH failed."
    fi

    if [ -n "$FETCH_SHA256" ] ; then
        die_if_sha256sum_mismatch "$FETCH_OUTPUT_PATH" "$FETCH_SHA256"
    fi
}

# fetch <URL> [--sha256=SHA256] <--output-path=PATH>
# fetch <URL> [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
# fetch <URL> [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
# fetch <URL> [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>
fetch() {
    unset FETCH_URL
    unset FETCH_SHA256
    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_NAME
    unset FETCH_OUTPUT_PATH
    
    if [ -z "$1" ] ; then
        die "please specify a fetch url."
    else
        FETCH_URL="$1"
    fi
    
    shift
    
    while [ -n "$1" ]
    do
        case $1 in
            --sha256=*)
                FETCH_SHA256=$(getvalue "$1")
                ;;
            --output-dir=*)
                FETCH_OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                    die "--output-dir argument's value must be not empty."
                fi
                ;;
            --output-name=*)
                FETCH_OUTPUT_NAME=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                    die "--output-name argument's value must be not empty."
                fi
                ;;
            --output-path=*)
                FETCH_OUTPUT_PATH=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_PATH" ] ; then
                    die "--output-path argument's value must be not empty."
                fi
        esac
        shift
    done
    
    if [ -z "$FETCH_OUTPUT_PATH" ] ; then
        [ -z "$FETCH_OUTPUT_DIR" ]  && FETCH_OUTPUT_DIR="$PWD"
        [ -z "$FETCH_OUTPUT_NAME" ] && FETCH_OUTPUT_NAME=$(basename "$FETCH_URL")

        FETCH_OUTPUT_PATH="$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME"
    else
        FETCH_OUTPUT_DIR="$(dirname $FETCH_OUTPUT_PATH)"
        FETCH_OUTPUT_NAME="$(basename $FETCH_OUTPUT_PATH)"
    fi

    if [ ! -d "$FETCH_OUTPUT_DIR" ] ; then
        run install -d "$FETCH_OUTPUT_DIR"
    fi

    case $FETCH_URL in
        *.git) __fetch_via_git ;;
        *)     __fetch_archive_via_tools ;;
    esac
}

sha256sum() {
    die_if_file_is_not_exist "$1"

    if command -v openssl > /dev/null ; then
        openssl sha256 "$1" | awk '{print $2}'
    elif command sha256sum --version > /dev/null 2>&1 ; then
        sha256sum "$1" | awk '{print $1}'
    else
        die "please install openssl or GNU CoreUtils."
    fi
}

is_sha256sum_match() {
    die_if_file_is_not_exist "$1"
    [ -z "$2" ] && die "please specify sha256sum."
    [ "$(sha256sum $1)" = "$2" ]
}

die_if_sha256sum_mismatch() {
    is_sha256sum_match "$1" "$2" || die "sha256sum mismatch."
}

__fetch_sources_of_a_package() {
    # fetch source code if needed
    if [ "$PACKAGE_SRC_TYPE" != 'dir' ] ; then
        fetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SUM" --output-path="$PACKAGE_SRC_PATH"
    fi
}

__fetch_patches_of_a_package() {
    unset PACKAGE_PATCHES

    # fetch patches if posible
    while [ -n "$1" ]
    do
        fetch "$1" --sha256="$2" --output-dir="$MY_PATCH_DIR/$PACKAGE_NAME" --output-name="$(basename $1)"
        
        if [ -z "$PACKAGE_PATCHES" ] ; then
            PACKAGE_PATCHES="$FETCH_OUTPUT_PATH"
        else
            PACKAGE_PATCHES="$PACKAGE_PATCHES $FETCH_OUTPUT_PATH"
        fi

        shift 2
    done
}

__fetch_resources_of_a_package() {
    __fetch_sources_of_a_package

    __fetch_patches_of_a_package $PACKAGE_PATCHES
}

die_if_file_is_not_exist() {
    [ -z "$1" ] && die "please specify a file path."
    [ -f "$1" ] || die "$1 is not exist."
}

die_if_file_is_not_executable() {
    die_if_file_is_not_exist "$1"
    [ -x "$1" ] || die "$1 is not executable."
}

die_if_abi_____is_not_specified() {
    [ -z "$1" ] && die "please specify a abi."
}

die_if_abi_____is_not_supported() {
    die_if_abi_____is_not_specified "$1"
    
    for ABI in $(__list_supported_abis)
    do
        [ "$ABI" = "$1" ] && return 0
    done

    die "$1 abi is not supported."
}

die_if_package_is_not_specified() {
    [ -z "$1" ] && die "please specify a package name."
}

die_if_package_list_is_not_specified() {
    [ -z "$1" ] && die "please specify at least one package name."
}

die_if_package_is_not_available() {
    is_package_available "$1" || die "$1 is not available."
}

die_if_package_is_already_exist() {
    die_if_package_is_not_specified "$1"
    [ -f "$MY_FORMULA_DIR/$1.sh" ] && die "$1 package is already exist."
}

die_from_package_is_not_installed() {
    die "$1 is not installed."
}

die_if_package_is_not_installed() {
    is_package_installed "$1" || die_from_package_is_not_installed "$1"
}

is_package_available() {
    die_if_package_is_not_specified "$1"
    [ -f "$MY_FORMULA_DIR/$1.sh" ]
}

is_package_installed() {
    die_if_package_is_not_specified "$1"
    
    [ -d "$MY_INSTALL_DIR/$1" ]              || return 1
    [ -f "$MY_INSTALL_DIR/$1/manifest.txt" ] || return 1

    for ABI in $(cat "$MY_INSTALL_DIR/$1/manifest.txt")
    do
        [ -d "$MY_INSTALL_DIR/$1/$ABI" ]                       || return 1
        [ -d "$MY_INSTALL_DIR/$1/$ABI/log" ]                   || return 1
        [ -f "$MY_INSTALL_DIR/$1/$ABI/log/installed.log.txt" ] || return 1
    done
}

is_package__outdated() {
    ___load_formula_of_a_package "$1"

    [ -d "$MY_INSTALL_DIR/$1" ]              || die_from_package_is_not_installed "$1"
    [ -f "$MY_INSTALL_DIR/$1/manifest.txt" ] || die_from_package_is_not_installed "$1"

    for ABI in $(__list_abis_of_a_installed_package "$1")
    do
        [ -d "$MY_INSTALL_DIR/$1/$ABI" ]                       || die_from_package_is_not_installed "$1"
        [ -d "$MY_INSTALL_DIR/$1/$ABI/log" ]                   || die_from_package_is_not_installed "$1"
        [ -f "$MY_INSTALL_DIR/$1/$ABI/log/installed.log.txt" ] || die_from_package_is_not_installed "$1"
        die_if_load_installed_log_failed "$1" "$ABI"
        [ "$PACKAGE_VERSION" = "$installed_version" ] && return 1
        [ "$PACKAGE_VERSION" = $(printf "$PACKAGE_VERSION\n$installed_version" | sort --version-sort --reverse | head -n 1) ]
    done
}

__list_packages_which_is_not_depended_by_others() {
    unset BREAK
    unset NDEPENDED_PACKAGES
    unset AVAILABLE_PACKAGES

    AVAILABLE_PACKAGES=$(__list_available_packages)

    for x in $AVAILABLE_PACKAGES
    do
        if [ "$x" = 'test' ] ; then
            continue
        fi
        for y in $AVAILABLE_PACKAGES
        do
            if [ "$x" = "$y" ] || [ 'test' = "$y" ] ; then
                continue
            else
                ___load_formula_of_a_package "$y"
                for z in $PACKAGE_DEPENDS
                do
                    if [ "$x" = "$z" ] ; then
                        BREAK=true
                        break 2
                    fi
                done
            fi
        done
        if [ "$BREAK" = 'true' ] ; then
            unset BREAK
        else
            if [ -z "$NDEPENDED_PACKAGES" ] ; then
                NDEPENDED_PACKAGES="$x"
            else
                NDEPENDED_PACKAGES="$NDEPENDED_PACKAGES $x"
            fi
            if [ "$(list_length $NDEPENDED_PACKAGES)" -eq 50 ] ; then
                echo "$NDEPENDED_PACKAGES" | tr ' ' ,
                echo
                unset NDEPENDED_PACKAGES
            fi
        fi
    done
    if [ -n "$NDEPENDED_PACKAGES" ] ; then
        echo "$NDEPENDED_PACKAGES" | tr ' ' ,
    fi
}

__list_available_packages() {
    unset SILENT

    case $# in
        0)  ;;
        1)  if [ "$1" = '-q' ] ; then
                SILENT=true
            else
                die "list available action only accept -q argument."
            fi
            ;;
        *)  die "list available action only accept -q argument."
    esac

    [ -d "$MY_FORMULA_DIR" ] || {
        if [ "$SILENT" = 'true' ] ; then
            __update_formula_repository >/dev/null 2>&1
        else
            __update_formula_repository
        fi
    }
    
    if [ "$SILENT" = 'true' ] ; then
        cd "$MY_FORMULA_DIR" 2>/dev/null || exit 1
    else
        cd "$MY_FORMULA_DIR" || exit 1
    fi

    for item in $(ls *.sh | sed 's/\.sh//g')
    do
        echo "$item"
    done
}

__list_installed_packages() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
         cd "$MY_INSTALL_DIR" 2>/dev/null || return 1
    else
        return 0
    fi

    for packageName in *
    do
        if is_package_installed "$packageName" ; then
            echo "$packageName"
        fi
    done
}

__list__outdated_packages() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
         cd "$MY_INSTALL_DIR" 2>/dev/null || return 1
    else
        return 0
    fi

    for packageName in *
    do
        is_package_available "$packageName" || continue
        is_package_installed "$packageName" || continue
        is_package__outdated "$packageName" || continue
        echo "$packageName"
    done
}

__list_abis_of_a_installed_package() {
    die_if_package_is_not_installed "$1"
    cat "$MY_INSTALL_DIR/$1/manifest.txt"
}

__tree_installed_of_a_package() {
    die_if_package_is_not_installed "$1"

    PKG_INSTALL_DIR="$MY_INSTALL_DIR/$1"

    shift

    if command -v tree > /dev/null ; then
        run tree $@ --dirsfirst "$PKG_INSTALL_DIR"
    else
        warn "please install tree utility."
    fi
}

__uninstall_packages() {
    shift

    die_if_package_list_is_not_specified "$1"
    
    for packageName in $@
    do
        __uninstall_a_package "$packageName" || return 1
    done
}

__uninstall_a_package() {
    die_if_package_is_not_installed "$1"

    run rm -rf "$MY_INSTALL_DIR/$1"
}

____view_a_formula() {
    die_if_package_is_not_available "$1"

    [ -z "$2" ] || warn "view action accept only one argument."
    
    if command -v bat > /dev/null ; then
        bat "$MY_FORMULA_DIR/$1.sh"
    else
        cat "$MY_FORMULA_DIR/$1.sh"
        echo
        prompt_user_to_install_bat
    fi    
}

____edit_a_formula() {
    die_if_package_is_not_available "$1"

    [ -z "$2" ] || warn "edit action accept only one argument."

    [ -z "$EDITOR" ] &&
    EDITOR=$(command -v nvim) ||
    EDITOR=$(command -v vim) ||
    EDITOR=$(command -v vi) ||
    EDITOR=$(command -v open) ||
    die "please set EDITOR environment variable."

    "$EDITOR" "$MY_FORMULA_DIR/$1.sh"
}

__create_a_formula() {
    die_if_package_is_already_exist "$1"

    cat > "$MY_FORMULA_DIR/$1.sh" <<EOF
summary "Summary of this package"

webpage "https://www.xx.com"

# the source code download url of this package. the value of src_url must end with one of .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz
src_url "https://www.xx.com/pkgname-x.y.z.tar.gz"

# the sha256sum of source code. If the value of src_url end with .git, this function is optional, otherwise, this function must be invoked.
src_sum "c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1"

# the version of this package. If this function is not invoked, it will be calculated from src_url.
#version "x.y.z"

# the license of this package.
#license "MIT"

# the required commands of this package when installing. If specify multiple values, separate them with spaces.
#require "a b c"

# the packages are depended by this package. If specify multiple values, separate them with spaces.
#depends "a b c"

prepare() {
    :
    #this function is optional, you can delete it, if don't use it.
}

build() {
    :
    #configure
    #cmake
    #meson
    #cargo
    #go
    #make
}
EOF
    ____edit_a_formula "$1"
}

__delete_a_formula() {
    die_if_package_is_not_available "$1"

    if rm "$MY_FORMULA_DIR/$1.sh" ; then
        success "delete $1 formula success."
    else
        die "delete $1 formula failed."
    fi
}

__rename_a_formula() {
    die_if_package_is_not_available "$1"
    die_if_package_is_already_exist "$2"

    if mv "$MY_FORMULA_DIR/$1.sh" "$MY_FORMULA_DIR/$2.sh" ; then
        success "rename formula $1 -> $2 success."
    else
        die "rename formula $1 -> $2 failed."
    fi
}

__update_formula_repository() {
    fetch "$MY_FORMULA_REPO_URL" --output-dir="$MY_HOME_DIR" --output-name=formula
}

____upgrade_packages() {
    check_prerequisites
    parse_arguments "$@"

    [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] && USER_SPECIFIED_PACKAGE_LIST=$(__list__outdated_packages)
    [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] && return 0

    __reinstall_packages
}

__reinstall_packages() {
    check_prerequisites
    parse_arguments "$@"

    die_if_package_list_is_not_specified "$USER_SPECIFIED_PACKAGE_LIST"

    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        die_if_package_is_not_available "$packageName"
        die_if_package_is_not_installed "$packageName"
    done
    
    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        {
            [ -d "$MY_BACKUP_DIR" ] || mkdir -p "$MY_BACKUP_DIR"
        } &&
        mv "$MY_INSTALL_DIR/$packageName" "$MY_BACKUP_DIR/$packageName" &&
        __install_a_package "$packageName" &&
        rm -rf "$MY_BACKUP_DIR/$packageName"
    done
}

__cleanup() {
    success "Done."
}

__search_packages() {
    [ -z "$1" ] && die "please specify a keyword."
    [ -d "$MY_FORMULA_DIR" ] || __update_formula_repository
    
    cd "$MY_FORMULA_DIR" || exit 1

    for item in $(ls -1 *.sh | sed 's/\.sh//g')
    do
        echo "$item" | grep "$*" || true
    done
}

__show_webpage_of_a_package() {
    if [ -z "$1" ] ; then
        PACKAGE_WEBPAGE="$MY_HOME_PAGE"
    else
        ___load_formula_of_a_package "$1"
    fi
    
    echo "$PACKAGE_WEBPAGE"

    if command -v open > /dev/null ; then
        open "$PACKAGE_WEBPAGE"
    fi
}

__show_depends_of_a_package() {
    die_if_package_is_not_specified "$1"

    EMPTY_DIR=$(mktemp -d) || return 1
    __gen_dependency_tree 'true' "$1"

    if [ -f "$DEPENDENCIES_TXT" ] ; then
        cat "$DEPENDENCIES_TXT"
    elif [ -f "$DEPENDENCIES_PNG" ] ; then
        if command -v open > /dev/null ; then
            open "$DEPENDENCIES_PNG"
        elif command -v feh > /dev/null ; then
            feh "$DEPENDENCIES_PNG"
        elif command -v eog > /dev/null ; then
            eog "$DEPENDENCIES_PNG"
        elif command -v lsix > /dev/null ; then
            lsix "$DEPENDENCIES_PNG"
        fi
    elif [ -f "$DEPENDENCIES__GV" ] ; then
        cat "$DEPENDENCIES__GV"
    fi
}

__show_prefix_of_a_package() {
    if [ -z "$1" ] ; then
        echo "$MY_HOME_DIR"
    else
        die_if_package_is_not_installed "$1"
        echo "$MY_INSTALL_DIR/$1"
    fi
}

__show_logs_of_a_package() {
    die_if_package_is_not_installed "$1"
    die_if_abi_____is_not_supported "$2"

    if command -v bat > /dev/null ; then
        VIEWER=bat
    else
        VIEWER=less
    fi

    for item in $(ls "$MY_INSTALL_DIR/$1/$2/log"/*)
    do
        if [ "$VIEWER" = 'bat' ] ; then
            case $item in
                *.png) ;;
                *.sh|*/installed.log.txt)
                    bat -l bash "$item" ;;
                *)  bat "$item"
            esac
        else
            "$VIEWER" "$item"
        fi
    done

    if [ "$VIEWER" != 'bat' ] ; then
        prompt_user_to_install_bat
    fi
}

__pack_bottle_of_a_package() {
    ABI="$(__list_abis_of_a_installed_package "$1" | head -n 1)"
    die_if_load_installed_log_failed "$1" "$ABI"

    install -d "$MY_BOTTLE_DIR" || return 1

    if command -v 7za > /dev/null ; then
        SUFFIX=7z
    elif command -v zip > /dev/null ; then
        SUFFIX=zip
    elif command -v tar > /dev/null ; then
        if command -v gzip > /dev/null ; then
            SUFFIX=tar.gz
        elif command -v xz > /dev/null ; then
            SUFFIX=tar.xz
        elif command -v bzip2 > /dev/null ; then
            SUFFIX=tar.bz2
        else
            die "please install gzip or xz or bzip2 utility."
        fi
    else
        die "please install zip or tar utility."
    fi

    FILE_PATH="$MY_BOTTLE_DIR/$1-$installed_version.bottle.$SUFFIX"

    if [ -f "$FILE_PATH" ] ; then
        rm  "$FILE_PATH" || return 1
    fi

    case $SUFFIX in
        7z)  run 7za a -t7z -r "$FILE_PATH" "$MY_INSTALL_DIR/$1" ;;
        zip) run cd "$MY_INSTALL_DIR" && run zip -9 -r "$FILE_PATH" "$1" ;;
        tar.gz)  run tar zvcf "$FILE_PATH" -C "$MY_INSTALL_DIR" "$1" ;;
        tar.xz)  run tar Jvcf "$FILE_PATH" -C "$MY_INSTALL_DIR" "$1" ;;
        tar.bz2) run tar jvcf "$FILE_PATH" -C "$MY_INSTALL_DIR" "$1" ;;
    esac
}

get_direct_dependency_package_list_of_a_package() {
    grep '^\s*depends\s*".*"' "$MY_FORMULA_DIR/$1.sh" | sed 's/.*depends.*"\(.*\)"/\1/'
}

# $1 is first call
# $2 packageName
__gen_dependency_list() {
    if [ "$1" = 'true' ] ; then
        unset I
        unset DEPENDENCY_PACKAGE_LIST
    fi

    unset DIRECT_DEPENDENCY_PACKAGE_LIST
    if [ -z "$2" ] ; then
        DIRECT_DEPENDENCY_PACKAGE_LIST="$USER_SPECIFIED_PACKAGE_LIST"
    else
        DIRECT_DEPENDENCY_PACKAGE_LIST=$(get_direct_dependency_package_list_of_a_package "$2")
    fi
    
    for dependencyPkgName in $DIRECT_DEPENDENCY_PACKAGE_LIST
    do
        die_if_package_is_not_available "$dependencyPkgName"

        DEPENDENCY_PACKAGE_LIST_TEMP=""

        for item in $DEPENDENCY_PACKAGE_LIST
        do
            if [ "$dependencyPkgName" = "$item" ] ; then
                continue
            else
                DEPENDENCY_PACKAGE_LIST_TEMP="$DEPENDENCY_PACKAGE_LIST_TEMP $item"
            fi
        done
        
        DEPENDENCY_PACKAGE_LIST="$dependencyPkgName $DEPENDENCY_PACKAGE_LIST_TEMP"

        __gen_dependency_list 'false' "$dependencyPkgName"
    done
}

# $1 is first call
# $2 packageName
__gen_dependency_tree() {
    unset DIRECT_DEPENDENCY_PACKAGE_LIST
    DIRECT_DEPENDENCY_PACKAGE_LIST=$(get_direct_dependency_package_list_of_a_package "$2")

    if [ "$1" = 'true' ] ; then
        unset I

        unset DEPENDENCIES__GV
        unset DEPENDENCIES_PNG
        unset DEPENDENCIES_TXT

        DEPENDENCIES__GV="$EMPTY_DIR/$2.dependencies.gv"
        DEPENDENCIES_PNG="$EMPTY_DIR/$2.dependencies.png"
        DEPENDENCIES_TXT="$EMPTY_DIR/$2.dependencies.txt"
        
        if [ -n "$DIRECT_DEPENDENCY_PACKAGE_LIST" ] ; then
            echo "digraph \"$2\" {" > "$DEPENDENCIES__GV"
        fi
    fi

    if [ -f "$DEPENDENCIES__GV" ] ; then
        print "  \"$2\" -> {" >> "$DEPENDENCIES__GV"
        for dependencyPkgName in $DIRECT_DEPENDENCY_PACKAGE_LIST
        do
            print " \"$dependencyPkgName\"" >> "$DEPENDENCIES__GV"
        done
        echo " }" >> "$DEPENDENCIES__GV"
    fi

    I=$(expr ${I-0} + 1)

    for dependencyPkgName in $DIRECT_DEPENDENCY_PACKAGE_LIST
    do
        __gen_dependency_tree 'false' "$dependencyPkgName"
    done

    I=$(expr $I - 1)

    if [ "$I" -eq 0 ] ; then
        if [ -f "$DEPENDENCIES__GV" ] ; then
            echo "}" >> "$DEPENDENCIES__GV"

            if command -v dot > /dev/null ; then
                dot -Tpng -o "$DEPENDENCIES_PNG" "$DEPENDENCIES__GV"
            else
                warn "graphviz is not installed. we do not generate png format dependency image."
            fi

            # https://github.com/ggerganov/dot-to-ascii
            curl \
                -o "$DEPENDENCIES_TXT" \
                -s \
                -G \
                --data-urlencode "boxart=1" \
                --data-urlencode "src=$(cat $DEPENDENCIES__GV)" \
                "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php"
        fi
    fi
}

__get_brew_package_name_by_command_name() {
    case $1 in
        make) echo 'make'  ;;
       gmake) echo 'gmake' ;;
       cmake) echo 'cmake' ;;
       smake) echo 'smake' ;;
       meson) echo 'meson' ;;
       ninja) echo 'ninja' ;;
       patch) echo 'patch' ;;
       gperf) echo 'gperf' ;;
        nasm) echo 'nasm'  ;;
        yasm) echo 'yasm'  ;;
        gsed) echo 'gnu-sed'  ;;
        flex) echo 'flex'     ;;
       bison) echo 'bison'    ;;
     objcopy) echo 'binutils' ;;
          go) echo 'go'    ;;
        perl) echo 'perl'  ;;
        tree) echo 'tree'  ;;
       xmlto) echo 'xmlto' ;;
     itstool) echo 'itstool' ;;
      protoc) echo 'protobuf' ;;
    help2man) echo 'help2man' ;;
     doxygen) echo 'doxygen'  ;;
      ps2pdf) echo "ghostscript" ;;
    pkg-config) echo 'pkg-config' ;;
    libtool|libtoolize|glibtool|glibtoolize)
              echo "libtool" ;;
    autoreconf|autoconf|automake|autoheader)
              echo "automake" ;;
    autopoint) echo "gettext" ;;
    esac
}

__version() {
    case $(basename "$1") in
        cmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         make) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        gmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
       rustup) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        cargo) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           go) "$1"   version | cut -d ' ' -f3 | cut -c3- ;;
         tree) "$1" --version | cut -d ' ' -f2 | cut -c2- ;;
   pkg-config) "$1" --version 2> /dev/null | head -n 1 ;;
       m4|gm4) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}';;
    autopoint) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     automake|aclocal)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     autoconf|autoheader|autom4te|autoreconf|autoscan|autoupdate|ifnames)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      libtool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
   libtoolize|glibtoolize)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      objcopy) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f5 ;;
         flex) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bison) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         yacc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         nasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         yasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        patch) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}' ;;
        gperf) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        groff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     help2man) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         file) "$1" --version 2> /dev/null | head -n 1 | cut -d '-' -f2 ;;
      itstool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        xmlto) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
      xmllint) ;;
     xsltproc) ;;
         gzip)
            unset TEMP_FILE
            TEMP_FILE=$(mktemp)
            "$1" --version > $TEMP_FILE 2>&1
            cat $TEMP_FILE | head -n 1 | awk '{print($NF)}'
            rm $TEMP_FILE
            unset TEMP_FILE
            ;;
         lzip) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           xz) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
          zip) "$1" --version 2> /dev/null | sed -n '2p' | cut -d ' ' -f4 ;;
        unzip) "$1" -v        2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bzip2)
            unset TEMP_FILE
            TEMP_FILE=$(mktemp)
            "$1" --help 2> $TEMP_FILE
            cat $TEMP_FILE | head -n 1 | cut -d ' ' -f8 | cut -d ',' -f1
            rm $TEMP_FILE
            unset TEMP_FILE
            ;;
          tar)
            VERSION_MSG=$("$1" --version 2> /dev/null | head -n 1)
            case $VERSION_MSG in
                  tar*) echo "$VERSION_MSG" | cut -d ' ' -f4 ;;
               bsdtar*) echo "$VERSION_MSG" | cut -d ' ' -f2 ;;
            esac
            ;;
          git) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         curl) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
     awk|gawk) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 | tr , ' ' ;;
     sed|gsed) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
          pip) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         cpan) ;;
         grep) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '-' -f1 ;;
         ruby) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         perl) "$1" -v | sed -n '2p' | sed 's/.*v\([0-9]\.[0-9][0-9]\.[0-9]\).*/\1/' ;;
    python|python2|python3)
            unset TEMP_FILE
            TEMP_FILE=$(mktemp)
            "$1" --version > $TEMP_FILE 2>&1
            cat $TEMP_FILE | head -n 1 | cut -d ' ' -f2
            rm $TEMP_FILE
            unset TEMP_FILE
            ;;
         node) "$1" --version 2> /dev/null | head -n 1 | cut -d 'v' -f2 ;;
          zsh) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         bash) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '(' -f1 ;;
            *) "$1" --version 2> /dev/null | head -n 1
    esac
}

# eq  equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# version compare automake eq 1.16.0
# version compare automake lt 1.16.0
# version compare automake gt 1.16.0
# version compare automake le 1.16.0
# version compare automake ge 1.16.0
__version_compare() {
    unset VERSION_COMPARE_INPUT_COMMAND
    unset VERSION_COMPARE_INPUT_OPERATOR
    unset VERSION_COMPARE_INPUT_VERSION
    unset VERSION_COMPARE_XXXXX_VERSION

    VERSION_COMPARE_INPUT_COMMAND="$1"
    VERSION_COMPARE_INPUT_OPERATOR="$2"
    VERSION_COMPARE_INPUT_VERSION="$3"
    VERSION_COMPARE_XXXXX_VERSION="$(__version $VERSION_COMPARE_INPUT_COMMAND)"

    echo "VERSION_COMPARE_INPUT_COMMAND=$VERSION_COMPARE_INPUT_COMMAND"
    echo "VERSION_COMPARE_INPUT_OPERATOR=$VERSION_COMPARE_INPUT_OPERATOR"
    echo "VERSION_COMPARE_INPUT_VERSION=$VERSION_COMPARE_INPUT_VERSION"
    echo "VERSION_COMPARE_XXXXX_VERSION=$VERSION_COMPARE_XXXXX_VERSION"

    case $VERSION_COMPARE_INPUT_OPERATOR in
        le)
            [ "$VERSION_COMPARE_XXXXX_VERSION" = "$VERSION_COMPARE_INPUT_VERSION" ] && return 0
            [ "$VERSION_COMPARE_XXXXX_VERSION" = $(printf "$VERSION_COMPARE_XXXXX_VERSION\n$VERSION_COMPARE_INPUT_VERSION" | sort --version-sort | head -n 1) ]
            ;;
        ge)
            [ "$VERSION_COMPARE_XXXXX_VERSION" = "$VERSION_COMPARE_INPUT_VERSION" ] && return 0
            [ "$VERSION_COMPARE_XXXXX_VERSION" = $(printf "$VERSION_COMPARE_XXXXX_VERSION\n$VERSION_COMPARE_INPUT_VERSION" | sort --version-sort --reverse | head -n 1) ]
            ;;
        eq)
            [ "$VERSION_COMPARE_XXXXX_VERSION" = "$VERSION_COMPARE_INPUT_VERSION" ]
            ;;
        lt)
            [ "$VERSION_COMPARE_XXXXX_VERSION" = "$VERSION_COMPARE_INPUT_VERSION" ] && return 1
            [ "$VERSION_COMPARE_XXXXX_VERSION" = $(printf "$VERSION_COMPARE_XXXXX_VERSION\n$VERSION_COMPARE_INPUT_VERSION" | sort --version-sort | head -n 1) ]
            ;;
        gt)
            [ "$VERSION_COMPARE_XXXXX_VERSION" = "$VERSION_COMPARE_INPUT_VERSION" ] && return 1
            [ "$VERSION_COMPARE_XXXXX_VERSION" = $(printf "$VERSION_COMPARE_XXXXX_VERSION\n$VERSION_COMPARE_INPUT_VERSION" | sort --version-sort --reverse | head -n 1) ]
            ;;
        *) die '__version_compare: $VERSION_COMPARE_INPUT_OPERATOR: not recognized operator.'
    esac
}

# $1:
# automake<=1.16.0
# automake>=1.16.0
# automake=1.16.0
# automake<1.16.0
# automake>1.16.0
# automake
__get_command_from_require_item() {
    case $1 in
        *\<=*) echo "$1" | sed 's/<=/ /g' | cut -d ' ' -f1 ;;
        *\>=*) echo "$1" | sed 's/>=/ /g' | cut -d ' ' -f1 ;;
        *=*)   echo "$1" | cut -d '=' -f1 ;;
        *\<*)  echo "$1" | cut -d '<' -f1 ;;
        *\>*)  echo "$1" | cut -d '>' -f1 ;;
        *)     echo "$1" ;;
    esac
}

__list_commands_info() {
    for item in $@
    do
        unset COMMAND
        unset COMMAND_PATH
        unset COMMAND_VERSION

        COMMAND="$(__get_command_from_require_item "$item")"

        case $COMMAND in
            make)       COMMAND_PATH="$MAKE"  ;;
            cmake)      COMMAND_PATH="$CMAKE" ;;
            meson)      COMMAND_PATH="$MESON" ;;
            pkg-config) COMMAND_PATH="$PKG_CONFIG" ;;
                     *) COMMAND_PATH="$(command -v "$COMMAND")"
        esac

        if [ -n "$COMMAND_PATH" ] ; then
            COMMAND_VERSION=$(__version "$COMMAND_PATH")
        fi

        printf "%-11s %-10s %s\n" "$COMMAND" "$COMMAND_VERSION" "$COMMAND_PATH"
    done

    unset COMMAND
    unset COMMAND_PATH
    unset COMMAND_VERSION
}

__config_global_installation_variables() {
    unset MAKE
    unset CMAKE
    unset MESON
    unset PKG_CONFIG

    if [ -z "$PKG_CONFIG" ] ; then
        PKG_CONFIG=$(command -v pkg-config) ||
        PKG_CONFIG=$(command -v pkgconfig) ||
        PKG_CONFIG=$(command -v pkgconf)
    fi

    for item in $(echo "$PATH" | tr ':' ' ')
    do
        if [ -z "$MAKE" ] ; then
            if [ -f  "$item/make" ] && [ -x "$item/make" ] ; then
                MAKE="$item/make"
            fi
        fi

        if [ -z "$MAKE" ] ; then
            if [ -f  "$item/gmake" ] && [ -x "$item/gmake" ] ; then
                MAKE="$item/gmake"
            fi
        fi

        if [ -z "$CMAKE" ] ; then
            if [ -f   "$item/cmake" ] && [ -x "$item/cmake" ] ; then
                CMAKE="$item/cmake"
            fi
        fi

        if [ -z "$MESON" ] ; then
            if [ -f   "$item/meson" ] && [ -x "$item/meson" ] ; then
                MESON="$item/meson"
            fi
        fi

        if [ -n "$MAKE" ] && [ -n "$CMAKE" ] && [ -n "$MESON" ] ; then
            break
        fi
    done

    info "list commands"
    __list_commands_info go cargo rustup pkg-config cmake meson ninja make gmake bmake m4 gm4 autoconf automake libtool libtoolize glibtoolize flex bison yacc nasm yasm patch gperf doxygen itstool xmlto xmllint xsltproc file zip unzip xz bzip2 gzip lzip tar curl git awk gawk sed gsed grep cpan gem pip npm yarn ruby perl python python2 python3 node bash zsh
    echo

    for tool in $(list_tools_in_the_toolchain)
    do
        unset TOOL_PATH
        case $tool in
            cc)
                if [ -z "$CC" ] ; then
                    TOOL_PATH=$(command -v cc) ||
                    TOOL_PATH=$(command -v gcc) ||
                    TOOL_PATH=$(command -v clang)
                else
                    TOOL_PATH="$CC"
                fi
                ;;
            cxx)
                if [ -z "$CXX" ] ; then
                    TOOL_PATH=$(command -v c++) ||
                    TOOL_PATH=$(command -v g++) ||
                    TOOL_PATH=$(command -v clang++)
                else
                    TOOL_PATH="$CXX"
                fi
                ;;
            *)  TOOL_PATH=$(command -v "$tool")
        esac

        unset TOOL_UPPER
        TOOL_UPPER=$(echo "$tool" | tr a-z A-Z)

        eval $TOOL_UPPER=$TOOL_PATH
        eval export ${TOOL_UPPER}_FOR_BUILD=\"$TOOL_PATH\"
    done
    unset TOOL_PATH
    unset TOOL_UPPER

    for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
    do
        eval export ${FLAG}_FOR_BUILD=\"\$$FLAG\"
    done
    unset FLAG

    export PATH="$TOOLCHAIN_BIN_DIR:$PATH"

    MAKEFLAGS='-w'

    if [ "$VERBOSE" = 'true' ] ; then
        export PKG_CONFIG_DEBUG_SPEW=set
        MAKEFLAGS="$MAKEFLAGS --debug"
    fi
}

____install_packages() {
    check_prerequisites

    parse_arguments "$@"

    die_if_package_list_is_not_specified "$USER_SPECIFIED_PACKAGE_LIST"

    __config_global_installation_variables

    __gen_dependency_list 'true' '' || return 1

    echo "$COLOR_PURPLE==>$COLOR_OFF to install$COLOR_GREEN $DEPENDENCY_PACKAGE_LIST $COLOR_OFF\n"

    for INSTALLING_PACKAGE in $DEPENDENCY_PACKAGE_LIST
    do
        if is_package_installed "$INSTALLING_PACKAGE" ; then
            printf "$COLOR_GREEN%-10s$COLOR_OFF already have been installed.\n" "$INSTALLING_PACKAGE"
        else
            echo "${COLOR_PURPLE}=============== Installing ${COLOR_OFF}${COLOR_GREEN}${INSTALLING_PACKAGE}${COLOR_OFF}${COLOR_PURPLE} ===============${COLOR_OFF}"
            __install_a_package "$INSTALLING_PACKAGE" || die_from_installation_failed "$INSTALLING_PACKAGE"
        fi
    done
}

command_not_found() {
    case $1 in
        make) [ -z "$MAKE" ]  ;;
       cmake) [ -z "$CMAKE" ] ;;
       meson) [ -z "$MESON" ] ;;
       pkg-config)
              [ -z "$PKG_CONFIG" ] ;;
           *) ! command -v "$1" > /dev/null
    esac
}

__try_to_install_required_commands_via_package_manager() {
    if command -v brew > /dev/null ; then
        BREW_PACKAGE_NAME="$(__get_brew_package_name_by_command_name "$1")"
        if [ -z "$BREW_PACKAGE_NAME" ] ; then
            die "command not found: $*. you can install it then try again."
        else
            print "🔥  ${COLOR_GREEN}$*${COLOR_OFF} ${COLOR_YELLOW}command not found, we try to install it via${COLOR_OFF} ${COLOR_GREEN}HomeBrew${COLOR_OFF}\n"
            if run brew install "$BREW_PACKAGE_NAME" ; then
                case $1 in
                    make|cmake|meson|pkg-config)
                        eval "$(echo "$1" | tr a-z A-Z)=$(brew --prefix "$BREW_PACKAGE_NAME")/bin/$1"
                esac
            else
                die "install $BREW_PACKAGE_NAME via brew failed. you can install it then try again."
            fi
        fi
    else
        die "command not found: $*. you can install it then try again."
    fi
}

die_if_command_not_found() {
    if command_not_found "$1" ; then
        __try_to_install_required_commands_via_package_manager "$1"
    else
        if [ $# -eq 3 ] ; then
            if ! __version_compare $@ ; then
                __try_to_install_required_commands_via_package_manager $@
            fi
        fi
    fi
}

die_from_installation_failed() {
    if [ -z "$BUILD_FOR_ABI" ] ; then
        die "install $1 failed! you can go to $WORKING_DIR to see see."
    else
        die "install $1/$BUILD_FOR_ABI failed! you can go to $WORKING_DIR to see see."
    fi
}

__state() {
    STATE_NUM=$1

    shift

    STATE_MESSAGE="$@"

    echo "\n${COLOR_PURPLE}=== STATE ${STATE_NUM} : ${STATE_MESSAGE} ${COLOR_OFF}"
}

__parse_require_item() {
    case $1 in
        *\<=*) echo "$1" | sed 's/<=/ le /g' ;;
        *\>=*) echo "$1" | sed 's/>=/ ge /g' ;;
        *=*)   echo "$1" | sed 's/<=/ eq /g' ;;
        *\<*)  echo "$1" | sed 's/<=/ lt /g' ;;
        *\>*)  echo "$1" | sed 's/<=/ gt /g' ;;
        *)     echo "$1"
    esac
}

__install_a_package() {
    # brew install meson
    # Error: The current working directory doesn't exist, cannot proceed.
    # beacuse previous package's working direcotory is deleted.
    cd ~ || return 1

    __state 1 "init variables"
    unset WORKING_DIR
    unset SOURCE_DIR
    unset EMPTY_DIR
    unset NATIVE_BUILD_DIR
    unset BUILD_DIR
    unset BUILD_FOR_ABI
    unset CONFIG_XX_UPDATED

    __state 2 "loading formula"
    ___load_formula_of_a_package "$1"

    __state 3 "checking required commands"
    for item in $PACKAGE_REQUIRE
    do
        die_if_command_not_found $(__parse_require_item "$item")
    done
    __list_commands_info $PACKAGE_REQUIRE || return 1

    __state 4 "fetching resources if needed"
    __fetch_resources_of_a_package "$1"

    __state 5 "creating working directory"
    info "mktemp -d"
    WORKING_DIR=$(mktemp -d) || die "create working directory failed."

    __state 6 "unpacking resources to working directory"
    case $PACKAGE_SRC_URL in
        dir://*|*.git)
            run cp -r "$PACKAGE_SRC_PATH/*" "$WORKING_DIR" || return 1
            ;;
        *.c|*.cc|*.cxx|*.cpp)
            run cp    "$PACKAGE_SRC_PATH"   "$WORKING_DIR" || return 1
            ;;
        *.zip)
            run unzip "$PACKAGE_SRC_PATH" -d "$WORKING_DIR" || return 1
            ;;
        *.tar.xz|*.tar.gz|*.tar.lz|*.tar.bz2|*.tgz|*.txz)
            run tar xf "$PACKAGE_SRC_PATH" -C "$WORKING_DIR" --strip-components 1 || return 1
            ;;
        *)  die "$PACKAGE_SRC_URL : extension isn't recognized. the supported extensions are .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    if [ -z "$PACKAGE_SOURCE_DIR" ] ; then
        SOURCE_DIR="$WORKING_DIR"
    else
        SOURCE_DIR="$WORKING_DIR/$PACKAGE_SOURCE_DIR"
    fi

    __state 7 "change to source directory"
    run cd "$SOURCE_DIR" || return 1

    __state 8 "list content of source directory"
    run ls -l

    EMPTY_DIR="$WORKING_DIR/$TIMESTAMP_UNIX"
    mkdir "$EMPTY_DIR"

    __state 9 "build for build-machine"
    if command -v build0 > /dev/null ; then
        NATIVE_BUILD_DIR="$EMPTY_DIR/native"

        printf "%17s = %s\n\n" "PACKAGE_NAME" "$PACKAGE_NAME"

        for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
        do
            eval export $TOOL=\$"${TOOL}_FOR_BUILD"
            printf "%17s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
        done

        for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
        do
            eval export $FLAG=\$"${FLAG}_FOR_BUILD"
            printf "\n%17s = " "$FLAG"
            FIRST='true'
            for item in $(eval echo \$$FLAG | tr ':' ' ')
            do
                if [ "$FIRST" = 'true' ] ; then
                    FIRST='false'
                    echo "$item"
                else
                    echo "                    $item"
                fi
            done
        done
        echo
        printf "\n%17s = " PATH
        FIRST='true'
        for item in $(echo "$PATH" | tr ':' ' ')
        do
            if [ "$FIRST" = 'true' ] ; then
                FIRST='false'
                echo "$item"
            else
                echo "                    $item"
            fi
        done

        echo
        echo "      WORKING_DIR = $WORKING_DIR"
        echo "       SOURCE_DIR = $SOURCE_DIR"
        echo "        EMPTY_DIR = $EMPTY_DIR"
        echo " NATIVE_BUILD_DIR = $NATIVE_BUILD_DIR"
        echo "              PWD = $PWD"
        echo

        run mkdir "$NATIVE_BUILD_DIR" || return 1
        run cd    "$NATIVE_BUILD_DIR" || return 1
        run build0                    || return 1
    else
        warn "no build0  function defined in formula, skipped."
    fi

    __state 10 "do some preparation works"
    if command -v prepare > /dev/null ; then
        if [ "$PWD" != "$SOURCE_DIR" ] ; then
            cd "$SOURCE_DIR" || return 1
        fi
        run prepare || return 1
    else
        case $PACKAGE_BUILD_SYSTEM in
            autogen)
                warn "no prepare function defined in formula."
                run ./autogen.sh    || return 1
                ;;
            autotools)
                warn "no prepare function defined in formula."
                run autoreconf -ivf || return 1
                ;;
            *)  warn "no prepare function defined in formula, skipped."
        esac
    fi

    __state 11 "build for target-machine"
    __install_a_package_all_builds "$1" || return 1

    echo
    success "$1 have been installed successfully."

    if [ "$KEEP_WORKING_DIR" != 'true' ] ; then
        __state 12 "clean working directory."
        run rm -rf "$WORKING_DIR" || true
    fi

    __state 13 "list installed content."
    __tree_installed_of_a_package "$1" || true
}

__install_a_package_all_builds() {
    unset BUILD_ROUND_NUM

    __gen_dependency_list 'true' "$1" || return 1

    __gen_dependency_tree 'true' "$1" || return 1

    PKG_INSTALL_DIR="$MY_INSTALL_DIR/$1"

    unset BUILD_FOR_ABI_LIST

    for BUILD in $BUILD_LIST
    do
        BUILD_ROUND_NUM=$(expr ${BUILD_ROUND_NUM-0} + 1)

        BUILD_FOR_ABI=$(echo "$BUILD" | cut -d: -f1)

        if [ -z "$BUILD_FOR_ABI_LIST" ] ; then
            BUILD_FOR_ABI_LIST="$BUILD_FOR_ABI"
        else
            BUILD_FOR_ABI_LIST=$(printf "%s\n%s" "$BUILD_FOR_ABI_LIST" "$BUILD_FOR_ABI")
        fi

        BUILD_DIR="$EMPTY_DIR/$BUILD_FOR_ABI"

        if [ "$DRYRUN" = 'true' ] ; then
            ___dryrun_a_package_one_build "$1" || return 1
        else
            (
                install -d "$BUILD_DIR" &&
                cd "$BUILD_DIR" &&
                mkfifo pipe &&
                (tee install.log.txt < pipe &) &&
                __install_a_package_one_build "$1" > pipe 2>&1
            ) || return 1
        fi
    done

    echo "$BUILD_FOR_ABI_LIST" > "$PKG_INSTALL_DIR/manifest.txt"
}

___dryrun_a_package_one_build() {
    if [ -z "$SHELL" ] ; then
        SHELL=$(command -v zsh) ||
        SHELL=$(command -v bash) ||
        SHELL=$(command -v sh)
    fi
    __config_this_build_variables "$1" &&
    __printf_this_build_variables "$1" &&
    exec "$SHELL"
}

__step() {
    echo
    echo "${COLOR_PURPLE}=== $*${COLOR_OFF}"
}

__install_a_package_one_build() {
    echo
    echo "${COLOR_PURPLE}=============== cross-build ROUND $BUILD_ROUND_NUM for $BUILD_FOR_ABI ===============${COLOR_OFF}"
    echo

    if [ -f "$DEPENDENCIES_TXT" ] ; then
        __step "list depends packages"
        cat "$DEPENDENCIES_TXT"
        echo
    fi

    __step "list required commands"
    __list_commands_info $PACKAGE_REQUIRE || return 1
    echo

    if [ "$PACKAGE_BUILD_IN_SOURCE_DIR" = 'true' ] ; then
        run cd "$SOURCE_DIR" || return 1
    fi

    run __config_this_build_variables "$1" &&
    run __printf_this_build_variables "$1" &&
    run rm -rf "$ABI_INSTALL_DIR" && {
        if command -v build > /dev/null ; then
            build
        else
            case $PACKAGE_BUILD_SYSTEM in
                autogen)   configure ;;
                autotools) configure ;;
                configure) configure ;;
                cmake*)    cmake ;;
                meson)     meson ;;
                ninja)     ninja clean && ninja && ninja install ;;
                make)      make  clean && make  && make  install ;;
                cargo)     run cargo install --target "$CARGO_TARGET" -vv --path "$SOURCE_DIR" --root="$ABI_INSTALL_DIR" ;;
                go)        run go build -v -trimpath ;;
            esac
        fi
    } && {
        [ -d "$ABI_INSTALL_DIR" ] || {
            error "installed nothing."
            return 1
        }
    } &&
    run __justfy_pc_files &&
    run __install_logs "$1"
}

__justfy_pc_files() {
    if [ -d "$ABI_PKGCONF_DIR" ] ; then
        for item in $(find "$ABI_PKGCONF_DIR" -name "*.pc")
        do
            
            if grep 'Libs.private:' "$item" > /dev/null ; then
                LIBS_CONTENT=$(awk '/Libs:/{print}' "$item" || return 1)
                LIBS_PRIVATE_CONTENT=$(awk -F: '/Libs.private:/{print $2}' "$item" || return 1)
                sed_in_place "s|$LIBS_CONTENT|$LIBS_CONTENT$LIBS_PRIVATE_CONTENT|" "$item" || return 1
                sed_in_place '/Libs.private/d' "$item" || return 1
            fi
        done
    fi
}

__install_logs() {
    ABI_LOG_DIR="$ABI_INSTALL_DIR/log"

    install -v -d "$ABI_LOG_DIR" || return 1

    install_installed_log

    for item in "$MY_FORMULA_DIR/$1.sh" "$BUILD_DIR/install.log.txt" "$DEPENDENCIES__GV" "$DEPENDENCIES_PNG" "$DEPENDENCIES_TXT"
    do
        if [ -f "$item" ] ; then
            install -v -m 644 "$item" "$ABI_LOG_DIR" || return 1
        fi
    done

    for item in "$BUILD_DIR" "$SOURCE_DIR"
    do
        for item2 in 'config.log' 'compile_commands.json'
        do
            if [ -f "$item/$item2" ] ; then
                install -v -m 644 "$item/$item2" "$ABI_LOG_DIR" || return 1
            fi
        done
    done
}

install_incs() {
    while [ -n "$1" ]
    do
        unset X1
        unset X2
        X1=$(echo "$1" | cut -d: -f1)
        X2=$(echo "$1" | cut -d: -f2)

        [ "$X1" = "$X2" ] && unset X2

        install -v -d         "$ABI_INCLUDE_DIR/$X2" || return 1
        install -v -m 644 $X1 "$ABI_INCLUDE_DIR/$X2" || return 1

        shift
    done
}

install_libs() {
    install -v -d "$ABI_LIBRARY_DIR" || return 1
    for item in $@
    do
        case $item in
            *.a) install -v -m 644 $item "$ABI_LIBRARY_DIR" || return 1 ;;
            *)   install -v -m 755 $item "$ABI_LIBRARY_DIR" || return 1 ;;
        esac
    done
}

install_pcfs() {
    install -v -d        "$ABI_PKGCONF_DIR" &&
    install -v -m 644 $@ "$ABI_PKGCONF_DIR"
}

install_bins() {
    install -v -d        "$ABI_BINARY__DIR" &&
    install -v -m 755 $@ "$ABI_BINARY__DIR"
}

install_mans() {
    for item in $@
    do
        unset NUMBER
        NUMBER=$(echo "$item" | cut -c ${#item}-${#item})
        case $NUMBER in
            [1-8]);;
            *)    die "$item: not a manpage."
        esac
        install -v -d           "$ABI_INSTALL_DIR/share/man/man$NUMBER" &&
        install -v -m 644 $item "$ABI_INSTALL_DIR/share/man/man$NUMBER"
    done
}

install_pc_file() {
    install -v -d "$ABI_PKGCONF_DIR" &&
    cat >         "$ABI_PKGCONF_DIR/$1.pc"
}

install_files() {
    while [ -n "$1" ]
    do
        case $(echo "$1" | cut -d: -f1) in
            *.[1-8]) install_mans "$1" || return 1 ;;
            *.h)     install_incs "$1" || return 1 ;;
            *.a)     install_libs "$1" || return 1 ;;
            *.dylib) install_libs "$1" || return 1 ;;
            *.pc)    install_pcfs "$1" || return 1 ;;
            *)       install_bins "$1" || return 1 ;;
        esac
        shift
    done
}

__show_infomation_of_packages() {
    unset PACKAGE_LIST

    if [ -z "$1" ] ; then
        [ -d "$MY_FORMULA_DIR" ] || __update_formula_repository
        cd "$MY_FORMULA_DIR" || exit 1
        PACKAGE_LIST=$(ls *.sh | sed 's/\.sh//g')
    else
        PACKAGE_LIST=$@
    fi

    unset FIRST
    unset PACKAGE

    for PACKAGE in $PACKAGE_LIST
    do
        if [ "${FIRST-true}" = 'true' ] ; then
            FIRST=false
        else
            echo "============================================================"
        fi
        __show_infomation_of_a_package "$PACKAGE"
    done
}

__show_infomation_of_a_package() {
    ___load_formula_of_a_package "$1"

    echo "name    : $(mark_is_package_installed_or_not $1)"

    if [ -n "$PACKAGE_VERSION" ] ; then
        echo "version : $PACKAGE_VERSION"
    fi

    echo "summary : $PACKAGE_SUMMARY"
    echo "webpage : $PACKAGE_WEBPAGE"

    [ -z "$PACKAGE_DEPENDS" ] || {
        unset DEPENDENCIES

        for dependencyPkgName in $PACKAGE_DEPENDS
        do
            if [ -z "$DEPENDENCIES" ] ; then
                DEPENDENCIES="depends : $(mark_is_package_installed_or_not $dependencyPkgName)"
            else
                DEPENDENCIES="$DEPENDENCIES | $(mark_is_package_installed_or_not $dependencyPkgName)"
            fi
        done

        echo "$DEPENDENCIES"
    }

    echo "src_url : $PACKAGE_SRC_URL"

    case $PACKAGE_SRC_TYPE in
        dir) ;;
        git)
            if [ -d "$PACKAGE_SRC_PATH" ] ; then
                echo "src_cache ${COLOR_PURPLE}==>${COLOR_OFF} $PACKAGE_SRC_PATH"
            else
                echo "src_cache : ${COLOR_RED}Not cached${COLOR_OFF}"
            fi
            ;;
        *)
            if [ -f "$PACKAGE_SRC_PATH" ] ; then
                echo "src_cache ${COLOR_PURPLE}==>${COLOR_OFF} $PACKAGE_SRC_PATH"
            else
                echo "src_cache : ${COLOR_RED}Not cached${COLOR_OFF}"
            fi
    esac

    if is_package_installed "$1" ; then
        echo "installed ${COLOR_PURPLE}==>${COLOR_OFF} $(du -sh "$MY_INSTALL_DIR/$1" | awk '{print $2, $1}')"

        unset I
        unset ABI
        unset ABI_LIST
        unset ABI_LIST_LENGTH

        ABI_LIST=$(__list_abis_of_a_installed_package "$1")
        ABI_LIST_LENGTH=$(list_length $ABI_LIST)

        for ABI in $ABI_LIST
        do
            I=$(expr ${I-0} + 1)
            if [ "$I" -eq "$ABI_LIST_LENGTH" ] ; then
                echo "              └── $(printf "%-25s" "$ABI") $(du -sh "$MY_INSTALL_DIR/$1/$ABI" | awk '{print $1}')"
            else
                echo "              ├── $(printf "%-25s" "$ABI") $(du -sh "$MY_INSTALL_DIR/$1/$ABI" | awk '{print $1}')"
            fi
        done

        die_if_load_installed_log_failed "$1" "$ABI"
        __show_installed_log "$1" "$ABI"
    fi
}

mark_is_package_installed_or_not() {
    if is_package_installed "$1" ; then
        echo "${COLOR_GREEN}$1${COLOR_OFF}"
    else
        echo "${COLOR_RED}$1${COLOR_OFF}"
    fi
}

summary() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_SUMMARY"
    else
        PACKAGE_SUMMARY="$1"
    fi
}

webpage() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_WEBPAGE"
    else
        PACKAGE_WEBPAGE="$1"
    fi
}

src_git() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_SRC_GIT"
    else
        PACKAGE_SRC_GIT="$1"
    fi
}

src_url() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_SRC_URL"
    else
        PACKAGE_SRC_URL="$1"
    fi
}

src_sum() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_SRC_SUM"
    else
        PACKAGE_SRC_SUM="$1"
    fi
}

# set or get build system.
# $1:
# - autogen        require make automake autoconf autoreconf
# - autotools      require make automake autoconf autoreconf
# - configure      require make
# - cmake          require cmake
# - cmake-make     require cmake make
# - cmake-ninja    require cmake ninja
# - meson          require meson ninja
# - make           require make
# - ninja          require ninja
# - cargo          require cargo rustup
# - go             require go
bsystem() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_BUILD_SYSTEM"
    else
        if [ -z "$PACKAGE_BUILD_SYSTEM" ] ; then
            PACKAGE_BUILD_SYSTEM="$@"
        else
            PACKAGE_BUILD_SYSTEM="$PACKAGE_BUILD_SYSTEM $@"
        fi
    fi
}

# set or get source directory.
sourced() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_SOURCE_DIR"
    else
        PACKAGE_SOURCE_DIR="$1"
    fi
}

# set build in source directory, otherwise, build in build directory.
build_in_sourced() {
    PACKAGE_BUILD_IN_SOURCE_DIR=true
}

# set or get version of current building package.
version() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_VERSION"
    else
        PACKAGE_VERSION="$1"
    fi
}

# set or get license of current building package.
license() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_LICENSE"
    else
        if [ -z "$PACKAGE_LICENSE" ] ; then
            PACKAGE_LICENSE="$@"
        else
            PACKAGE_LICENSE="$PACKAGE_LICENSE $@"
        fi
    fi
}

# set or get list of required commands used by current building package.
require() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_REQUIRE"
    else
        if [ -z "$PACKAGE_REQUIRE" ] ; then
            PACKAGE_REQUIRE="$@"
        else
            PACKAGE_REQUIRE="$PACKAGE_REQUIRE $@"
        fi
    fi
}

# set or get list of packages depended by current building package.
depends() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_DEPENDS"
    else
        if [ -z "$PACKAGE_DEPENDS" ] ; then
            PACKAGE_DEPENDS="$@"
        else
            PACKAGE_DEPENDS="$PACKAGE_DEPENDS $@"
        fi
    fi
}

# set or get list of C/C++ definations(#define key value)
# $1:
# - key=value
# - key
cdefine() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_CDEFINE"
    else
        if [ -z "$PACKAGE_CDEFINE" ] ; then
            PACKAGE_CDEFINE="$@"
        else
            PACKAGE_CDEFINE="$PACKAGE_CDEFINE $@"
        fi
    fi
}

# set or get list of linker flags
ldflags() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_LDFLAGS"
    else
        if [ -z "$PACKAGE_LDFLAGS" ] ; then
            PACKAGE_LDFLAGS="$@"
        else
            PACKAGE_LDFLAGS="$PACKAGE_LDFLAGS $@"
        fi
    fi
}

patches() {
    if [ $# -eq 0 ] ; then
        echo "$PACKAGE_PATCHES"
    else
        [ $# -lt 2 ]             && die "the number of arguments of patches command at least 2."
        [ $(expr $# % 2) -eq 1 ] && die "the number of arguments of patches command must be even integer."

        PACKAGE_PATCHES="$@"

        while [ -n "$1" ]
        do
            case $1 in
                *.diff)    PATCH_CONTENT_TYPE=patch  ; require patch     ;;
                *.patch)   PATCH_CONTENT_TYPE=patch  ; require patch     ;;
                *.zip)     PATCH_CONTENT_TYPE=zip    ; require unzip     ;;
                *.tar.xz)  PATCH_CONTENT_TYPE=tar.xz ; require tar xz    ;;
                *.tar.gz)  PATCH_CONTENT_TYPE=tar.gz ; require tar gzip  ;;
                *.tar.lz)  PATCH_CONTENT_TYPE=tar.lz ; require tar lzip  ;;
                *.tar.bz2) PATCH_CONTENT_TYPE=tar.bz2; require tar bzip2 ;;
                *.tgz)     PATCH_CONTENT_TYPE=tar.gz ; require tar gzip  ;;
                *.txz)     PATCH_CONTENT_TYPE=tar.xz ; require tar xz    ;;
                *)  die "$1 : extension isn't recognized. the supported extensions are .diff .patch .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
            esac

            [ ${#2} -eq 64 ] || die "$2 is not sha256sum. the length of sha256sum must be 64."

            shift 2
        done
    fi
}

ios_ios() {
    PACKAGE_IOS_IOS=true
}





___load_formula_of_a_package() {
    die_if_package_is_not_available "$1"

    unset PACKAGE_NAME
    unset PACKAGE_SUMMARY
    unset PACKAGE_WEBPAGE
    unset PACKAGE_SRC_GIT
    unset PACKAGE_SRC_URL
    unset PACKAGE_SRC_SUM
    unset PACKAGE_SRC_NAME
    unset PACKAGE_SRC_PATH
    unset PACKAGE_SRC_TYPE
    unset PACKAGE_VERSION
    unset PACKAGE_LICENSE
    unset PACKAGE_PATCHES

    unset PACKAGE_BUILD_SYSTEM

    unset PACKAGE_REQUIRE

    unset PACKAGE_DEPENDS

    unset PACKAGE_CDEFINE
    unset PACKAGE_LDFLAGS

    unset PACKAGE_IOS_IOS


    # relative to $WORKING_DIR, which contains configure, CMakeLists.txt, etc.
    unset PACKAGE_SOURCE_DIR
    unset PACKAGE_BUILD_IN_SOURCE_DIR

    unset -f build0
    unset -f prepare
    unset -f build
    unset -f build_configed

    PACKAGE_REQUIRE='tree'

    PACKAGE_NAME="$1"

    FORMULA_FILE_PATH="$MY_FORMULA_DIR/$PACKAGE_NAME.sh"

    . "$FORMULA_FILE_PATH" || die "$FORMULA_FILE_PATH is broken."

    [ -z "$PACKAGE_SUMMARY" ] && die "summary command must be invoked in $FORMULA_FILE_PATH"
    [ -z "$PACKAGE_WEBPAGE" ] && die "webpage command must be invoked in $FORMULA_FILE_PATH"
    [ -z "$PACKAGE_SRC_URL" ] && PACKAGE_SRC_URL=$PACKAGE_SRC_GIT
    [ -z "$PACKAGE_SRC_URL" ] && die "src_url or src_git command must be invoked in $FORMULA_FILE_PATH"















    case $PACKAGE_SRC_URL in
        dir://*)   PACKAGE_SRC_TYPE=dir ;;
        *.git)     PACKAGE_SRC_TYPE=git    ; require git ;;
        *.zip)     PACKAGE_SRC_TYPE=zip    ; require curl unzip ;;
        *.tar.xz)  PACKAGE_SRC_TYPE=tar.xz ; require curl tar xz ;;
        *.tar.gz)  PACKAGE_SRC_TYPE=tar.gz ; require curl tar gzip ;;
        *.tar.lz)  PACKAGE_SRC_TYPE=tar.lz ; require curl tar lzip ;;
        *.tar.bz2) PACKAGE_SRC_TYPE=tar.bz2; require curl tar bzip2 ;;
        *.tgz)     PACKAGE_SRC_TYPE=tar.gz ; require curl tar gzip ;;
        *.txz)     PACKAGE_SRC_TYPE=tar.xz ; require curl tar xz ;;
        *.c)       PACKAGE_SRC_TYPE=c      ; require curl ;;
        *.cc)      PACKAGE_SRC_TYPE=cxx    ; require curl ;;
        *.cxx)     PACKAGE_SRC_TYPE=cxx    ; require curl ;;
        *.cpp)     PACKAGE_SRC_TYPE=cxx    ; require curl ;;
        *)  die "$PACKAGE_SRC_URL : extension isn't recognized. the supported extensions are .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    case $PACKAGE_SRC_TYPE in
        dir)
            if command -v cut > /dev/null ; then
                PACKAGE_SRC_PATH=$(echo $PACKAGE_SRC_URL | cut -c7-${#PACKAGE_SRC_URL})
            elif command -v awk > /dev/null ; then
                PACKAGE_SRC_PATH=$(echo $PACKAGE_SRC_URL | awk '{print(substr($0, 7))}')
            else
                PACKAGE_SRC_PATH=$(expr substr "$PACKAGE_SRC_URL" 7 ${#PACKAGE_SRC_URL})
            fi
            [ -d "$PACKAGE_SRC_PATH" ] || die "src_url argument point to dir is not exist."
            ;;
        git)
            PACKAGE_SRC_NAME="$PACKAGE_NAME.git"
            PACKAGE_SRC_PATH="$MY_CACHED_DIR/$PACKAGE_SRC_NAME"
            ;;
        *)
            if [ -z "$PACKAGE_SRC_SUM" ] ; then
                die "src_sum command is not invoked in $FORMULA_FILE_PATH"
            fi
            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(basename "$PACKAGE_SRC_URL" | awk '{str = tolower($0); gsub(".tar.xz", "", str); gsub(".tar.gz", "", str); gsub(".tar.lz", "", str); gsub(".tar.bz2", "", str); gsub(".tgz", "", str); gsub(".txz", "", str); gsub(".zip", "", str); print(str)}' | awk -F- '{print $NF}')"
                if [ -z "$PACKAGE_VERSION" ] ; then
                    die "version command is not invoked in $FORMULA_FILE_PATH"
                else
                    case $PACKAGE_VERSION in
                        v*) if command -v cut > /dev/null ; then
                                PACKAGE_VERSION=$(echo $PACKAGE_VERSION | cut -c2-${#PACKAGE_VERSION})
                            elif command -v awk > /dev/null ; then
                                PACKAGE_VERSION=$(echo $PACKAGE_VERSION | awk '{print(substr($0, 2))}')
                            else
                                PACKAGE_VERSION=$(expr substr "$PACKAGE_VERSION" 2 ${#PACKAGE_VERSION})
                            fi
                    esac
                fi
            fi
            PACKAGE_SRC_NAME="$PACKAGE_NAME-$PACKAGE_VERSION.$PACKAGE_SRC_TYPE"
            PACKAGE_SRC_PATH="$MY_CACHED_DIR/$PACKAGE_SRC_NAME"
    esac

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            autogen)     require perl m4 autoconf automake make ;;
            autotools)   require perl m4 autoconf automake make ;;
            configure)   require make ;;
            ndk-build)   require make ;;
            cmake)       require cmake make  ;;
            cmake-make)  require cmake make  ;;
            cmake-ninja) require cmake ninja ;;
            meson)       require meson ninja ;;
            make)        require make  ;;
            ninja)       require ninja ;;
            cargo)       require cargo rustup ;;
            go)          require go ;;
        esac
    done
}

__json_available_packages() {
    unset PACKAGE
    unset STR
    unset I
    unset AVAILABLE_PACKAGES
    unset AVAILABLE_PACKAGES_LENGTH

    AVAILABLE_PACKAGES=$(__list_available_packages)
    AVAILABLE_PACKAGES_LENGTH=$(list_length $AVAILABLE_PACKAGES)

    for item in $AVAILABLE_PACKAGES
    do
        I=$(expr ${I-0} + 1)

        ___load_formula_of_a_package "$item"

        if [ "$I" -eq 1 ] ; then
            echo "["
        fi

        if [ "$I" -eq "$AVAILABLE_PACKAGES_LENGTH" ] ; then
            printf "{\"name\":\"%s\",\"version\":\"%s\",\"summary\":\"%s\",\"license\":\"%s\",\"webpage\":\"%s\",\"bsystem\":\"%s\"}]\n"  "$PACKAGE_NAME" "$PACKAGE_VERSION" "$PACKAGE_SUMMARY" "$PACKAGE_LICENSE" "$PACKAGE_WEBPAGE" "$PACKAGE_BUILD_SYSTEM"
        else
            printf "{\"name\":\"%s\",\"version\":\"%s\",\"summary\":\"%s\",\"license\":\"%s\",\"webpage\":\"%s\",\"bsystem\":\"%s\"},\n" "$PACKAGE_NAME" "$PACKAGE_VERSION" "$PACKAGE_SUMMARY" "$PACKAGE_LICENSE" "$PACKAGE_WEBPAGE" "$PACKAGE_BUILD_SYSTEM"
        fi
    done
}

install_installed_log() {
    cat > "$ABI_LOG_DIR/installed.log.txt" <<EOF
installed_datetime=$TIMESTAMP_UNIX
installed_pkg_version=$PACKAGE_VERSION
min_platform_version=$PLATFORM_MIN_VERSION
using_xcode_version='$XCODE_VERSION'
EOF
}

die_if_load_installed_log_failed() {
    die_if_package_is_not_installed "$1"
    die_if_abi_____is_not_supported "$2"

    INSTALLED_LOG_FILE_PATH="$MY_INSTALL_DIR/$1/$2/log/installed.log.txt"

    unset installed_datetime
    unset installed_pkg_version
    unset min_platform_version
    unset using_xcode_version
    
    . "$INSTALLED_LOG_FILE_PATH" || die "$INSTALLED_LOG_FILE_PATH is broken."
}

__show_installed_log() {
    echo "installed_datetime    : $(format_unix_timestamp $installed_datetime '+%Y/%m/%d %H:%M:%S')"
    echo "installed_pkg_version : $installed_pkg_version"
    echo "min platform version  : $min_platform_version"
    echo "using xcode  version  : $using_xcode_version"
}

__config_this_build_variables() {
    die_if_package_is_not_available "$1"

    BUILD_FOR_ARCH=$(echo_arch_by_abi "$BUILD_FOR_ABI")
    BUILD_FOR_TARGET=$(echo_target_by_arch "$BUILD_FOR_ARCH")

    PLATFORM_MIN_VERSION=$(echo "$BUILD" | cut -d: -f2)
    BUILD_FOR_PLATFORM=$(echo "$BUILD_FOR_ABI" | cut -d/ -f1)
    SYSROOT="$DEVELOPER_DIR/Platforms/${BUILD_FOR_PLATFORM}.platform/Developer/SDKs/${BUILD_FOR_PLATFORM}.sdk"
    platformLower="$(printf "$BUILD_FOR_PLATFORM" | awk '{print(tolower($0))}')"

    for tool in $(list_tools_in_the_toolchain)
    do
        if [ "$tool" = 'cpp' ] ; then
            CPP="$CC -E"
        else
            eval $(echo "$tool" | tr a-z A-Z)=$(echo_path_of_tool_in_the_toolchain "$tool")
        fi
    done

    SYSTEM_INCLUDE_DIR="$SYSROOT/usr/include"
    SYSTEM_LIBRARY_DIR="$SYSROOT/usr/lib"

      CFLAGS="-isysroot $SYSROOT -Qunused-arguments -arch $BUILD_FOR_ARCH -Os -pipe -m${platformLower}-version-min=$PLATFORM_MIN_VERSION"
    CPPFLAGS="-isysroot $SYSROOT -Qunused-arguments"
     LDFLAGS="-isysroot $SYSROOT -arch $BUILD_FOR_ARCH -m${platformLower}-version-min=$PLATFORM_MIN_VERSION"

    for item in $PACKAGE_CDEFINE
    do
        CPPFLAGS="$CPPFLAGS -D$item"
    done

    if [ -n "$PACKAGE_LDFLAGS" ] ; then
        LDFLAGS="$LDFLAGS $PACKAGE_LDFLAGS"
    fi

    case $BUILD_FOR_ARCH in
        armv7*) CPPFLAGS="$CPPFLAGS -D__arm__"   ;;
        arm64*) CPPFLAGS="$CPPFLAGS -D__arm64__" ;;
        i386)   CPPFLAGS="$CPPFLAGS -D__i386__"  ;;
        x86_64) CPPFLAGS="$CPPFLAGS -D__x86_64__";;
    esac

    # https://www.freedesktop.org/wiki/Software/pkg-config/CrossCompileProposal
    unset PKG_CONFIG_LIBDIR
    unset PKG_CONFIG_PATH

    for PACKAGE in $DEPENDENCY_PACKAGE_LIST
    do
        PKG=$(printf "$PACKAGE" | tr '-' '_')
        
        ABI_INSTALL_DIR="$MY_INSTALL_DIR/$PACKAGE/$BUILD_FOR_ABI"
        ABI_INCLUDE_DIR="$ABI_INSTALL_DIR/include"
        ABI_LIBRARY_DIR="$ABI_INSTALL_DIR/lib"
        ABI_PKGCONF_DIR="$ABI_INSTALL_DIR/lib/pkgconfig"

        eval "${PKG}_INSTALL_DIR='$ABI_INSTALL_DIR'"
        eval "${PKG}_INCLUDE_DIR='$ABI_INCLUDE_DIR'"
        eval "${PKG}_LIBRARY_DIR='$ABI_LIBRARY_DIR'"

        CPPFLAGS="-I$ABI_INCLUDE_DIR $CPPFLAGS"
         LDFLAGS="-L$ABI_LIBRARY_DIR $LDFLAGS"

        if [ -z "$PKG_CONFIG_PATH" ] ; then
            PKG_CONFIG_PATH="$ABI_PKGCONF_DIR"
        else
            PKG_CONFIG_PATH="$PKG_CONFIG_PATH:$ABI_PKGCONF_DIR"
        fi
    done

    if [ "$VERBOSE" = 'true' ] ; then
        CFLAGS="$CFLAGS -v"
    fi

    CXXFLAGS="$CFLAGS"

    ABI_INSTALL_DIR="$PKG_INSTALL_DIR/$BUILD_FOR_ABI"
    ABI_BINARY__DIR="$ABI_INSTALL_DIR/bin"
    ABI_INCLUDE_DIR="$ABI_INSTALL_DIR/include"
    ABI_LIBRARY_DIR="$ABI_INSTALL_DIR/lib"
    ABI_PKGCONF_DIR="$ABI_INSTALL_DIR/lib/pkgconfig"

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            cargo)
                for supportedTarget in $(__list_supported_targets)
                do
                    supportedTarget=$(echo "$supportedTarget" | sed 's/armv7a/armv7/')
                    for installedTarget in $(rustup target list | grep installed | cut -d " " -f1)
                    do
                        [ "$supportedTarget" = "$installedTarget" ] && break
                    done
                    [ "$supportedTarget" = "$installedTarget" ] || {
                        rustup target add "$supportedTarget" || return 1
                    }
                done

                CARGO_TARGET=$(echo "$BUILD_FOR_TARGET" | sed 's/armv7a/armv7/')

                # https://doc.rust-lang.org/cargo/reference/environment-variables.html
                CARGO_TARGET_XXX=$(echo "$CARGO_TARGET" | tr a-z A-Z | tr - _)

                eval export CARGO_TARGET_${CARGO_TARGET_XXX}_AR=$AR
                eval export CARGO_TARGET_${CARGO_TARGET_XXX}_LINKER=$CC
                ;;
               go)
                # https://golang.org/doc/install/source#environment
                export CGO_ENABLED=1
                export CGO_CFLAGS="$CFLAGS"
                export CGO_CXXFLAGS="$CXXFLAGS"
                export CGO_CPPFLAGS="$CPPFLAGS"
                export CGO_LDFLAGS="$LDFLAGS"

                export GO111MODULE="auto"
                export GOPROXY=https://goproxy.cn

                export GOOS=ios

                case $BUILD_FOR_ARCH in
                    armv7*)  export GOARCH=arm   ;;
                    arm64*)  export GOARCH=arm64 ;;
                    i386)    export GOARCH=386   ;;
                    x86_64)  export GOARCH=amd64 ;;
                esac
                ;;
        esac
    done

    if [ -n "$NATIVE_BUILD_DIR" ] && [ -d "$NATIVE_BUILD_DIR/output/bin" ] ; then
        export PATH="$NATIVE_BUILD_DIR/output/bin:$PATH"
    fi
}

__printf_this_build_variables() {
    echo
    echo "INSTALLING_PACKAGE= $1"
    echo
    echo "   TIMESTAMP_UNIX = $TIMESTAMP_UNIX"
    echo
    echo " BUILD_ROUND_NUM  = $BUILD_ROUND_NUM"
    echo
    echo " BUILD_MACHINE_OS = $BUILD_MACHINE_OS_TYPE-$BUILD_MACHINE_OS_ARCH"
    echo
    echo " BUILD_FOR_TARGET = $BUILD_FOR_TARGET"
    echo " BUILD_FOR_ARCH   = $BUILD_FOR_ARCH"
    echo " BUILD_FOR_ABI    = $BUILD_FOR_ABI"
    echo
    echo "PLATFORM_MIN_VERSION = $PLATFORM_MIN_VERSION"
    echo
    echo "    XCODE_VERSION = $XCODE_VERSION"
    echo "    DEVELOPER_DIR = $DEVELOPER_DIR"
    echo
    echo "          SYSROOT = $SYSROOT"
    echo "SYSTEM_INCLUDE_DIR= $SYSTEM_INCLUDE_DIR"
    echo "SYSTEM_LIBRARY_DIR= $SYSTEM_LIBRARY_DIR"
    echo
    echo "TOOLCHAIN_BIN_DIR = $TOOLCHAIN_BIN_DIR"

    for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
    do
        eval export $TOOL=\"\$$TOOL\"
        printf "%17s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
    done

    echo

    for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
    do
        eval export ${TOOL}_FOR_BUILD="\$${TOOL}_FOR_BUILD"
        printf "%17s = %s\n" "${TOOL}_FOR_BUILD" "$(eval echo \$${TOOL}_FOR_BUILD)"
    done

    echo

    for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
    do
        eval export $FLAG=\"\$$FLAG\"
        printf "\n%17s = " "$FLAG"
        FIRST=true
        for item in $(eval echo \$$FLAG | tr ':' ' ')
        do
            if [ "$FIRST" = 'true' ] ; then
                FIRST=false
                echo "$item"
            else
                echo "                    $item"
            fi
        done
    done

    echo

    printf "\n%17s = " PATH
    FIRST='true'
    for item in $(echo "$PATH" | tr ':' ' ')
    do
        if [ "$FIRST" = 'true' ] ; then
            FIRST='false'
            echo "$item"
        else
            echo "                    $item"
        fi
    done

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            cargo)
                echo
                env | grep CARGO
                echo
                ;;
               go)
                echo
                echo "      GO111MODULE = $GO111MODULE"
                echo "      GOPROXY     = $GOPROXY"
                echo
                echo "     CGO_ENABLED  = $CGO_ENABLED"
                echo "     CGO_CFLAGS   = $CGO_CFLAGS"
                echo "     CGO_CXXFLAGS = $CGO_CXXFLAGS"
                echo "     CGO_CPPFLAGS = $CGO_CPPFLAGS"
                echo "     CGO_LDFLAGS  = $CGO_LDFLAGS"
                echo
                echo "           GOOS   = $GOOS"
                echo "           GOARCH = $GOARCH"
                ;;
        esac
    done

    echo
    echo "      WORKING_DIR = $WORKING_DIR"
    echo "       SOURCE_DIR = $SOURCE_DIR"
    echo "        EMPTY_DIR = $EMPTY_DIR"

    [ -n "$NATIVE_BUILD_DIR" ] &&
    echo " NATIVE_BUILD_DIR = $NATIVE_BUILD_DIR"

    echo "        BUILD_DIR = $BUILD_DIR"
    echo "              PWD = $PWD"
    echo
    echo "  PKG_INSTALL_DIR = $PKG_INSTALL_DIR"
    echo "  ABI_INSTALL_DIR = $ABI_INSTALL_DIR"
    echo "  ABI_BINARY__DIR = $ABI_BINARY__DIR"
    echo "  ABI_INCLUDE_DIR = $ABI_INCLUDE_DIR"
    echo "  ABI_LIBRARY_DIR = $ABI_LIBRARY_DIR"
    echo "  ABI_PKGCONF_DIR = $ABI_PKGCONF_DIR"
    echo

    if [ "$VERBOSE" = 'true' ] ; then
        echo
        run export -p
        echo
    fi
}

config_url() {
    echo "http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=$1;hb=HEAD"
}

# run in a subshell
configure() {
    if [ -z "$CONFIG_XX_UPDATED" ] ; then
        CONFIG_XX_UPDATED=true
        # https://www.gnu.org/software/gettext/manual/html_node/config_002eguess.html
        # https://git.savannah.gnu.org/cgit/config.git/tree/
        for item in config.sub config.guess
        do
            for file in $(find "$SOURCE_DIR" -name "$item")
            do
                CONFIG_XX="$MY_CACHED_DIR/config/$item"
                if [ ! -f "$CONFIG_XX" ] ; then
                    fetch "$(config_url "$item")" --output-path="$CONFIG_XX" || return 1
                    run chmod a+x "$CONFIG_XX" || return 1
                    if [ "$item" = 'config.sub' ] ; then
                        sed_in_place 's/arm64-*/arm64-*|arm64e-*/g' "$CONFIG_XX" || return 1
                    fi
                fi
                run cp -f "$CONFIG_XX" "$file" || return 1
            done
        done
    fi

    if [ "$STATE_NUM" -eq 9 ] && [ "$STATE_MESSAGE" = 'build for build-machine' ] ; then
        if run "$SOURCE_DIR"/configure \
            --prefix="$NATIVE_BUILD_DIR/output" \
            $@ ; then
            echo
        else
            if [ -f "$BUILD_DIR/config.log" ] ; then
                run cat "$BUILD_DIR/config.log"
            elif [ -f "$SOURCE_DIR/config.log" ] ; then
                run cat "$SOURCE_DIR/config.log"
            fi
            return 1
        fi
    else
        if run "$SOURCE_DIR"/configure \
            --host="\"$BUILD_FOR_TARGET\"" \
            --prefix="\"$ABI_INSTALL_DIR\"" \
            --disable-option-checking \
            --disable-rpath \
            --disable-debug \
            --disable-nls\
            --enable-largefile \
            --enable-static \
            --enable-shared \
            CC="\"$CC\"" \
            CFLAGS="\"$CFLAGS\"" \
            CXX="\"$CXX\"" \
            CXXFLAGS="\"$CXXFLAGS\"" \
            CPP="\"$CPP\"" \
            CPPFLAGS="\"$CPPFLAGS\"" \
            LDFLAGS="\"$LDFLAGS\"" \
            AR="\"$AR\"" \
            RANLIB="\"$RANLIB\"" \
            PKG_CONFIG="\"$PKG_CONFIG\"" \
            PKG_CONFIG_PATH="\"$PKG_CONFIG_PATH\"" \
            PKG_CONFIG_LIBDIR="\"\"" \
            CC_FOR_BUILD="\"$CC_FOR_BUILD\"" \
            $@ ; then
            echo
        else
            if [ -f "$BUILD_DIR/config.log" ] ; then
                run cat "$BUILD_DIR/config.log"
            elif [ -f "$SOURCE_DIR/config.log" ] ; then
                run cat "$SOURCE_DIR/config.log"
            fi
            return 1
        fi
    fi

    if [ "$VERBOSE" = 'true' ] ; then
        for Makefile in $(find "$SOURCE_DIR" -name Makefile)
        do
            sed_in_place 's|\t@|\t|g'     "$Makefile" || return 1
            sed_in_place 's|@echo|echo|g' "$Makefile" || return 1
        done
        unset Makefile
    fi

    make clean &&
    make       &&
    make install
}

make() {
    if [ -z "$MAKE" ] ; then
        MAKE="command make"
    fi
    info "$MAKE $MAKEFLAGS $*"
    eval "$MAKE $MAKEFLAGS $*"
}

# https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling
# https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html
# https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
# https://cmake.org/cmake/help/latest/command/enable_testing.html?highlight=build_testing
# run in a subshell
cmake() {
    cat > "$BUILD_DIR/toolchain.cmake" <<EOF
set(CMAKE_SYSTEM_NAME Darwin)
set(CMAKE_SYSTEM_PROCESSOR $BUILD_FOR_ARCH)

set(CMAKE_ASM_COMPILER $AS)
set(CMAKE_ASM_FLAGS "-arch $BUILD_FOR_ARCH")

set(CMAKE_C_COMPILER "$CC")
set(CMAKE_C_FLAGS "$CFLAGS $CPPFLAGS")

set(CMAKE_CXX_COMPILER "$CXX")
set(CMAKE_CXX_FLAGS "$CXXFLAGS $CPPFLAGS")

set(CMAKE_AR "$AR")
set(CMAKE_RANLIB "$RANLIB")

set(CMAKE_NM "$NM")
set(CMAKE_STRIP "$STRIP")

set(CMAKE_OSX_SYSROOT "$SYSROOT")
set(CMAKE_OSX_ARCHITECTURES "$BUILD_FOR_ARCH")
EOF
    run "$CMAKE" \
    -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
    -DCMAKE_VERBOSE_MAKEFILE=ON \
    -DCMAKE_COLOR_MAKEFILE=ON \
    -DCMAKE_TOOLCHAIN_FILE="$BUILD_DIR/toolchain.cmake" \
    -DCMAKE_PREFIX_PATH="$MY_INSTALL_DIR" \
    -DCMAKE_FIND_ROOT_PATH="$MY_INSTALL_DIR" \
    -DCMAKE_INSTALL_PREFIX="$ABI_INSTALL_DIR" \
    -DCMAKE_BUILD_TYPE=Release \
    -DCMAKE_OSX_ARCHITECTURES="$BUILD_FOR_ARCH" \
    -DBUILD_SHARED_LIBS=OFF \
    -DBUILD_TESTING=OFF \
    -G "\"Unix Makefiles\"" \
    -Wno-dev \
    -S "$SOURCE_DIR" \
    -B "$BUILD_DIR" $@ &&
    make $MAKEFLAGS -C "$BUILD_DIR" &&
    make $MAKEFLAGS -C "$BUILD_DIR" install
}

# https://mesonbuild.com/Cross-compilation.html
# run in a subshell
meson() {
    case $BUILD_FOR_ARCH in
        armv7*)
            HOST_MACHINE_CPU_FAMILY='arm'
            HOST_MACHINE_CPU_NAME="$BUILD_FOR_ARCH"
            ;;
        arm64*)
            HOST_MACHINE_CPU_FAMILY='aarch64'
            HOST_MACHINE_CPU_NAME="$BUILD_FOR_ARCH"
            ;;
        i386)
            HOST_MACHINE_CPU_FAMILY='x86'
            HOST_MACHINE_CPU_NAME="$BUILD_FOR_ARCH"
            ;;
        x86_64)
            HOST_MACHINE_CPU_FAMILY='x86_64'
            HOST_MACHINE_CPU_NAME="$BUILD_FOR_ARCH"
            ;;
    esac

    cat >> "$BUILD_DIR/cross-file" <<EOF
[host_machine]
system = 'darwin'
endian = 'little'
cpu_family = '$HOST_MACHINE_CPU_FAMILY'
cpu = '$HOST_MACHINE_CPU_NAME'

[binaries]
c = '$CC'
cpp = '$CXX'
ar = '$AR'
strip = '$STRIP'
cmake = '$CMAKE'
pkgconfig = '$PKG_CONFIG'

[properties]
c_args = $(to_meson_array $CFLAGS $CPPFLAGS)
c_link_args = $(to_meson_array $LDFLAGS)
cpp_args = $(to_meson_array $CXXFLAGS $CPPFLAGS)
cpp_link_args = $(to_meson_array $LDFLAGS)
EOF
    run "$MESON" setup \
        --prefix="$ABI_INSTALL_DIR" \
        --buildtype=release \
        --backend=ninja \
        --pkg-config-path="$PKG_CONFIG_PATH" \
        --build.pkg-config-path="$PKG_CONFIG_PATH_FOR_BUILD" \
        --cross-file="$BUILD_DIR/cross-file" \
        $@ "$BUILD_DIR" "$SOURCE_DIR" &&
    {
        if command -v build_configed > /dev/null ; then
            build_configed
        fi
    } &&
    run ninja -C "$BUILD_DIR" install
}

to_meson_array() {
    RESULT="[''"
    for item in $@
    do
        RESULT="$RESULT, '$item'"
    done
    RESULT="$RESULT]"
    echo "$RESULT"
}

########################################################################

die_if_rule_is_not_available() {
    [ -z "$1" ] && die "please specify a rule name."
    [ -f "$MY_HOME_DIR/rules/$1" ] || die "$1 : rule is not exist."
}

die_if_rule_is_already_exist() {
    [ -z "$1" ] && die "please specify a rule name."
    [ -f "$MY_HOME_DIR/rules/$1" ] && die "$1 : rule is already exist."
}

____view_a_rule() {
    die_if_rule_is_not_available "$1"

    if command -v bat > /dev/null ; then
        bat "$MY_HOME_DIR/rules/$1"
    else
        cat "$MY_HOME_DIR/rules/$1"
    fi    
}

____edit_a_rule() {
    die_if_rule_is_not_available "$1"

    [ -z "$EDITOR" ] &&
    EDITOR=$(command -v nvim) ||
    EDITOR=$(command -v vim) ||
    EDITOR=$(command -v vi) ||
    EDITOR=$(command -v open) ||
    die "please set EDITOR environment variable."

    "$EDITOR" "$MY_HOME_DIR/rules/$1"

    VERBOSE=true
    resolve_a_rule "$1"
}

__create_a_rule() {
    die_if_rule_is_already_exist "$1"

    cat > "$MY_HOME_DIR/rules/$1" <<EOF
# please comment or remove the line you don't want.

# AppleTVOS        : 9.0  : all
# AppleTVSimulator : 9.0  : all
# MacOSX           : 10.6 : all
# WatchOS          : 2.0  : all
# WatchSimulator   : 2.0  : all
# iPhoneOS         : 8.0  : all
# iPhoneSimulator  : 8.0  : all
EOF
    ____edit_a_rule "$1"
}

__delete_a_rule() {
    die_if_rule_is_not_available "$1"

    [ "$1" = 'default' ] && die "default rule can not be deleted."

    if rm "$MY_HOME_DIR/rules/$1" ; then
        success "delete $1 rule success."
    else
        die "delete $1 rule failed."
    fi
}

__rename_a_rule() {
    die_if_rule_is_not_available "$1"
    die_if_rule_is_already_exist "$2"

    [ "$1" = 'default' ] && die "default rule can not be renamed to another."

    if mv -v "$MY_HOME_DIR/rules/$1" "$MY_HOME_DIR/rules/$2" ; then
        success "rename rule $1 -> $2 success."
    else
        die "rename rule $1 -> $2 failed."
    fi
}

resolve_a_rule() {
    die_if_rule_is_not_available "$1"

    unset BUILD_LIST

    unset BUILD_FOR_PLATFORM
    unset PLATFORM_MIN_VERSION
    unset BUILD_FOR_ARCH

    while read line
    do
        line=$(echo "$line" | sed 's/[[:space:]]//g')

        [ -z "$line" ] && continue
        echo "$line" | grep -q '^#' && continue

        BUILD_FOR_PLATFORM=$(echo "$line" | cut -d: -f1)
        PLATFORM_MIN_VERSION=$(echo "$line" | cut -d: -f2)
        BUILD_FOR_ARCH=$(echo "$line" | cut -d: -f3)

        if [ "$VERBOSE" = 'true' ] ; then
            echo "BUILD_FOR_PLATFORM=$BUILD_FOR_PLATFORM"
            echo "PLATFORM_MIN_VERSION=$PLATFORM_MIN_VERSION"
            echo "BUILD_FOR_ARCH=$BUILD_FOR_ARCH"
            echo '---------------------------------'
        fi
        
        [ -z "$PLATFORM_MIN_VERSION" ] && {
            PLATFORM_MIN_VERSION=$(get_supported_min_version "$BUILD_FOR_PLATFORM")
        }
        
        if [ -z "$BUILD_FOR_ARCH" -o "$BUILD_FOR_ARCH" = 'all' ] ; then
            for BUILD_FOR_ARCH in $(list_supported_archs "$BUILD_FOR_PLATFORM")
            do
                if [ -z "$BUILD_LIST" ]; then
                    BUILD_LIST="$BUILD_FOR_PLATFORM/$BUILD_FOR_ARCH:$PLATFORM_MIN_VERSION"
                else
                    BUILD_LIST=$(printf "%s\n%s" "$BUILD_LIST" "$BUILD_FOR_PLATFORM/$BUILD_FOR_ARCH:$PLATFORM_MIN_VERSION")
                fi
            done
        else
            if [ -z "$BUILD_LIST" ]; then
                BUILD_LIST="$BUILD_FOR_PLATFORM/$BUILD_FOR_ARCH:$PLATFORM_MIN_VERSION"
            else
                BUILD_LIST=$(printf "%s\n%s" "$BUILD_LIST" "$BUILD_FOR_PLATFORM/$BUILD_FOR_ARCH:$PLATFORM_MIN_VERSION")
            fi
        fi
    done < "$MY_HOME_DIR/rules/$1"

    unset BUILD_FOR_PLATFORM
    unset PLATFORM_MIN_VERSION
    unset BUILD_FOR_ARCH

    if [ "$VERBOSE" = 'true' ] ; then
        for item in $BUILD_LIST
        do
            echo "$item"
        done
    fi
}

inject_stub_system() {
    cat > "$SOURCE_DIR/stub-system.c" <<EOF
#ifndef SYSTEM_STUB_C
#define SYSTEM_STUB_C

#include <stdlib.h>
#include <unistd.h>
#include <spawn.h>
#include <sys/wait.h>

extern char **environ;

#ifdef __cplusplus
    extern "C" {
#endif

__attribute__((unused))
static int stub_system(char* cmd) {
    char argv0[] = "sh";
    char argv1[] = "-c";
    char* const argv[4] = {argv0, argv1, cmd, NULL};
    pid_t pid;
    int status;
    status = posix_spawn(&pid, "/bin/sh", NULL, NULL, argv, environ);
    if (0 == status) {
        return waitpid(pid, &status, 0);
    }
    return status;
}

#define system(x) stub_system(x)

#ifdef __cplusplus
    }
#endif

#endif
EOF
    for item in $@
    do
        echo "inject $SOURCE_DIR/stub-system.c -> $item"
        cat "$SOURCE_DIR/stub-system.c" "$item" > "$item.bak" || return 1
        mv "$item.bak" "$item" || return 1
    done
}

include_stub_system() {
    if [ "$BUILD_ROUND_NUM" -eq 1 ] ; then
        gen_stub_system
    fi
    export CPPFLAGS="$CPPFLAGS -include $SOURCE_DIR/stub-system.c"
}

check_prerequisites() {
    DEVELOPER_DIR="$(xcode-select -p)"

    [ -z "$DEVELOPER_DIR" ] && die "please set and export DEVELOPER_DIR=DIR environment variable, then try again."
    [ -d "$DEVELOPER_DIR" ] || die "DEVELOPER_DIR=$DEVELOPER_DIR directory is not exist."

    TOOLCHAIN_BIN_DIR="$DEVELOPER_DIR/Toolchains/XcodeDefault.xctoolchain/usr/bin"

    XCODE_VERSION=$(system_profiler SPDeveloperToolsDataType | grep Version | head -n 1 | cut -d: -f2 | sed 's/^ //g')
}

__list_rules() {
    ls "$MY_HOME_DIR/rules"
}

list_supported_platforms() {
    [ -z "$DEVELOPER_DIR" ] && check_prerequisites
    ls "$DEVELOPER_DIR/Platforms" | sed 's/.platform//g'
    #print_list AppleTVOS AppleTVSimulator MacOSX iPhoneOS iPhoneSimulator WatchOS WatchSimulator
}

list_supported_archs() {
    if [ -z "$1" ] ; then
        for PLATFORM in $(list_supported_platforms)
        do
            printf "%-16s : $(list_supported_archs "$PLATFORM")\n" "$PLATFORM"
        done
    else
        case $1 in
            iPhoneOS)   echo "armv7 armv7s arm64 arm64e";;
            WatchOS)    echo "arm64_32 armv7k";;
            AppleTVOS)  echo "arm64";;
            MacOSX)     echo "x86_64";;
            *Simulator) echo "x86_64 i386";;
            --table)
                cat <<EOF
┌───────────┬───────────────────────────┐
│ platform  │ arch                      │
│           │                           │
│ AppleTVOS │ arm64                     │
│ WatchOS   │ arm64_32 armv7k           │
│ iPhoneOS  │ armv7 armv7s arm64 arm64e │
│ MacOSX    │ x86_64                    │
│ *Simulator│ x86_64 i386               │
└───────────┴───────────────────────────┘
EOF
;;
            *)      die "$1 : platform isn't supported."
        esac
    fi
}

__list_supported_abis() {
    for PLATFORM in $(list_supported_platforms)
    do
        for ARCH in $(list_supported_archs "$PLATFORM")
        do
            echo "$PLATFORM/$ARCH"
        done
    done
}

list_supported_targets() {
    for ARCH in armv7 armv7s arm64 arm64e arm64_32 armv7k x86_64 i386
    do
        echo_target_by_arch "$ARCH"
    done
}

echo_arch_by_abi() {
    echo "$1" | cut -d/ -f2
}

echo_target_by_arch() {
    if [ 'arm64' = "$1" ] ; then
        if [ "$PACKAGE_IOS_IOS" = 'true' ] ; then
            echo 'aarch64-apple-ios'
        else
            echo 'aarch64-apple-darwin'
        fi
    else
        if [ "$PACKAGE_IOS_IOS" = 'true' ] ; then
            echo "$1-apple-ios"
        else
            echo "$1-apple-darwin"
        fi
    fi
}

list_tools_in_the_toolchain() {
    list cc cxx cpp as ar ranlib ld nm strip size strings objdump
}

list_flags_used_by_tools_in_the_toolchain() {
    list CFLAGS CXXFLAGS CPPFLAGS LDFLAGS PKG_CONFIG_PATH PKG_CONFIG_LIBDIR
}

echo_path_of_tool_in_the_toolchain() {
    unset TOOL_PATH
    case $1 in
        cc)  TOOL_PATH="$TOOLCHAIN_BIN_DIR/clang"   ;;
        cxx) TOOL_PATH="$TOOLCHAIN_BIN_DIR/clang++" ;;
        *)   TOOL_PATH="$TOOLCHAIN_BIN_DIR/$1"
    esac
    die_if_file_is_not_executable "$TOOL_PATH"
    echo "$TOOL_PATH"
}

list_supported_versions() {
    if [ -z "$1" ] ; then
        for PLATFORM in $(list_supported_platforms)
        do
            printf "%-16s : $(list_supported_versions "$PLATFORM")\n" "$PLATFORM"
        done
    else
        case $1 in
            iPhoneOS|iPhoneSimulator)   echo "8.0 8.1 8.2 8.3 8.4 9.0 9.1 9.2 9.3 10.0 10.1 10.2 10.3 11.0 11.1 11.2 11.3 11.4 12.0 12.1 12.2 12.3 12.4 13.0 13.1 13.2 13.3 13.4 13.5";;
            WatchOS|WatchSimulator)     echo "2.0 2.1 2.2 3.0 3.1 3.2 4.0 4.1 4.2 4.3 5.0 5.1 5.2 5.3 6.0 6.1 6.2";;
            AppleTVOS|AppleTVSimulator) echo "9.0 9.1 9.2 10.0 10.1 10.2 11.0 11.1 11.2 11.3 11.4 12.0 12.1 12.3 12.4 13.0 13.1 13.2 13.3";;
            MacOSX)                     echo "10.6 10.7 10.8 10.9 10.10 10.11 10.12 10.13 10.14 10.15";;
            *)     die "$1 : platform isn't supported."
        esac
    fi
}

get_supported_min_version() {
    if [ -z "$1" ] ; then
        for PLATFORM in $(list_supported_platforms)
        do
            printf "%-16s : %s\n" "$PLATFORM" $(get_supported_min_version "$PLATFORM")
        done
    else
        list_supported_versions "$1" | awk '{print $1}'
    fi
}

echo_tool_of_chain() {
    TOOL="$TOOLCHAIN_BIN_DIR/$1"
    die_if_file_is_not_executable "$TOOL"
    echo "$TOOL"
}

__create_framework_of_packages() {
    die_if_package_list_is_not_specified "$1"
    
    for PACKAGE in $@
    do
        __create_framework_for_a_package "$PACKAGE"
    done
}

__create_framework_for_a_package() {
    die_if_package_is_not_installed "$1"

    unset -f create_framework

    ___load_formula_of_a_package "$1"
    
    if command -v create_framework > /dev/null ; then
        create_framework
    else
        die "create_framework function is not declared in formula $MY_FORMULA_DIR/$1.sh"
    fi
}

parse_arguments() {
    # https://stackoverflow.com/questions/18476490/what-is-purpose-of-target-arch-variable-in-makefiles
    unset TARGET_ARCH

    unset USER_SPECIFIED_PACKAGE_LIST

    unset PLATFORM_MIN_VERSION

    unset RULE

    unset DRYRUN
    unset XTRACE
    unset VERBOSE

    unset KEEP_WORKING_DIR

    ACTION="$1"
    
    shift 1
    
    while [ -n "$1" ]
    do
        case $1 in
            --rule=*)
                RULE=$(getvalue "$1")
                [ -z "$RULE" ] && die "--rule=VALUE argument's value must not be empty."
                ;;
            --verbose|-v)
                VERBOSE=true
                ;;
            --xtrace|-x)
                XTRACE=true
                set -x
                ;;
            --dry-run)
                DRYRUN=true
                ;;
            --keep-working-dir)
                KEEP_WORKING_DIR=true
                ;;
            [a-z]*)
                if [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] ; then
                    USER_SPECIFIED_PACKAGE_LIST="$1"
                else
                    USER_SPECIFIED_PACKAGE_LIST="$USER_SPECIFIED_PACKAGE_LIST $1"
                fi
                ;;
            *)  die "$1 is a invalid argument."
        esac
        shift
    done

    [ -z "$RULE" ] && RULE=default
    
    resolve_a_rule "$RULE"
}

init() {
    # MY represents this software's
    MY_NAME=ipkg
    MY_VERSION=0.1.0
    MY_HOME_PAGE="https://github.com/leleliu008/$MY_NAME"

    if [ -z "$IPKG_FORMULA_REPO_URL" ] ; then
        MY_FORMULA_REPO_URL="https://github.com/leleliu008/$MY_NAME-formula.git"
    else
        MY_FORMULA_REPO_URL="$IPKG_FORMULA_REPO_URL"
    fi

    if [ -z "$IPKG_HOME_DIR" ] ; then
        MY_HOME_DIR="$HOME/.$MY_NAME"
    else
        MY_HOME_DIR="$IPKG_HOME_DIR"
    fi

    MY_FORMULA_DIR="$MY_HOME_DIR/formula"
    MY_INSTALL_DIR="$MY_HOME_DIR/pkg"
    MY_CACHED_DIR="$MY_HOME_DIR/downloads"
    MY_BOTTLE_DIR="$MY_HOME_DIR/bottles"
    MY_BACKUP_DIR="$MY_HOME_DIR/backup"
    MY_PATCH_DIR="$MY_HOME_DIR/patches"

    install -d "$MY_HOME_DIR/rules"

    if [ ! -f "$MY_HOME_DIR/rules/default" ] ; then
        cat > "$MY_HOME_DIR/rules/default" <<EOF
iPhoneOS         : 8.0  : all
iPhoneSimulator  : 8.0  : all
EOF
    fi
    if [ ! -f "$MY_HOME_DIR/rules/thread-local-storage" ] ; then
        cat > "$MY_HOME_DIR/rules/thread-local-storage" <<EOF
iPhoneOS         : 9.0  : all
iPhoneSimulator  : 9.0  : x86_64
iPhoneSimulator  : 10.0 : i386
EOF
    fi

    if command -v date > /dev/null ; then
        TIMESTAMP_UNIX="$(date +%s)"
    else
        die "command not found: date. please make sure it in PATH."
    fi
}

help() {
    cat << EOF
Usage: $MY_NAME <ACTION> [ARGUMENT...]
ACTION:
    help    | --help    | -h    --show help information.
    version | --version | -V    --print version of $MY_NAME and Android NDK.
    
    list rules             --list the rules.
    list versions          --list the supported versions of platforms.
    list platforms         --list the supported platforms.
    list available         --list the available packages.
    list installed         --list the installed packages.
    list outdated          --list the outdated packages.

    is available PACKAGE  --is PACKAGE available?
    is installed PACKAGE  --is PACKAGE installed?
    is outdated  PACKAGE  --is PACKAGE outdated?
    
    search KEYWORD        --search packages.
    
    rule create RULE      --create a new rule.
    rule delete RULE      --delete a exist rule.
    rule rename R1 R2     --rename a exist rule to new name.
    rule view RULE        --view the specified rule.
    rule edit RULE        --edit the specified rule.
    rule list             --equipment to list rules.

    formula create PACKAGE   --create a new formula.
    formula delete PACKAGE   --delete a exist formula.
    formula rename P1 P2     --rename a exist formula to new name.
    formula view PACKAGE     --view the formula of a package.
    formula edit PACKAGE     --edit the formula of a package.
    formula list             --equipment to list available

    tree PACKAGE          --list contents of a installed package directory in a tree-like format.
    pack PACKAGE          --pack a installed package.
    fetch PACKAGE         --download formula resources of a package to the cache.
    prefix PACKAGE        --show the installation direcotory of a formula or the $MY_NAME home.
    homepage PACKAGE      --visit the homepage of a formula or the $MY_NAME project.
    
    install   PACKAGE... [--create-framework --rule=default -v -x]    --install packages.
    reinstall PACKAGE... [--create-framework --rule=default -v -x]    --reinstall packages.
    upgrade   PACKAGE... [--create-framework --rule=default -v -x]    --upgrade packages.

    uninstall PACKAGE...                --uninstall packages.
    info      PACKAGE...                --print the information of packages.
    
    create-framework PACKAGE...         --create framework for packages.
    
    logs PACKAGE PLATFORM/ARCH          --print the logs of a installed package.
    
    min-version [PLATFORM]              --print the supported min-version of platforms.
    
    cleanup          --cleanup the unused cache.
    update           --update the formula repository.
EOF
    if [ -z "$1" ] ; then
        exit
    else
        exit "$1"
    fi
}

main() {
    if [ "$(uname -s)" != 'Darwin' ] ; then
        die "this software can only run on macOS."
    fi

    init
     
    case $1 in
        --help|help|-h) 
            help
            ;;
        --version|version|-V)
            echo "$MY_VERSION"
            ;;
        version-xcode)
            check_prerequisites
            echo "$XCODE_VERSION"
            ;;
        list)
            shift
            case $1 in
                platforms) shift; list_supported_platforms "$@" ;;
                versions)  shift; list_supported_versions  "$@" ;;
                archs)     shift; list_supported_archs     "$@" ;;
                abis)
                    shift
                    if [ -z "$1" ] ; then
                        __list_supported_abis
                    else
                        __list_abis_of_a_installed_package "$1"
                    fi
                    ;;
                rules)     shift; __list_rules ;;
                available) shift; __list_available_packages ;;
                installed) shift; __list_installed_packages ;;
                outdated)  shift; __list__outdated_packages ;;
                notdepended) shift; __list_packages_which_is_not_depended_by_others ;;
                *) help 1
            esac
            ;;
        min-version) shift; get_supported_min_version "$1" ;;
        search)  shift; __search_packages "$*" ;;
        formula) shift
            case $1 in
                create) shift; __create_a_formula "$@" ;;
                delete) shift; __delete_a_formula "$@" ;;
                rename) shift; __rename_a_formula "$@" ;;
                view)   shift; ____view_a_formula "$@" ;;
                edit)   shift; ____edit_a_formula "$@" ;;
                list)   shift; __list_available_packages ;;
                   *)   help 1
            esac
            ;;
        rule)
            shift
            case $1 in
                create) shift; __create_a_rule "$@" ;;
                delete) shift; __delete_a_rule "$@" ;;
                rename) shift; __rename_a_rule "$@" ;;
                view)   shift; ____view_a_rule "$@" ;;
                edit)   shift; ____edit_a_rule "$@" ;;
                list)   shift; __list_rules ;;
                   *)   help 1
            esac
            ;;
        update)  __update_formula_repository ;;
        cleanup) __cleanup ;;
        
        install)   ____install_packages "$@" ;;
        reinstall) __reinstall_packages "$@" ;;
        uninstall) __uninstall_packages "$@" ;;
        upgrade)   ____upgrade_packages "$@" ;;

        json_available_packages) __json_available_packages ;;

        homepage) shift; __show_webpage_of_a_package    "$@" ;;
        depends)  shift; __show_depends_of_a_package    "$@" ;;
        prefix)   shift; __show_prefix_of_a_package     "$@" ;;
        fetch)    shift; ___load_formula_of_a_package   "$@" &&
                         __fetch_resources_of_a_package "$@" ;;
        logs)     shift; __show_logs_of_a_package       "$@" ;;
        pack)     shift; __pack_bottle_of_a_package     "$@" ;;
        tree)     shift; __tree_installed_of_a_package  "$@" ;;
        info)     shift; __show_infomation_of_packages  "$@" ;;
        create-framework)
                  shift; __create_framework_of_packages "$@" ;;
        is)
            shift
            case $1 in
                available) shift; is_package_available "$@" ;;
                installed) shift; is_package_installed "$@" ;;
                outdated)  shift; is_package__outdated "$@" ;;
                *) help 1
            esac
            ;;
        *) help 1
    esac
}

main "$@"
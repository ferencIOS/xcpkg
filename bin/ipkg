#!/bin/sh

#------------------------------------------------------------------------------
# https://clang.llvm.org/docs/ClangCommandLineReference.html
# https://clang.llvm.org/docs/CrossCompilation.html
# https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art024
#------------------------------------------------------------------------------

COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;34m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

print() {
    printf "%b" "$*"
}

echo() {
    print "$*\n"
}

info() {
    print "${COLOR_PURPLE}$*\n${COLOR_OFF}"
}

success() {
    print "${COLOR_GREEN}[✔] $*\n${COLOR_OFF}"
}

warn() {
    print "${COLOR_YELLOW}🔥 $*\n${COLOR_OFF}"
}

error() {
    print "${COLOR_RED}[✘] $*\n${COLOR_OFF}"
}

die() {
    print "${COLOR_RED}[✘] $*\n${COLOR_OFF}"
    exit 1
}

list() {
    for item in $@
    do
        echo "$item"
    done
}

list_length() {
    echo $#
}

eeval() {
    echo "$@"
    eval "$@"
}

nproc() {
    if command -v nproc > /dev/null ; then
        command nproc
    elif command -v sysctl > /dev/null ; then
        sysctl -n machdep.cpu.thread_count
    elif test -f /proc/cpuinfo ; then
        grep -c processor /proc/cpuinfo
    else
        echo 4
    fi
}

sed_in_place() {
    if command -v gsed > /dev/null ; then
        gsed -i "$1" "$2"
    elif command -v sed  > /dev/null ; then
        sed -i    "$1" "$2" 2> /dev/null || 
        sed -i "" "$1" "$2"
    else
        die "please install sed utility."
    fi
}

format_unix_timestamp() {
   date -jf "%s" "$1" "$2" 2> /dev/null ||
   date -d      "@$1" "$2"
}

getvalue() {
    echo "$1" | cut -d= -f2
}

prompt_user_to_install_bat() {
    warn "if you want to have a better experience, I strongly recommend you install ${COLOR_RED}bat${COLOR_OFF} on your os. For more details, see ${COLOR_RED}https://github.com/sharkdp/bat${COLOR_OFF}"
}

__fetch_via_git() {
    info "Fetching $FETCH_URL"

    if [ -d "$FETCH_OUTPUT_PATH" ] ; then
        if  git -C "$FETCH_OUTPUT_PATH" rev-parse 2> /dev/null ; then
            git -C "$FETCH_OUTPUT_PATH" pull &&
            git -C "$FETCH_OUTPUT_PATH" submodule update --recursive
        else
            rm -rf "$FETCH_OUTPUT_PATH" &&
            git -C "$FETCH_OUTPUT_DIR" clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME"
        fi
    else
        git -C "$FETCH_OUTPUT_DIR" clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME"
    fi
    
    if [ $? -eq 0 ] ; then
        success "Fetched to $FETCH_OUTPUT_PATH success."
    else
        die "Fetched to $FETCH_OUTPUT_PATH failed."
    fi
}

__fetch_archive_via_tools() {
    if [ -f "$FETCH_OUTPUT_PATH" ] ; then
        if [ -n "$FETCH_SHA256" ] ; then
            if is_sha256sum_match "$FETCH_OUTPUT_PATH" "$FETCH_SHA256" ; then
                success "$FETCH_OUTPUT_PATH is already downloaded."
                return 0
            fi
        fi
        rm -f "$FETCH_OUTPUT_PATH"
    fi

    if command -v curl > /dev/null ; then
        info "Fetching $FETCH_URL"
        curl -L -o "$FETCH_OUTPUT_PATH" "$FETCH_URL"
    elif command -v wget > /dev/null ; then
        info "Fetching $FETCH_URL"
        wget -O "$FETCH_OUTPUT_PATH" "$FETCH_URL"
    else
        die "please install curl or wget."
    fi

    if [ $? -eq 0 ] ; then
        success "Fetched to $FETCH_OUTPUT_PATH success."
    else
        die "Fetched to $FETCH_OUTPUT_PATH failed."
    fi

    if [ -n "$FETCH_SHA256" ] ; then
        die_if_sha256sum_mismatch "$FETCH_OUTPUT_PATH" "$FETCH_SHA256"
    fi
}

# fetch <URL> [--sha256=SHA256] <--output-path=PATH>
# fetch <URL> [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
# fetch <URL> [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
# fetch <URL> [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>
fetch() {
    unset FETCH_URL
    unset FETCH_SHA256
    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_NAME
    unset FETCH_OUTPUT_PATH
    
    if [ -z "$1" ] ; then
        die "please specify a fetch url."
    else
        FETCH_URL="$1"
    fi
    
    shift
    
    while [ -n "$1" ]
    do
        case $1 in
            --sha256=*)
                FETCH_SHA256=$(getvalue "$1")
                ;;
            --output-dir=*)
                FETCH_OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                    die "--output-dir argument's value must be not empty."
                fi
                ;;
            --output-name=*)
                FETCH_OUTPUT_NAME=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                    die "--output-name argument's value must be not empty."
                fi
                ;;
            --output-path=*)
                FETCH_OUTPUT_PATH=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_PATH" ] ; then
                    die "--output-path argument's value must be not empty."
                fi
        esac
        shift
    done
    
    if [ -z "$FETCH_OUTPUT_PATH" ] ; then
        [ -z "$FETCH_OUTPUT_DIR" ]  && FETCH_OUTPUT_DIR="$PWD"
        [ -z "$FETCH_OUTPUT_NAME" ] && FETCH_OUTPUT_NAME=$(basename "$FETCH_URL")

        FETCH_OUTPUT_PATH="$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME"
    else
        FETCH_OUTPUT_DIR="$(dirname $FETCH_OUTPUT_PATH)"
        FETCH_OUTPUT_NAME="$(basename $FETCH_OUTPUT_PATH)"
    fi

    install -v -d "$FETCH_OUTPUT_DIR"

    case $FETCH_URL in
        *.git) __fetch_via_git ;;
        *)     __fetch_archive_via_tools ;;
    esac
}

sha256sum() {
    die_if_file_is_not_exist "$1"

    if command -v openssl > /dev/null ; then
        openssl sha256 "$1" | awk '{print $2}'
    elif command sha256sum --version > /dev/null 2>&1 ; then
        sha256sum "$1" | awk '{print $1}'
    else
        die "please install openssl or GNU CoreUtils."
    fi
}

is_sha256sum_match() {
    die_if_file_is_not_exist "$1"
    [ -z "$2" ] && die "please specify sha256sum."
    [ "$(sha256sum $1)" = "$2" ]
}

die_if_sha256sum_mismatch() {
    is_sha256sum_match "$1" "$2" || die "sha256sum mismatch."
}

__fetch_sources_of_a_package() {
    # fetch source code if posible
    if [ "$PACKAGE_SRC_TYPE" != 'dir' ] ; then
        fetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SUM" --output-path="$PACKAGE_SRC_PATH"
    fi
}

__fetch_patches_of_a_package() {
    unset PACKAGE_PATCHES

    # fetch patches if posible
    while [ -n "$1" ]
    do
        fetch "$1" --sha256="$2" --output-dir="$MY_PATCH_DIR/$PACKAGE_NAME" --output-name="$(basename $1)"
        
        if [ -z "$PACKAGE_PATCHES" ] ; then
            PACKAGE_PATCHES="$FETCH_OUTPUT_PATH"
        else
            PACKAGE_PATCHES="$PACKAGE_PATCHES $FETCH_OUTPUT_PATH"
        fi

        shift 2
    done
}

__fetch_resources_of_a_package() {
    ___load_formula_of_a_package "$1"

    __fetch_sources_of_a_package

    __fetch_patches_of_a_package $PACKAGE_PATCHES
}

die_if_file_is_not_exist() {
    [ -z "$1" ] && die "please specify a file path."
    [ -f "$1" ] || die "$1 is not exist."
}

die_if_file_is_not_executable() {
    die_if_file_is_not_exist "$1"
    [ -x "$1" ] || die "$1 is not executable."
}

die_if_abi_____is_not_specified() {
    [ -z "$1" ] && die "please specify a abi."
}

die_if_abi_____is_not_supported() {
    die_if_abi_____is_not_specified "$1"
    
    for ABI in $(__list_supported_abis)
    do
        [ "$ABI" = "$1" ] && return 0
    done

    die "$1 abi is not supported."
}

die_if_package_is_not_specified() {
    [ -z "$1" ] && die "please specify a package name."
}

die_if_package_list_is_not_specified() {
    [ -z "$1" ] && die "please specify at least one package name."
}

die_if_package_is_not_available() {
    is_package_available "$1" || die "$1 is not available."
}

die_if_package_is_already_exist() {
    die_if_package_is_not_specified "$1"
    [ -f "$MY_FORMULA_DIR/$1.sh" ] && die "$1 package is already exist."
}

die_from_package_is_not_installed() {
    die "$1 is not installed."
}

die_if_package_is_not_installed() {
    is_package_installed "$1" || die_from_package_is_not_installed "$1"
}

is_package_available() {
    die_if_package_is_not_specified "$1"
    [ -f "$MY_FORMULA_DIR/$1.sh" ]
}

is_package_installed() {
    die_if_package_is_not_specified "$1"
    
    [ -d "$MY_INSTALL_DIR/$1" ]              || return 1
    [ -f "$MY_INSTALL_DIR/$1/manifest.txt" ] || return 1

    for ABI in $(cat "$MY_INSTALL_DIR/$1/manifest.txt")
    do
        [ -d "$MY_INSTALL_DIR/$1/$ABI" ]                       || return 1
        [ -d "$MY_INSTALL_DIR/$1/$ABI/log" ]                   || return 1
        [ -f "$MY_INSTALL_DIR/$1/$ABI/log/installed.log.txt" ] || return 1
    done
}

is_package__outdated() {
    ___load_formula_of_a_package "$1"

    [ -d "$MY_INSTALL_DIR/$1" ]              || die_from_package_is_not_installed "$1"
    [ -f "$MY_INSTALL_DIR/$1/manifest.txt" ] || die_from_package_is_not_installed "$1"

    for ABI in $(cat "$MY_INSTALL_DIR/$1/manifest.txt")
    do
        [ -d "$MY_INSTALL_DIR/$1/$ABI" ]                       || die_from_package_is_not_installed "$1"
        [ -d "$MY_INSTALL_DIR/$1/$ABI/log" ]                   || die_from_package_is_not_installed "$1"
        [ -f "$MY_INSTALL_DIR/$1/$ABI/log/installed.log.txt" ] || die_from_package_is_not_installed "$1"
        die_if_load_installed_log_failed "$1" "$ABI"
        [ "$PACKAGE_VERSION" = "$installed_pkg_version" ] && return 1
        [ "$PACKAGE_VERSION" = $(printf "$PACKAGE_VERSION\n$installed_pkg_version" | sort --version-sort --reverse | head -n 1) ]
    done
}

__list_available_packages() {
    unset SILENT

    case $# in
        0)  ;;
        1)  if [ "$1" = '-q' ] ; then
                SILENT=true
            else
                die "list available action only accept -q argument."
            fi
            ;;
        *)  die "list available action only accept -q argument."
    esac

    [ -d "$MY_FORMULA_DIR" ] || {
        if [ "$SILENT" = 'true' ] ; then
            __update_formula_repository >/dev/null 2>&1
        else
            __update_formula_repository
        fi
    }
    
    if [ "$SILENT" = 'true' ] ; then
        cd "$MY_FORMULA_DIR" 2>/dev/null || exit 1
    else
        cd "$MY_FORMULA_DIR" || exit 1
    fi

    for item in $(ls *.sh | sed 's/\.sh//g')
    do
        echo "$item"
    done
}

__list_installed_packages() {
    cd "$MY_INSTALL_DIR" 2>/dev/null || exit 1

    for packageName in *
    do
        if is_package_installed "$packageName" ; then
            echo "$packageName"
        fi
    done
}

__list__outdated_packages() {
    cd "$MY_INSTALL_DIR" 2>/dev/null || exit 1

    for packageName in *
    do
        is_package_available "$packageName" || continue
        is_package_installed "$packageName" || continue
        is_package__outdated "$packageName" || continue
        echo "$packageName"
    done
}

__list_abis_of_a_installed_package() {
    die_if_package_is_not_installed "$1"
    cat "$MY_INSTALL_DIR/$1/manifest.txt"
}

__tree_installed_of_a_package() {
    die_if_package_is_not_installed "$1"

    PKG_INSTALL_DIR="$MY_INSTALL_DIR/$1"

    shift

    if command -v tree > /dev/null ; then
        tree $@ --dirsfirst "$PKG_INSTALL_DIR"
    else
        warn "please install tree utility."
    fi
}

__uninstall_packages() {
    shift

    die_if_package_list_is_not_specified "$1"
    
    for packageName in $@
    do
        __uninstall_a_package "$packageName" || return 1
    done
}

__uninstall_a_package() {
    die_if_package_is_not_installed "$1"

    info "uninstalling $1..." &&
    rm -rf "$MY_INSTALL_DIR/$1" &&
    success "$1 uninstalled."
}

____view_a_formula() {
    die_if_package_is_not_available "$1"

    [ -z "$2" ] || warn "view action accept only one argument."
    
    if command -v bat > /dev/null ; then
        bat "$MY_FORMULA_DIR/$1.sh"
    else
        cat "$MY_FORMULA_DIR/$1.sh"
        echo
        prompt_user_to_install_bat
    fi    
}

____edit_a_formula() {
    die_if_package_is_not_available "$1"

    [ -z "$2" ] || warn "edit action accept only one argument."

    [ -z "$EDITOR" ] &&
    EDITOR=$(command -v nvim) ||
    EDITOR=$(command -v vim) ||
    EDITOR=$(command -v vi) ||
    EDITOR=$(command -v open) ||
    die "please set EDITOR environment variable."

    "$EDITOR" "$MY_FORMULA_DIR/$1.sh"
}

__create_a_formula() {
    die_if_package_is_already_exist "$1"

    cat > "$MY_FORMULA_DIR/$1.sh" <<EOF
summary "Summary of this package"

webpage "https://www.xx.com"

# the source code download url of this package. the value of src_url must end with one of .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz
src_url "https://www.xx.com/pkgname-x.y.z.tar.gz"

# the sha256sum of source code. If the value of src_url end with .git, this function is optional, otherwise, this function must be invoked.
src_sum "c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1"

# the version of this package. If this function is not invoked, it will be calculated from src_url.
#version "x.y.z"

# the license of this package.
#license "MIT"

# the required commands of this package when installing. If specify multiple values, separate them with spaces.
#require "a b c"

# the packages are depended by this package. If specify multiple values, separate them with spaces.
#depends "a b c"

prepare() {
    :
    #this function is optional, you can delete it, if don't use it.
}

build() {
    :
    #configure
    #cmake
    #meson
    #cargo
    #$MAKE
}
EOF
    ____edit_a_formula "$1"
}

__delete_a_formula() {
    die_if_package_is_not_available "$1"

    if rm "$MY_FORMULA_DIR/$1.sh" ; then
        success "delete $1 formula success."
    else
        die "delete $1 formula failed."
    fi
}

__rename_a_formula() {
    die_if_package_is_not_available "$1"
    die_if_package_is_already_exist "$2"

    if mv "$MY_FORMULA_DIR/$1.sh" "$MY_FORMULA_DIR/$2.sh" ; then
        success "rename formula $1 -> $2 success."
    else
        die "rename formula $1 -> $2 failed."
    fi   
}

__update_formula_repository() {
    info "Updating formula repository."
    fetch "$MY_FORMULA_REPO_URL" --output-dir="$MY_HOME_DIR" --output-name=formula
}

____upgrade_packages() {
    check_prerequisites
    parse_arguments "$@"

    [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] && USER_SPECIFIED_PACKAGE_LIST=$(__list__outdated_packages)
    [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] && return 0

    __reinstall_packages
}

__reinstall_packages() {
    check_prerequisites
    parse_arguments "$@"

    die_if_package_list_is_not_specified "$USER_SPECIFIED_PACKAGE_LIST"

    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        die_if_package_is_not_available "$packageName"
        die_if_package_is_not_installed "$packageName"
    done
    
    for packageName in $USER_SPECIFIED_PACKAGE_LIST
    do
        {
            [ -d "$MY_BACKUP_DIR" ] || mkdir -p "$MY_BACKUP_DIR"
        } &&
        mv "$MY_INSTALL_DIR/$packageName" "$MY_BACKUP_DIR/$packageName" &&
        __install_a_package "$packageName" &&
        rm -rf "$MY_BACKUP_DIR/$packageName"
    done
}

__cleanup() {
    success "Done."
}

__search_packages() {
    [ -z "$1" ] && die "please specify a keyword."
    [ -d "$MY_FORMULA_DIR" ] || __update_formula_repository
    
    cd "$MY_FORMULA_DIR" || exit 1

    for item in $(ls -1 *.sh | sed 's/\.sh//g')
    do
        echo "$item" | grep "$*" || true
    done
}

__show_webpage_of_a_package() {
    if [ -z "$1" ] ; then
        PACKAGE_WEBPAGE="$MY_HOME_PAGE"
    else
        ___load_formula_of_a_package "$1"
    fi
    
    echo "$PACKAGE_WEBPAGE"

    if command -v open > /dev/null ; then
        open "$PACKAGE_WEBPAGE"
    fi
}

__show_prefix_of_a_package() {
    if [ -z "$1" ] ; then
        echo "$MY_HOME_DIR"
    else
        die_if_package_is_not_installed "$1"
        echo "$MY_INSTALL_DIR/$1"
    fi
}

__show_logs_of_a_package() {
    die_if_package_is_not_installed "$1"
    die_if_abi_____is_not_supported "$2"

    if command -v bat > /dev/null ; then
        VIEWER=bat
    else
        VIEWER=less
    fi

    for item in $(ls "$MY_INSTALL_DIR/$1/$2/log"/*)
    do
        if [ "$VIEWER" = 'bat' ] ; then
            case $item in
                *.png) ;;
                *.sh|*/installed.log.txt)
                    bat -l bash "$item" ;;
                *)  bat "$item"
            esac
        else
            "$VIEWER" "$item"
        fi
    done

    if [ "$VIEWER" != 'bat' ] ; then
        prompt_user_to_install_bat
    fi
}

__pack_bottle_of_a_package_via_zip() {
    die_if_package_is_not_installed "$1"
    
    install -d "$MY_BOTTLE_DIR" || return 1

    cd "$MY_INSTALL_DIR" || return 1

    FILE_PATH_BOTTLE="$MY_BOTTLE_DIR/$1-bottle.zip"

    info "packing $1 ..."

    if zip -r "$FILE_PATH_BOTTLE" "$1" ; then
        success "packed $1 success. $FILE_PATH_BOTTLE"
    else
        die "packed $1 failed."
    fi
}

__pack_bottle_of_a_package_via_tar_gzip() {
    die_if_package_is_not_installed "$1"
    
    install -d "$MY_BOTTLE_DIR" || return 1

    FILE_PATH_BOTTLE="$MY_BOTTLE_DIR/$1-bottle.tar.gz"

    info "packing $1 ..."
    
    if tar zvcf "$FILE_PATH_BOTTLE" -C "$MY_INSTALL_DIR" "$1" ; then
        success "packed $1 success. $FILE_PATH_BOTTLE"
    else
        die "packed $1 failed."
    fi
}

__pack_bottle_of_a_package_via_tar_xz() {
    die_if_package_is_not_installed "$1"
    
    install -d "$MY_BOTTLE_DIR" || return 1

    FILE_PATH_BOTTLE="$MY_BOTTLE_DIR/$1-bottle.tar.xz"

    info "packing $1 ..."

    if tar Jvcf "$FILE_PATH_BOTTLE" -C "$MY_INSTALL_DIR" "$1" ; then
        success "packed $1 success. $FILE_PATH_BOTTLE"
    else
        die "packed $1 failed."
    fi
}

__pack_bottle_of_a_package_via_tar_bzip2() {
    die_if_package_is_not_installed "$1"
    
    install -d "$MY_BOTTLE_DIR" || return 1

    FILE_PATH_BOTTLE="$MY_BOTTLE_DIR/$1-bottle.tar.bz2"

    info "packing $1 ..."

    if tar jvcf "$FILE_PATH_BOTTLE" -C "$MY_INSTALL_DIR" "$1" ; then
        success "packed $1 success. $FILE_PATH_BOTTLE"
    else
        die "packed $1 failed."
    fi
}

__pack_bottle_of_a_package() {
    if command -v zip > /dev/null ; then
        __pack_bottle_of_a_package_via_zip "$1"
    elif command -v tar > /dev/null ; then
        if command -v gzip > /dev/null ; then
            __pack_bottle_of_a_package_via_tar_gzip "$1"
        elif command -v xz > /dev/null ; then
            __pack_bottle_of_a_package_via_tar_xz "$1"
        elif command -v bzip2 > /dev/null ; then
            __pack_bottle_of_a_package_via_tar_bzip2 "$1"
        else
            die "please install gzip or xz or bzip2 utility."
        fi
    else
        die "please install zip or tar utility."
    fi
}

get_direct_dependency_package_list_of_a_package() {
    grep '^\s*depends\s*".*"' "$MY_FORMULA_DIR/$1.sh" | sed 's/.*depends.*"\(.*\)"/\1/'
}

# $1 is first call
# $2 packageName
__gen_dependency_list() {
    if [ "$1" = 'true' ] ; then
        unset I
        unset DEPENDENCY_PACKAGE_LIST
    fi

    unset DIRECT_DEPENDENCY_PACKAGE_LIST
    if [ -z "$2" ] ; then
        DIRECT_DEPENDENCY_PACKAGE_LIST="$USER_SPECIFIED_PACKAGE_LIST"
    else
        DIRECT_DEPENDENCY_PACKAGE_LIST=$(get_direct_dependency_package_list_of_a_package "$2")
    fi
    
    for dependencyPkgName in $DIRECT_DEPENDENCY_PACKAGE_LIST
    do
        die_if_package_is_not_available "$dependencyPkgName"

        DEPENDENCY_PACKAGE_LIST_TEMP=""

        for item in $DEPENDENCY_PACKAGE_LIST
        do
            if [ "$dependencyPkgName" = "$item" ] ; then
                continue
            else
                DEPENDENCY_PACKAGE_LIST_TEMP="$DEPENDENCY_PACKAGE_LIST_TEMP $item"
            fi
        done
        
        DEPENDENCY_PACKAGE_LIST="$dependencyPkgName $DEPENDENCY_PACKAGE_LIST_TEMP"

        __gen_dependency_list 'false' "$dependencyPkgName"
    done
}

# $1 is first call
# $2 packageName
__gen_dependency_tree() {
    unset DIRECT_DEPENDENCY_PACKAGE_LIST
    DIRECT_DEPENDENCY_PACKAGE_LIST=$(get_direct_dependency_package_list_of_a_package "$2")

    if [ "$1" = 'true' ] ; then
        unset I

        unset DEPENDENCIES__GV
        unset DEPENDENCIES_PNG
        unset DEPENDENCIES_TXT

        DEPENDENCIES__GV="$EMPTY_DIR/$2.dependencies.gv"
        DEPENDENCIES_PNG="$EMPTY_DIR/$2.dependencies.png"
        DEPENDENCIES_TXT="$EMPTY_DIR/$2.dependencies.txt"
        
        if [ -n "$DIRECT_DEPENDENCY_PACKAGE_LIST" ] ; then
            echo "digraph \"$2\" {" > "$DEPENDENCIES__GV"
        fi
    fi

    if [ -f "$DEPENDENCIES__GV" ] ; then
        print "  \"$2\" -> {" >> "$DEPENDENCIES__GV"
        for dependencyPkgName in $DIRECT_DEPENDENCY_PACKAGE_LIST
        do
            print " \"$dependencyPkgName\"" >> "$DEPENDENCIES__GV"
        done
        echo " }" >> "$DEPENDENCIES__GV"
    fi

    I=$(expr ${I-0} + 1)

    for dependencyPkgName in $DIRECT_DEPENDENCY_PACKAGE_LIST
    do
        __gen_dependency_tree 'false' "$dependencyPkgName"
    done

    I=$(expr $I - 1)

    if [ "$I" -eq 0 ] ; then
        if [ -f "$DEPENDENCIES__GV" ] ; then
            echo "}" >> "$DEPENDENCIES__GV"

            dot -Tpng -o "$DEPENDENCIES_PNG" "$DEPENDENCIES__GV"

            # https://github.com/ggerganov/dot-to-ascii
            curl \
                -o "$DEPENDENCIES_TXT" \
                -s \
                -G \
                --data-urlencode "boxart=1" \
                --data-urlencode "src=$(cat $DEPENDENCIES__GV)" \
                "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php"
        fi
    fi
}

__config_glob_installation_variables() {
    if [ -z "$SHELL" ] ; then
        SHELL=$(command -v zsh) ||
        SHELL=$(command -v bash) ||
        SHELL=$(command -v sh)
    fi

    if [ -z "$MAKE" ] ; then
        MAKE=$(command -v gmake) ||
        MAKE=$(command -v make)
    fi

    if [ -z "$NINJA" ] ; then
        NINJA=$(command -v ninja) ||
        NINJA=$(command -v ninja-build)
    fi

    if [ -z "$PKG_CONFIG" ] ; then
        PKG_CONFIG=$(command -v pkg-config) ||
        PKG_CONFIG=$(command -v pkgconfig) ||
        PKG_CONFIG=$(command -v pkgconf)
    fi

    for item in $(echo "$PATH" | tr ':' ' ')
    do
        if [ -z "$CMAKE" ] ; then
            if [ -f "$item/cmake" ] && [ -x "$item/cmake" ] ; then
                CMAKE="$item/cmake"
            fi
        fi

        if [ -z "$MESON" ] ; then
            if [ -f "$item/meson" ] && [ -x "$item/meson" ] ; then
                MESON="$item/meson"
            fi
        fi

        if [ -z "$CARGO" ] ; then
            if [ -f "$item/cargo" ] && [ -x "$item/cargo" ] ; then
                CARGO="$item/cargo"
            fi
        fi

        if [ -n "$CMAKE" ] && [ -n "$MESON" ] && [ -n "$CARGO" ] ; then
            break
        fi
    done

    for tool in $(list_tools_in_the_toolchain)
    do
        unset TOOL_PATH
        case $tool in
            cc)
                if [ -z "$CC" ] ; then
                    TOOL_PATH=$(command -v cc) ||
                    TOOL_PATH=$(command -v gcc) ||
                    TOOL_PATH=$(command -v clang)
                else
                    TOOL_PATH="$CC"
                fi
                ;;
            cxx)
                if [ -z "$CXX" ] ; then
                    TOOL_PATH=$(command -v c++) ||
                    TOOL_PATH=$(command -v g++) ||
                    TOOL_PATH=$(command -v clang++)
                else
                    TOOL_PATH="$CXX"
                fi
                ;;
            *)  TOOL_PATH=$(command -v "$tool")
        esac

        unset TOOL_UPPER
        TOOL_UPPER=$(echo "$tool" | tr a-z A-Z)

        eval $TOOL_UPPER=$TOOL_PATH
        eval export ${TOOL_UPPER}_FOR_BUILD=$TOOL_PATH
    done
    unset TOOL_PATH
    unset TOOL_UPPER

    for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
    do
        eval export ${FLAG}_FOR_BUILD="\$$FLAG"
    done
    unset FLAG

    export PATH="$TOOLCHAIN_BIN_DIR:$PATH"

    if [ "$VERBOSE" = 'true' ] ; then
        export PKG_CONFIG_DEBUG_SPEW=set
    fi
}

____install_packages() {
    check_prerequisites

    parse_arguments "$@"

    die_if_package_list_is_not_specified "$USER_SPECIFIED_PACKAGE_LIST"

    __config_glob_installation_variables
    
    __gen_dependency_list 'true' '' || return 1
    
    for INSTALLING_PACKAGE in $DEPENDENCY_PACKAGE_LIST
    do
        if is_package_installed "$INSTALLING_PACKAGE" ; then
            success "$INSTALLING_PACKAGE is already installed."
        else
            __install_a_package "$INSTALLING_PACKAGE"
        fi
    done
}

die_if_command_not_found() {
    case $1 in
        make) [ -z "$MAKE" ]  && die_from_command_not_found "$1"  "MAKE" ;;
       cmake) [ -z "$CMAKE" ] && die_from_command_not_found "$1" "CMAKE" ;;
       meson) [ -z "$MESON" ] && die_from_command_not_found "$1" "MESON" ;;
       ninja) [ -z "$NINJA" ] && die_from_command_not_found "$1" "NINJA" ;;
       cargo) [ -z "$CARGO" ] && die_from_command_not_found "$1" "CARGO" ;;
       pkg-config|pkgconfig|pkgconf)
              [ -z "$PKG_CONFIG" ] && die_from_command_not_found "$1" "PKG_CONFIG" ;;
           *) command -v "$1" > /dev/null || die_from_command_not_found "$1"
    esac
}

die_from_command_not_found() {
    if [ -z "$2" ] ; then
        die "command not found: $1. please make sure it in PATH."
    else
        die "command not found: $1. please make sure it in PATH or export $2=path/to/$1 environment."
    fi
}

die_from_installation_failed() {
    if [ -z "$BUILD_FOR_ABI" ] ; then
        die "install $1 failed! you can go to $WORKING_DIR to see see."
    else
        die "install $1/$BUILD_FOR_ABI failed! you can go to $WORKING_DIR to see see."
    fi
}

__install_a_package() {
    unset BUILD_FOR_ABI

    __fetch_resources_of_a_package "$1"

    for bin in $PACKAGE_REQUIRE
    do
        die_if_command_not_found "$bin"
    done

    if WORKING_DIR=$(mktemp -d) ; then
        echo "mkdir $WORKING_DIR"
    else
        die "create working directory failed."
    fi

    case $PACKAGE_SRC_URL in
        dir://*|*.git)
            echo "copy $PACKAGE_SRC_PATH -> $WORKING_DIR"
            cp -r "$PACKAGE_SRC_PATH"/* "$WORKING_DIR" || return 1
            ;;
        *.c|*.cc|*.cxx|*.cpp)
            echo "copy $PACKAGE_SRC_PATH -> $WORKING_DIR"
            cp "$PACKAGE_SRC_PATH" "$WORKING_DIR" || return 1
            ;;
        *.zip)
            echo "unzip $PACKAGE_SRC_PATH -> $WORKING_DIR"
            unzip "$PACKAGE_SRC_PATH" -d "$WORKING_DIR" || return 1
            ;;
        *.tar.xz|*.tar.gz|*.tar.lz|*.tar.bz2|*.tgz|*.txz)
            echo "untar $PACKAGE_SRC_PATH -> $WORKING_DIR"
            tar xf "$PACKAGE_SRC_PATH" -C "$WORKING_DIR" --strip-components 1 || return 1
            ;;
        *)  die "$PACKAGE_SRC_URL : extension isn't recognized. the supported extensions are .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    if [ -z "$PACKAGE_SOURCE_DIR" ] ; then
        SOURCE_DIR="$WORKING_DIR"
    else
        SOURCE_DIR="$WORKING_DIR/$PACKAGE_SOURCE_DIR"
    fi

    cd "$SOURCE_DIR" || die "check the $FORMULA_FILE_PATH. argument of sourced command is not right."

    EMPTY_DIR="$WORKING_DIR/$TIMESTAMP_UNIX"
    BUILD_DIR="$EMPTY_DIR/native"

    install -v -d "$BUILD_DIR" || exit 1

    if command -v prepare > /dev/null ; then
        # may be build something for building
        
        info "=========================================> prepare pre"

        printf "%16s = %s\n" "PACKAGE_NAME" "$PACKAGE_NAME"
        echo

        for TOOL in SHELL MAKE CMAKE MESON NINJA CARGO PKG_CONFIG
        do
            printf "%16s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
        done

        echo

        for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
        do
            eval export $TOOL=\$"${TOOL}_FOR_BUILD"
            printf "%16s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
        done

        for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
        do
            eval export $FLAG=\$"${FLAG}_FOR_BUILD"
            printf "\n%16s = " "$FLAG"
            FIRST='true'
            for item in $(eval echo \$$FLAG | tr ':' ' ')
            do
                if [ "$FIRST" = 'true' ] ; then
                    FIRST='false'
                    echo "$item"
                else
                    echo "                   $item"
                fi
            done
        done

        echo
        echo
        echo "      WORKING_DIR = $WORKING_DIR"
        echo "       SOURCE_DIR = $SOURCE_DIR"
        echo "        EMPTY_DIR = $EMPTY_DIR"
        echo "        BUILD_DIR = $BUILD_DIR"
        echo "              PWD = $PWD"
        echo
        info "=========================================> prepare pre"

        prepare || die_from_installation_failed "$1"
    fi

    __install_a_package_all_builds "$1" || die_from_installation_failed "$1"

    if [ "$KEEP_WORKING_DIR" != 'true' ] ; then
        rm -rf "$WORKING_DIR"
    fi
}

__install_a_package_all_builds() {
    unset BUILD_ROUND_NUM

    __gen_dependency_list 'true' "$1" || return 1

    __gen_dependency_tree 'true' "$1" || return 1

    PKG_INSTALL_DIR="$MY_INSTALL_DIR/$1"

    unset BUILD_FOR_ABI_LIST

    for BUILD in $BUILD_LIST
    do
        BUILD_ROUND_NUM=$(expr ${BUILD_ROUND_NUM-0} + 1)

        BUILD_FOR_ABI=$(echo "$BUILD" | cut -d: -f1)

        if [ -z "$BUILD_FOR_ABI_LIST" ] ; then
            BUILD_FOR_ABI_LIST="$BUILD_FOR_ABI"
        else
            BUILD_FOR_ABI_LIST=$(printf "%s\n%s" "$BUILD_FOR_ABI_LIST" "$BUILD_FOR_ABI")
        fi

        BUILD_DIR="$EMPTY_DIR/$BUILD_FOR_ABI"
        mkdir -p "$BUILD_DIR" || return 1

        if [ "$DRYRUN" = 'true' ] ; then
            ___dryrun_a_package_one_build "$1" || return 1
        else
            (
                cd "$BUILD_DIR" &&
                mkfifo pipe &&
                (tee install.log.txt < pipe &) &&
                __install_a_package_one_build "$1" > pipe 2>&1
            ) || return 1
        fi
    done

    echo "$BUILD_FOR_ABI_LIST" > "$PKG_INSTALL_DIR/manifest.txt"

    success "$1 installed success. in $PKG_INSTALL_DIR directory."
    
    __tree_installed_of_a_package "$1" || true
}

___dryrun_a_package_one_build() {
    __config_this_build_variables "$1" &&
    __printf_this_build_variables "$1" &&
    exec "$SHELL"
}

__install_a_package_one_build() {
    if [ "$PACKAGE_BUILD_IN_SOURCE_DIR" = 'true' ] ; then
        cd "$SOURCE_DIR" || return 1
    fi

    __config_this_build_variables "$1" &&
    __printf_this_build_variables "$1" &&
    rm -rf "$ABI_INSTALL_DIR" &&
    build && {
        [ -d "$ABI_INSTALL_DIR" ] || {
            error "installed nothing."
            return 1
        }
    } &&
    __justfy_pc_files &&
    __install_logs "$1"
}

__justfy_pc_files() {
    if [ -d "$ABI_PKGCONF_DIR" ] ; then
        for item in $(find "$ABI_PKGCONF_DIR" -name "*.pc")
        do
            
            if grep 'Libs.private:' "$item" > /dev/null ; then
                LIBS_CONTENT=$(awk '/Libs:/{print}' "$item" || return 1)
                LIBS_PRIVATE_CONTENT=$(awk -F: '/Libs.private:/{print $2}' "$item" || return 1)
                sed_in_place "s|$LIBS_CONTENT|$LIBS_CONTENT$LIBS_PRIVATE_CONTENT|" "$item" || return 1
                sed_in_place '/Libs.private/d' "$item" || return 1
            fi
        done
    fi
}

__install_logs() {
    ABI_LOG_DIR="$ABI_INSTALL_DIR/log"

    install -d "$ABI_LOG_DIR" || return 1

    install_installed_log
    
    for item in "$BUILD_DIR" "$SOURCE_DIR"
    do
        if [ -f "$item/config.log" ] ; then
            install -m 644 "$item/config.log" "$ABI_LOG_DIR" || return 1
        fi
        if [ -f "$item/compile_commands.json" ] ; then
            install -m 644 "$item/compile_commands.json" "$ABI_LOG_DIR" || return 1
        fi
        if [ -f "$item/config.log" -a -f "$item/compile_commands.json" ] ; then
            break
        fi
    done

    for item in "$BUILD_DIR/install.log.txt" "$MY_FORMULA_DIR/$1.sh" "$DEPENDENCIES__GV" "$DEPENDENCIES_PNG" "$DEPENDENCIES_TXT"
    do
        if [ -f "$item" ] ; then
            install -m 644 "$item" "$ABI_LOG_DIR" || return 1
        fi
    done
}

install_incs() {
    while [ -n "$1" ]
    do
        unset X1
        unset X2
        X1=$(echo "$1" | cut -d: -f1)
        X2=$(echo "$1" | cut -d: -f2)

        [ "$X1" = "$X2" ] && unset X2

        install -v -d         "$ABI_INCLUDE_DIR/$X2" || return 1
        install -v -m 644 $X1 "$ABI_INCLUDE_DIR/$X2" || return 1

        shift
    done
}

install_libs() {
    install -v -d "$ABI_LIBRARY_DIR" || return 1
    for item in $@
    do
        case $item in
            *.dylib) install -v -m 755 $item "$ABI_LIBRARY_DIR" || return 1 ;;
            *)       install -v -m 644 $item "$ABI_LIBRARY_DIR" || return 1
        esac
    done
}

install_pcfs() {
    install -v -d        "$ABI_PKGCONF_DIR" &&
    install -v -m 644 $@ "$ABI_PKGCONF_DIR"
}

install_bins() {
    install -v -d        "$ABI_BINARY__DIR" &&
    install -v -m 755 $@ "$ABI_BINARY__DIR"
}

install_mans() {
    for item in $@
    do
        unset NUMBER
        NUMBER=$(echo "$item" | cut -c ${#item}-${#item})
        case $NUMBER in
            [1-8]);;
            *)    die "$item: not a manpage."
        esac
        install -v -d           "$ABI_INSTALL_DIR/share/man/man$NUMBER" &&
        install -v -m 644 $item "$ABI_INSTALL_DIR/share/man/man$NUMBER"
    done
}

install_pc_file() {
    install -v -d "$ABI_PKGCONF_DIR" &&
    cat >         "$ABI_PKGCONF_DIR/$1.pc"
}

install_files() {
    while [ -n "$1" ]
    do
        case $(echo "$1" | cut -d: -f1) in
            *.[1-8]) install_mans "$1" || return 1 ;;
            *.h)     install_incs "$1" || return 1 ;;
            *.a)     install_libs "$1" || return 1 ;;
            *.dylib) install_libs "$1" || return 1 ;;
            *.pc)    install_pcfs "$1" || return 1 ;;
            *)       install_bins "$1" || return 1 ;;
        esac
        shift
    done
}

__show_infomation_of_packages() {
    unset PACKAGE_LIST

    if [ -z "$1" ] ; then
        [ -d "$MY_FORMULA_DIR" ] || __update_formula_repository
        cd "$MY_FORMULA_DIR" || exit 1
        PACKAGE_LIST=$(ls *.sh | sed 's/\.sh//g')
    else
        PACKAGE_LIST=$@
    fi

    unset FIRST
    unset PACKAGE

    for PACKAGE in $PACKAGE_LIST
    do
        if [ "${FIRST-true}" = 'true' ] ; then
            FIRST=false
        else
            echo "============================================================"
        fi
        __show_infomation_of_a_package "$PACKAGE"
    done
}

__show_infomation_of_a_package() {
    ___load_formula_of_a_package "$1"

    echo "name    : $(mark_is_package_installed_or_not $1)"

    if [ -n "$PACKAGE_VERSION" ] ; then
        echo "version : $PACKAGE_VERSION"
    fi

    echo "summary : $PACKAGE_SUMMARY"
    echo "webpage : $PACKAGE_WEBPAGE"

    [ -z "$PACKAGE_DEPENDS" ] || {
        unset DEPENDENCIES

        for dependencyPkgName in $PACKAGE_DEPENDS
        do
            if [ -z "$DEPENDENCIES" ] ; then
                DEPENDENCIES="depends : $(mark_is_package_installed_or_not $dependencyPkgName)"
            else
                DEPENDENCIES="$DEPENDENCIES | $(mark_is_package_installed_or_not $dependencyPkgName)"
            fi
        done

        echo "$DEPENDENCIES"
    }

    echo "src_url : $PACKAGE_SRC_URL"

    case $PACKAGE_SRC_TYPE in
        dir) ;;
        git)
            if [ -d "$PACKAGE_SRC_PATH" ] ; then
                echo "src_cache ${COLOR_PURPLE}==>${COLOR_OFF} $PACKAGE_SRC_PATH"
            else
                echo "src_cache : ${COLOR_RED}Not cached${COLOR_OFF}"
            fi
            ;;
        *)
            if [ -f "$PACKAGE_SRC_PATH" ] ; then
                echo "src_cache ${COLOR_PURPLE}==>${COLOR_OFF} $PACKAGE_SRC_PATH"
            else
                echo "src_cache : ${COLOR_RED}Not cached${COLOR_OFF}"
            fi
    esac

    if is_package_installed "$1" ; then
        echo "installed ${COLOR_PURPLE}==>${COLOR_OFF} $(du -sh "$MY_INSTALL_DIR/$1" | awk '{print $2, $1}')"

        unset I
        unset ABI
        unset ABI_LIST
        unset ABI_LIST_LENGTH

        ABI_LIST=$(cat "$MY_INSTALL_DIR/$1/manifest.txt")
        ABI_LIST_LENGTH=$(list_length $ABI_LIST)

        for ABI in $ABI_LIST
        do
            I=$(expr ${I-0} + 1)
            if [ "$I" -eq "$ABI_LIST_LENGTH" ] ; then
                echo "              └── $(printf "%-25s" "$ABI") $(du -sh "$MY_INSTALL_DIR/$1/$ABI" | awk '{print $1}')"
            else
                echo "              ├── $(printf "%-25s" "$ABI") $(du -sh "$MY_INSTALL_DIR/$1/$ABI" | awk '{print $1}')"
            fi
        done

        die_if_load_installed_log_failed "$1" "$ABI"
        __show_installed_log "$1" "$ABI"
    fi
}

mark_is_package_installed_or_not() {
    if is_package_installed "$1" ; then
        echo "${COLOR_GREEN}$1${COLOR_OFF}"
    else
        echo "${COLOR_RED}$1${COLOR_OFF}"
    fi
}

summary() {
    if [ -z "$1" ] ; then
        echo "$PACKAGE_SUMMARY"
    else
        PACKAGE_SUMMARY="$1"
    fi
}

webpage() {
    if [ -z "$1" ] ; then
        echo "$PACKAGE_WEBPAGE"
    else
        PACKAGE_WEBPAGE="$1"
    fi
}

src_git() {
    if [ -z "$1" ] ; then
        echo "$PACKAGE_SRC_GIT"
    else
        PACKAGE_SRC_GIT="$1"
    fi
}

src_url() {
    if [ -z "$1" ] ; then
        echo "$PACKAGE_SRC_URL"
    else
        PACKAGE_SRC_URL="$1"
    fi
}

src_sum() {
    if [ -z "$1" ] ; then
        echo "$PACKAGE_SRC_SUM"
    else
        PACKAGE_SRC_SUM="$1"
    fi
}

sourced() {
    if [ -z "$1" ] ; then
        echo "$PACKAGE_SOURCE_DIR"
    else
        PACKAGE_SOURCE_DIR="$1"
    fi
}

build_in_sourced() {
    PACKAGE_BUILD_IN_SOURCE_DIR=true
}

version() {
    if [ -z "$1" ] ; then
        echo "$PACKAGE_VERSION"
    else
        PACKAGE_VERSION="$1"
    fi
}

license() {
    if [ -z "$1" ] ; then
        echo "$PACKAGE_LICENSE"
    else
        PACKAGE_LICENSE="$1"
    fi
}

require() {
    if [ -z "$1" ] ; then
        echo "$PACKAGE_REQUIRE"
    else
        PACKAGE_REQUIRE="$1"
    fi
}

depends() {
    if [ -z "$1" ] ; then
        echo "$PACKAGE_DEPENDS"
    else
        PACKAGE_DEPENDS="$1"
    fi
}

ldflags() {
    if [ -z "$1" ] ; then
        echo "$PACKAGE_LDFLAGS"
    else
        PACKAGE_LDFLAGS="$@"
    fi
}

ios_ios() {
    PACKAGE_IOS_IOS=true
}

patches() {
    if [ -z "$1" ] ; then
        echo "$PACKAGE_PATCHES"
    else
        [ $# -lt 2 ]             && die "the number of arguments of patches command at least 2."
        [ $(expr $# % 2) -eq 1 ] && die "the number of arguments of patches command must be even integer."

        PACKAGE_PATCHES="$@"

        while [ -n "$1" ]
        do
            case $1 in
                *.patch)   PATCH_CONTENT_TYPE=patch  ;;
                *.zip)     PATCH_CONTENT_TYPE=zip    ;;
                *.tar.xz)  PATCH_CONTENT_TYPE=tar.xz ;;
                *.tar.gz)  PATCH_CONTENT_TYPE=tar.gz ;;
                *.tar.lz)  PATCH_CONTENT_TYPE=tar.lz ;;
                *.tar.bz2) PATCH_CONTENT_TYPE=tar.bz2;;
                *.tgz)     PATCH_CONTENT_TYPE=tar.gz ;;
                *.txz)     PATCH_CONTENT_TYPE=tar.xz ;;
                *)  die "$1 : extension isn't recognized. the supported extensions are .patch .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
            esac

            [ ${#2} -eq 64 ] || die "$2 is not sha256sum. the length of sha256sum must be 64."

            shift 2
        done
    fi
}

___load_formula_of_a_package() {
    die_if_package_is_not_available "$1"

    unset PACKAGE_NAME
    unset PACKAGE_SUMMARY
    unset PACKAGE_WEBPAGE
    unset PACKAGE_SRC_GIT
    unset PACKAGE_SRC_URL
    unset PACKAGE_SRC_SUM
    unset PACKAGE_SRC_NAME
    unset PACKAGE_SRC_PATH
    unset PACKAGE_SRC_TYPE
    unset PACKAGE_VERSION
    unset PACKAGE_LICENSE
    unset PACKAGE_PATCHES
    unset PACKAGE_REQUIRE
    unset PACKAGE_DEPENDS
    unset PACKAGE_LDFLAGS
    unset PACKAGE_IOS_IOS

    # relative to $WORKING_DIR, which contains configure, CMakeLists.txt, etc.
    unset PACKAGE_SOURCE_DIR
    unset PACKAGE_BUILD_IN_SOURCE_DIR

    unset -f prepare
    unset -f build
    unset -f build_configed

    PACKAGE_NAME="$1"

    FORMULA_FILE_PATH="$MY_FORMULA_DIR/$PACKAGE_NAME.sh"

    . "$FORMULA_FILE_PATH" || die "$FORMULA_FILE_PATH is broken."

    [ -z "$PACKAGE_SUMMARY" ] && die "summary command must be invoked in $FORMULA_FILE_PATH"
    [ -z "$PACKAGE_WEBPAGE" ] && die "webpage command must be invoked in $FORMULA_FILE_PATH"
    [ -z "$PACKAGE_SRC_URL" ] && die "src_url command must be invoked in $FORMULA_FILE_PATH"

    case $PACKAGE_SRC_URL in
        dir://*)   PACKAGE_SRC_TYPE=dir ;;
        *.git)     PACKAGE_SRC_TYPE=git ;;
        *.zip)     PACKAGE_SRC_TYPE=zip ;;
        *.tar.xz)  PACKAGE_SRC_TYPE=tar.xz ;;
        *.tar.gz)  PACKAGE_SRC_TYPE=tar.gz ;;
        *.tar.lz)  PACKAGE_SRC_TYPE=tar.lz ;;
        *.tar.bz2) PACKAGE_SRC_TYPE=tar.bz2;;
        *.tgz)     PACKAGE_SRC_TYPE=tar.gz ;;
        *.txz)     PACKAGE_SRC_TYPE=tar.xz ;;
        *.c)       PACKAGE_SRC_TYPE=c   ;;
        *.cc)      PACKAGE_SRC_TYPE=cxx ;;
        *.cxx)     PACKAGE_SRC_TYPE=cxx ;;
        *.cpp)     PACKAGE_SRC_TYPE=cxx ;;
        *)  die "$PACKAGE_SRC_URL : extension isn't recognized. the supported extensions are .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    case $PACKAGE_SRC_TYPE in
        dir)
            if command -v cut > /dev/null ; then
                PACKAGE_SRC_PATH=$(echo $PACKAGE_SRC_URL | cut -c7-${#PACKAGE_SRC_URL})
            elif command -v awk > /dev/null ; then
                PACKAGE_SRC_PATH=$(echo $PACKAGE_SRC_URL | awk '{print(substr($0, 7))}')
            else
                PACKAGE_SRC_PATH=$(expr substr "$PACKAGE_SRC_URL" 7 ${#PACKAGE_SRC_URL})
            fi
            [ -d "$PACKAGE_SRC_PATH" ] || "src_url argument point to dir is not exist."
            ;;
        git)
            PACKAGE_SRC_NAME="$PACKAGE_NAME.git"
            PACKAGE_SRC_PATH="$MY_CACHED_DIR/$PACKAGE_SRC_NAME"
            ;;
        *)
            if [ -z "$PACKAGE_SRC_SUM" ] ; then
                die "src_sum command is not invoked in $FORMULA_FILE_PATH"
            fi
            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(basename "$PACKAGE_SRC_URL" | awk '{str = tolower($0); gsub(".tar.xz", "", str); gsub(".tar.gz", "", str); gsub(".tar.lz", "", str); gsub(".tar.bz2", "", str); gsub(".tgz", "", str); gsub(".txz", "", str); gsub(".zip", "", str); print(str)}' | awk -F- '{print $NF}')"
                if [ -z "$PACKAGE_VERSION" ] ; then
                    die "version command is not invoked in $FORMULA_FILE_PATH"
                else
                    case $PACKAGE_VERSION in
                        v*) if command -v cut > /dev/null ; then
                                PACKAGE_VERSION=$(echo $PACKAGE_VERSION | cut -c2-${#PACKAGE_VERSION})
                            elif command -v awk > /dev/null ; then
                                PACKAGE_VERSION=$(echo $PACKAGE_VERSION | awk '{print(substr($0, 2))}')
                            else
                                PACKAGE_VERSION=$(expr substr "$PACKAGE_VERSION" 2 ${#PACKAGE_VERSION})
                            fi
                    esac
                fi
            fi
            PACKAGE_SRC_NAME="$PACKAGE_NAME-$PACKAGE_VERSION.$PACKAGE_SRC_TYPE"
            PACKAGE_SRC_PATH="$MY_CACHED_DIR/$PACKAGE_SRC_NAME"
    esac
}

install_installed_log() {
    cat > "$ABI_LOG_DIR/installed.log.txt" <<EOF
installed_datetime=$TIMESTAMP_UNIX
installed_pkg_version=$PACKAGE_VERSION
min_platform_version=$PLATFORM_MIN_VERSION
using_xcode_version='$XCODE_VERSION'
EOF
}

die_if_load_installed_log_failed() {
    die_if_package_is_not_installed "$1"
    die_if_abi_____is_not_supported "$2"

    INSTALLED_LOG_FILE_PATH="$MY_INSTALL_DIR/$1/$2/log/installed.log.txt"

    unset installed_datetime
    unset installed_pkg_version
    unset min_platform_version
    unset using_xcode_version
    
    . "$INSTALLED_LOG_FILE_PATH" || die "$INSTALLED_LOG_FILE_PATH is broken."
}

__show_installed_log() {
    echo "installed_datetime    : $(format_unix_timestamp $installed_datetime '+%Y/%m/%d %H:%M:%S')"
    echo "installed_pkg_version : $installed_pkg_version"
    echo "min platform version  : $min_platform_version"
    echo "using xcode  version  : $using_xcode_version"
}

__config_this_build_variables() {
    die_if_package_is_not_available "$1"

    BUILD_FOR_ARCH=$(echo_arch_by_abi "$BUILD_FOR_ABI")
    BUILD_FOR_TARGET=$(echo_target_by_arch "$BUILD_FOR_ARCH")

    PLATFORM_MIN_VERSION=$(echo "$BUILD" | cut -d: -f2)
    BUILD_FOR_PLATFORM=$(echo "$BUILD_FOR_ABI" | cut -d/ -f1)
    SYSROOT="$DEVELOPER_DIR/Platforms/${BUILD_FOR_PLATFORM}.platform/Developer/SDKs/${BUILD_FOR_PLATFORM}.sdk"
    platformLower="$(printf "$BUILD_FOR_PLATFORM" | awk '{print(tolower($0))}')"

    for tool in $(list_tools_in_the_toolchain)
    do
        if [ "$tool" = 'cpp' ] ; then
            CPP="$CC -E"
        else
            eval $(echo "$tool" | tr a-z A-Z)=$(echo_path_of_tool_in_the_toolchain "$tool")
        fi
    done

    SYSTEM_INCLUDE_DIR="$SYSROOT/usr/include"
    SYSTEM_LIBRARY_DIR="$SYSROOT/usr/lib"

      CFLAGS="-isysroot $SYSROOT -Qunused-arguments -arch $BUILD_FOR_ARCH -Os -pipe -m${platformLower}-version-min=$PLATFORM_MIN_VERSION"
    CPPFLAGS="-isysroot $SYSROOT -Qunused-arguments"
     LDFLAGS="-isysroot $SYSROOT -arch $BUILD_FOR_ARCH -m${platformLower}-version-min=$PLATFORM_MIN_VERSION"

    if [ -n "$PACKAGE_LDFLAGS" ] ; then
        LDFLAGS="$LDFLAGS $PACKAGE_LDFLAGS"
    fi

    case $BUILD_FOR_ARCH in
        armv7*) CPPFLAGS="$CPPFLAGS -D__arm__"   ;;
        arm64*) CPPFLAGS="$CPPFLAGS -D__arm64__" ;;
        i386)   CPPFLAGS="$CPPFLAGS -D__i386__"  ;;
        x86_64) CPPFLAGS="$CPPFLAGS -D__x86_64__";;
    esac

    # https://www.freedesktop.org/wiki/Software/pkg-config/CrossCompileProposal
    unset PKG_CONFIG_LIBDIR
    unset PKG_CONFIG_PATH

    for PACKAGE in $DEPENDENCY_PACKAGE_LIST
    do
        PKG=$(printf "$PACKAGE" | tr '-' '_')
        
        ABI_INSTALL_DIR="$MY_INSTALL_DIR/$PACKAGE/$BUILD_FOR_ABI"
        ABI_INCLUDE_DIR="$ABI_INSTALL_DIR/include"
        ABI_LIBRARY_DIR="$ABI_INSTALL_DIR/lib"
        ABI_PKGCONF_DIR="$ABI_INSTALL_DIR/lib/pkgconfig"

        eval "${PKG}_INSTALL_DIR='$ABI_INSTALL_DIR'"
        eval "${PKG}_INCLUDE_DIR='$ABI_INCLUDE_DIR'"
        eval "${PKG}_LIBRARY_DIR='$ABI_LIBRARY_DIR'"

        CPPFLAGS="-I$ABI_INCLUDE_DIR $CPPFLAGS"
         LDFLAGS="-L$ABI_LIBRARY_DIR $LDFLAGS"
        PKG_CONFIG_PATH="$PKG_CONFIG_PATH:$ABI_PKGCONF_DIR"
    done

    if [ "$VERBOSE" = 'true' ] ; then
        CFLAGS="$CFLAGS -v"
        if [ -n "$MAKE" ] ; then
            MAKE="$MAKE --debug"
        fi
    fi

    CXXFLAGS="$CFLAGS"

    ABI_INSTALL_DIR="$PKG_INSTALL_DIR/$BUILD_FOR_ABI"
    ABI_BINARY__DIR="$ABI_INSTALL_DIR/bin"
    ABI_INCLUDE_DIR="$ABI_INSTALL_DIR/include"
    ABI_LIBRARY_DIR="$ABI_INSTALL_DIR/lib"
    ABI_PKGCONF_DIR="$ABI_INSTALL_DIR/lib/pkgconfig"
}

__printf_this_build_variables() {
    print_seperator 'printf_this_build_variables start'

    if [ -f "$DEPENDENCIES_TXT" ] ; then
        cat "$DEPENDENCIES_TXT"
    fi

    echo "INSTALLING_PACKAGE= $1"
    echo
    echo " BUILD_ROUND_NUM  = $BUILD_ROUND_NUM"
    echo
    echo " BUILD_FOR_TARGET = $BUILD_FOR_TARGET"
    echo " BUILD_FOR_ARCH   = $BUILD_FOR_ARCH"
    echo " BUILD_FOR_ABI    = $BUILD_FOR_ABI"
    echo
    echo "PLATFORM_MIN_VERSION = $PLATFORM_MIN_VERSION"
    echo
    echo "    XCODE_VERSION = $XCODE_VERSION"
    echo "    DEVELOPER_DIR = $DEVELOPER_DIR"
    echo
    echo "          SYSROOT = $SYSROOT"
    echo "SYSTEM_INCLUDE_DIR= $SYSTEM_INCLUDE_DIR"
    echo "SYSTEM_LIBRARY_DIR= $SYSTEM_LIBRARY_DIR"
    echo
    echo "TOOLCHAIN_BIN_DIR = $TOOLCHAIN_BIN_DIR"

    for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
    do
        eval export $TOOL="\$$TOOL"
        printf "%17s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
    done

    echo

    for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
    do
        eval export ${TOOL}_FOR_BUILD="\$${TOOL}_FOR_BUILD"
        printf "%17s = %s\n" "${TOOL}_FOR_BUILD" "$(eval echo \$${TOOL}_FOR_BUILD)"
    done

    echo

    for TOOL in  SHELL MAKE CMAKE MESON NINJA CARGO PKG_CONFIG
    do
        printf "%17s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
    done

    for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
    do
        eval export $FLAG=\$$FLAG
        printf "\n%17s = " "$FLAG"
        FIRST=true
        for item in $(eval echo \$$FLAG | tr ':' ' ')
        do
            if [ "$FIRST" = 'true' ] ; then
                FIRST=false
                echo "$item"
            else
                echo "                    $item"
            fi
        done
    done

    echo
    echo
    echo "      WORKING_DIR = $WORKING_DIR"
    echo "       SOURCE_DIR = $SOURCE_DIR"
    echo "        EMPTY_DIR = $EMPTY_DIR"
    echo "        BUILD_DIR = $BUILD_DIR"
    echo "              PWD = $PWD"
    echo
    echo "  PKG_INSTALL_DIR = $PKG_INSTALL_DIR"
    echo "  ABI_INSTALL_DIR = $ABI_INSTALL_DIR"
    echo "  ABI_BINARY__DIR = $ABI_BINARY__DIR"
    echo "  ABI_INCLUDE_DIR = $ABI_INCLUDE_DIR"
    echo "  ABI_LIBRARY_DIR = $ABI_LIBRARY_DIR"
    echo "  ABI_PKGCONF_DIR = $ABI_PKGCONF_DIR"

    print_seperator 'printf_this_build_variables end'

    if [ "$VERBOSE" = 'true' ] ; then
        export -p
        print_seperator
    fi
}

print_seperator() {
    info "=========================================> $1"
}

config_url() {
    echo "http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=$1;hb=HEAD"
}

# run in a subshell
configure() {
    die_if_command_not_found make

    if [ "$BUILD_ROUND_NUM" -eq 1 ] ; then
        # https://www.gnu.org/software/gettext/manual/html_node/config_002eguess.html
        # https://git.savannah.gnu.org/cgit/config.git/tree/
        for item in config.sub config.guess
        do
            for file in $(find "$SOURCE_DIR" -name "$item")
            do
                CONFIG_XX="$MY_CACHED_DIR/config/$item"
                if [ ! -f "$CONFIG_XX" ] ; then
                    fetch $(config_url "$item") --output-path="$CONFIG_XX" || return 1
                    chmod a+x "$CONFIG_XX" || return 1
                    if [ "$item" = 'config.sub' ] ; then
                        sed_in_place 's/arm64-*/arm64-*|arm64e-*/g' "$CONFIG_XX" || return 1
                    fi
                fi
                cp -v "$CONFIG_XX" "$file" || return 1
            done
        done
    fi

    print_seperator "config start"
    
    if "$SOURCE_DIR"/configure \
        --host="$BUILD_FOR_TARGET" \
        --prefix="$ABI_INSTALL_DIR" \
        --disable-option-checking \
        --disable-rpath \
        --disable-debug \
        --disable-nls\
        --enable-largefile \
        --enable-static \
        --enable-shared \
        CC="$CC" \
        CFLAGS="$CFLAGS" \
        CXX="$CXX" \
        CXXFLAGS="$CXXFLAGS" \
        CPP="$CPP" \
        CPPFLAGS="$CPPFLAGS" \
        LDFLAGS="$LDFLAGS" \
        AR="$AR" \
        RANLIB="$RANLIB" \
        PKG_CONFIG="$PKG_CONFIG" \
        PKG_CONFIG_PATH="$PKG_CONFIG_PATH" \
        PKG_CONFIG_LIBDIR="" \
        CC_FOR_BUILD="$CC_FOR_BUILD" \
        $@ ; then
        print_seperator "config success"
    else
        print_seperator "config failed"
        return 1
    fi

    if [ "$VERBOSE" = 'true' ] ; then
        for Makefile in $(find "$SOURCE_DIR" -name Makefile)
        do
            sed_in_place 's|\t@|\t|g'     "$Makefile" || return 1
            sed_in_place 's|@echo|echo|g' "$Makefile" || return 1
        done
        unset Makefile
    fi

    print_seperator "clean start"
    if $MAKE clean ; then
        print_seperator "clean success"
    else
        print_seperator "clean failed"
        return 1
    fi

    print_seperator "build start"
    if $MAKE ; then
        print_seperator "build success"
    else
        print_seperator "build failed"
        return 1
    fi

    print_seperator "install start"
    if $MAKE install ; then
        print_seperator "install success"
    else
        print_seperator "install failed"
        return 1
    fi
}

# https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling
# https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html
# https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
# https://cmake.org/cmake/help/latest/command/enable_testing.html?highlight=build_testing
# run in a subshell
#-DCMAKE_OSX_ARCHITECTURES="$BUILD_FOR_ARCH" \
cmake() {
    die_if_command_not_found cmake
    die_if_command_not_found  make

    cat > "$BUILD_DIR/toolchain.cmake" <<EOF
set(CMAKE_SYSTEM_NAME Darwin)
set(CMAKE_SYSTEM_PROCESSOR $BUILD_FOR_ARCH)

set(CMAKE_ASM_COMPILER $AS)
set(CMAKE_ASM_FLAGS "-arch $BUILD_FOR_ARCH")

set(CMAKE_C_COMPILER "$CC")
set(CMAKE_C_FLAGS "$CFLAGS $CPPFLAGS")

set(CMAKE_CXX_COMPILER "$CXX")
set(CMAKE_CXX_FLAGS "$CXXFLAGS $CPPFLAGS")

set(CMAKE_AR "$AR")
set(CMAKE_RANLIB "$RANLIB")

set(CMAKE_NM "$NM")
set(CMAKE_STRIP "$STRIP")

set(CMAKE_OSX_SYSROOT "$SYSROOT")
EOF
    "$CMAKE" \
    -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
    -DCMAKE_VERBOSE_MAKEFILE=ON \
    -DCMAKE_COLOR_MAKEFILE=ON \
    -DCMAKE_TOOLCHAIN_FILE="$BUILD_DIR/toolchain.cmake" \
    -DCMAKE_PREFIX_PATH="$MY_INSTALL_DIR" \
    -DCMAKE_FIND_ROOT_PATH="$MY_INSTALL_DIR" \
    -DCMAKE_INSTALL_PREFIX="$ABI_INSTALL_DIR" \
    -DCMAKE_BUILD_TYPE=Release \
    -DBUILD_SHARED_LIBS=OFF \
    -DBUILD_TESTING=OFF \
    -G "Unix Makefiles" \
    -Wno-dev \
    -S "$SOURCE_DIR" \
    -B "$BUILD_DIR" $@ &&
    $MAKE --directory="$BUILD_DIR" &&
    $MAKE --directory="$BUILD_DIR" install
}

# https://mesonbuild.com/Cross-compilation.html
# run in a subshell
meson() {
    die_if_command_not_found meson
    die_if_command_not_found ninja

    case $BUILD_FOR_ARCH in
        armv7*)
            HOST_MACHINE_CPU_FAMILY='arm'
            HOST_MACHINE_CPU_NAME="$BUILD_FOR_ARCH"
            ;;
        arm64*)
            HOST_MACHINE_CPU_FAMILY='aarch64'
            HOST_MACHINE_CPU_NAME="$BUILD_FOR_ARCH"
            ;;
        i386)
            HOST_MACHINE_CPU_FAMILY='x86'
            HOST_MACHINE_CPU_NAME="$BUILD_FOR_ARCH"
            ;;
        x86_64)
            HOST_MACHINE_CPU_FAMILY='x86_64'
            HOST_MACHINE_CPU_NAME="$BUILD_FOR_ARCH"
            ;;
    esac

    cat >> "$BUILD_DIR/cross-file" <<EOF
[host_machine]
system = 'darwin'
endian = 'little'
cpu_family = '$HOST_MACHINE_CPU_FAMILY'
cpu = '$HOST_MACHINE_CPU_NAME'

[binaries]
c = '$CC'
cpp = '$CXX'
ar = '$AR'
strip = '$STRIP'
cmake = '$CMAKE'
pkgconfig = '$PKG_CONFIG'

[properties]
c_args = $(to_meson_array $CFLAGS $CPPFLAGS)
c_link_args = $(to_meson_array $LDFLAGS)
cpp_args = $(to_meson_array $CXXFLAGS $CPPFLAGS)
cpp_link_args = $(to_meson_array $LDFLAGS)
EOF
    "$MESON" setup \
        --prefix="$ABI_INSTALL_DIR" \
        --buildtype=release \
        --backend=ninja \
        --pkg-config-path="$PKG_CONFIG_PATH" \
        --build.pkg-config-path="$PKG_CONFIG_PATH_FOR_BUILD" \
        --cross-file="$BUILD_DIR/cross-file" \
        $@ "$BUILD_DIR" "$SOURCE_DIR" &&
    {
        if command -v build_configed > /dev/null ; then
            build_configed
        fi
    } &&
    "$NINJA" -C "$BUILD_DIR" install
}

to_meson_array() {
    RESULT="[''"
    for item in $@
    do
        RESULT="$RESULT, '$item'"
    done
    RESULT="$RESULT]"
    echo "$RESULT"
}

cargo() {
    die_if_command_not_found rustup
    die_if_command_not_found cargo

    if [ "$BUILD_ROUND_NUM" -eq 1 ] ; then
        for supportedTarget in $(__list_supported_targets)
        do
            for installedTarget in $(rustup target list | grep installed | cut -d " " -f1)
            do
                [ "$supportedTarget" = "$installedTarget" ] && break
            done
            [ "$supportedTarget" = "$installedTarget" ] || {
                rustup target add "$supportedTarget" || return 1
            }
        done
        grep -q '\[lib\]' "$SOURCE_DIR/Cargo.toml" ||
        cat >> "$SOURCE_DIR/Cargo.toml" <<EOF

[lib]
crate-type = ["staticlib", "cdylib"]
EOF
    fi

    BUILD_FOR_TARGET=$(echo "$BUILD_FOR_TARGET" | sed 's/armv7a/armv7/')

    # https://doc.rust-lang.org/cargo/reference/environment-variables.html
    CARGO_TARGET_XXX=$(echo "$BUILD_FOR_TARGET" | tr a-z A-Z | tr - _)
    eval export CARGO_TARGET_${CARGO_TARGET_XXX}_AR=$AR
    eval export CARGO_TARGET_${CARGO_TARGET_XXX}_LINKER=$CC

    env | grep CARGO_TARGET_

    print_seperator "build start"
    if command cargo build --target $BUILD_FOR_TARGET --release --verbose ; then
        print_seperator "build success"
    else
        print_seperator "build failed"
        return 1
    fi

    print_seperator "install start"

    for item in $@
    do
        case $(echo "$item" | cut -d: -f1) in
           /*.[1-8]) install_mans "$item"             || return 1 ;;
            *.[1-8]) install_mans "$SOURCE_DIR/$item" || return 1 ;;
           /*.h)     install_incs "$item"             || return 1 ;;
            *.h)     install_incs "$SOURCE_DIR/$item" || return 1 ;;
            *.a)     install_libs "$SOURCE_DIR/target/$BUILD_FOR_TARGET/release/$item" || return 1 ;;
            *.dylib) install_libs "$SOURCE_DIR/target/$BUILD_FOR_TARGET/release/$item" || return 1 ;;
            *)       install_bins "$SOURCE_DIR/target/$BUILD_FOR_TARGET/release/$item" || return 1 ;;
        esac
    done

    print_seperator "install success"
}

########################################################################

die_if_rule_is_not_available() {
    [ -z "$1" ] && die "please specify a rule name."
    [ -f "$MY_HOME_DIR/rules/$1" ] || die "$1 : rule is not exist."
}

die_if_rule_is_already_exist() {
    [ -z "$1" ] && die "please specify a rule name."
    [ -f "$MY_HOME_DIR/rules/$1" ] && die "$1 : rule is already exist."
}

____view_a_rule() {
    die_if_rule_is_not_available "$1"

    if command -v bat > /dev/null ; then
        bat "$MY_HOME_DIR/rules/$1"
    else
        cat "$MY_HOME_DIR/rules/$1"
    fi    
}

____edit_a_rule() {
    die_if_rule_is_not_available "$1"

    [ -z "$EDITOR" ] &&
    EDITOR=$(command -v nvim) ||
    EDITOR=$(command -v vim) ||
    EDITOR=$(command -v vi) ||
    EDITOR=$(command -v open) ||
    die "please set EDITOR environment variable."

    "$EDITOR" "$MY_HOME_DIR/rules/$1"

    VERBOSE=true
    resolve_a_rule "$1"
}

__create_a_rule() {
    die_if_rule_is_already_exist "$1"

    cat > "$MY_HOME_DIR/rules/$1" <<EOF
# please comment or remove the line you don't want.

# AppleTVOS        : 9.0  : all
# AppleTVSimulator : 9.0  : all
# MacOSX           : 10.6 : all
# WatchOS          : 2.0  : all
# WatchSimulator   : 2.0  : all
# iPhoneOS         : 8.0  : all
# iPhoneSimulator  : 8.0  : all
EOF
    ____edit_a_rule "$1"
}

__delete_a_rule() {
    die_if_rule_is_not_available "$1"

    [ "$1" = 'default' ] && die "default rule can not be deleted."

    if rm "$MY_HOME_DIR/rules/$1" ; then
        success "delete $1 rule success."
    else
        die "delete $1 rule failed."
    fi
}

__rename_a_rule() {
    die_if_rule_is_not_available "$1"
    die_if_rule_is_already_exist "$2"

    [ "$1" = 'default' ] && die "default rule can not be renamed to another."

    if mv -v "$MY_HOME_DIR/rules/$1" "$MY_HOME_DIR/rules/$2" ; then
        success "rename rule $1 -> $2 success."
    else
        die "rename rule $1 -> $2 failed."
    fi
}

resolve_a_rule() {
    die_if_rule_is_not_available "$1"

    unset BUILD_LIST

    unset BUILD_FOR_PLATFORM
    unset PLATFORM_MIN_VERSION
    unset BUILD_FOR_ARCH

    while read line
    do
        line=$(echo "$line" | sed 's/[[:space:]]//g')

        [ -z "$line" ] && continue
        echo "$line" | grep -q '^#' && continue

        BUILD_FOR_PLATFORM=$(echo "$line" | cut -d: -f1)
        PLATFORM_MIN_VERSION=$(echo "$line" | cut -d: -f2)
        BUILD_FOR_ARCH=$(echo "$line" | cut -d: -f3)

        if [ "$VERBOSE" = 'true' ] ; then
            echo "BUILD_FOR_PLATFORM=$BUILD_FOR_PLATFORM"
            echo "PLATFORM_MIN_VERSION=$PLATFORM_MIN_VERSION"
            echo "BUILD_FOR_ARCH=$BUILD_FOR_ARCH"
            echo '---------------------------------'
        fi
        
        [ -z "$PLATFORM_MIN_VERSION" ] && {
            PLATFORM_MIN_VERSION=$(get_supported_min_version "$BUILD_FOR_PLATFORM")
        }
        
        if [ -z "$BUILD_FOR_ARCH" -o "$BUILD_FOR_ARCH" = 'all' ] ; then
            for BUILD_FOR_ARCH in $(list_supported_archs "$BUILD_FOR_PLATFORM")
            do
                if [ -z "$BUILD_LIST" ]; then
                    BUILD_LIST="$BUILD_FOR_PLATFORM/$BUILD_FOR_ARCH:$PLATFORM_MIN_VERSION"
                else
                    BUILD_LIST=$(printf "%s\n%s" "$BUILD_LIST" "$BUILD_FOR_PLATFORM/$BUILD_FOR_ARCH:$PLATFORM_MIN_VERSION")
                fi
            done
        else
            if [ -z "$BUILD_LIST" ]; then
                BUILD_LIST="$BUILD_FOR_PLATFORM/$BUILD_FOR_ARCH:$PLATFORM_MIN_VERSION"
            else
                BUILD_LIST=$(printf "%s\n%s" "$BUILD_LIST" "$BUILD_FOR_PLATFORM/$BUILD_FOR_ARCH:$PLATFORM_MIN_VERSION")
            fi
        fi
    done < "$MY_HOME_DIR/rules/$1"

    unset BUILD_FOR_PLATFORM
    unset PLATFORM_MIN_VERSION
    unset BUILD_FOR_ARCH

    if [ "$VERBOSE" = 'true' ] ; then
        for item in $BUILD_LIST
        do
            echo "$item"
        done
    fi
}

inject_stub_system() {
    cat > "$SOURCE_DIR/stub-system.c" <<EOF
#ifndef SYSTEM_STUB_C
#define SYSTEM_STUB_C

#include <stdlib.h>
#include <unistd.h>
#include <spawn.h>
#include <sys/wait.h>

extern char **environ;

#ifdef __cplusplus
    extern "C" {
#endif

__attribute__((unused))
static int stub_system(char* cmd) {
    char argv0[] = "sh";
    char argv1[] = "-c";
    char* const argv[4] = {argv0, argv1, cmd, NULL};
    pid_t pid;
    int status;
    status = posix_spawn(&pid, "/bin/sh", NULL, NULL, argv, environ);
    if (0 == status) {
        return waitpid(pid, &status, 0);
    }
    return status;
}

#define system(x) stub_system(x)

#ifdef __cplusplus
    }
#endif

#endif
EOF
    for item in $@
    do
        echo "inject $SOURCE_DIR/stub-system.c -> $item"
        cat "$SOURCE_DIR/stub-system.c" "$item" > "$item.bak" || return 1
        mv "$item.bak" "$item" || return 1
    done
}

include_stub_system() {
    if [ "$BUILD_ROUND_NUM" -eq 1 ] ; then
        gen_stub_system
    fi
    export CPPFLAGS="$CPPFLAGS -include $SOURCE_DIR/stub-system.c"
}

check_prerequisites() {
    DEVELOPER_DIR="$(xcode-select -p)"

    [ -z "$DEVELOPER_DIR" ] && die "please set and export DEVELOPER_DIR=DIR environment variable, then try again."
    [ -d "$DEVELOPER_DIR" ] || die "DEVELOPER_DIR=$DEVELOPER_DIR directory is not exist."

    TOOLCHAIN_BIN_DIR="$DEVELOPER_DIR/Toolchains/XcodeDefault.xctoolchain/usr/bin"

    XCODE_VERSION=$(system_profiler SPDeveloperToolsDataType | grep Version | cut -d: -f2 | sed 's/^ //g')
}

__list_rules() {
    ls "$MY_HOME_DIR/rules"
}

list_supported_platforms() {
    [ -z "$DEVELOPER_DIR" ] && check_prerequisites
    ls "$DEVELOPER_DIR/Platforms" | sed 's/.platform//g'
    #print_list AppleTVOS AppleTVSimulator MacOSX iPhoneOS iPhoneSimulator WatchOS WatchSimulator
}

list_supported_archs() {
    if [ -z "$1" ] ; then
        for PLATFORM in $(list_supported_platforms)
        do
            printf "%-16s : $(list_supported_archs "$PLATFORM")\n" "$PLATFORM"
        done
    else
        case $1 in
            iPhoneOS)   echo "armv7 armv7s arm64 arm64e";;
            WatchOS)    echo "arm64_32 armv7k";;
            AppleTVOS)  echo "arm64";;
            MacOSX)     echo "x86_64";;
            *Simulator) echo "x86_64 i386";;
            --table)
                cat <<EOF
┌───────────┬───────────────────────────┐
│ platform  │ arch                      │
│           │                           │
│ AppleTVOS │ arm64                     │
│ WatchOS   │ arm64_32 armv7k           │
│ iPhoneOS  │ armv7 armv7s arm64 arm64e │
│ MacOSX    │ x86_64                    │
│ *Simulator│ x86_64 i386               │
└───────────┴───────────────────────────┘
EOF
;;
            *)      die "$1 : platform isn't supported."
        esac
    fi
}

__list_supported_abis() {
    for PLATFORM in $(list_supported_platforms)
    do
        for ARCH in $(list_supported_archs "$PLATFORM")
        do
            echo "$PLATFORM/$ARCH"
        done
    done
}

list_supported_targets() {
    for ARCH in armv7 armv7s arm64 arm64e arm64_32 armv7k x86_64 i386
    do
        echo_target_by_arch "$ARCH"
    done
}

echo_arch_by_abi() {
    echo "$1" | cut -d/ -f2
}

echo_target_by_arch() {
    if [ 'arm64' = "$1" ] ; then
        if [ "$PACKAGE_IOS_IOS" = 'true' ] ; then
            echo 'aarch64-apple-ios'
        else
            echo 'aarch64-apple-darwin'
        fi
    else
        if [ "$PACKAGE_IOS_IOS" = 'true' ] ; then
            echo "$1-apple-ios"
        else
            echo "$1-apple-darwin"
        fi
    fi
}

list_tools_in_the_toolchain() {
    list cc cxx cpp as ar ranlib ld nm strip size strings objdump
}

list_flags_used_by_tools_in_the_toolchain() {
    list CFLAGS CXXFLAGS CPPFLAGS LDFLAGS PKG_CONFIG_PATH PKG_CONFIG_LIBDIR
}

echo_path_of_tool_in_the_toolchain() {
    unset TOOL_PATH
    case $1 in
        cc)  TOOL_PATH="$TOOLCHAIN_BIN_DIR/clang"   ;;
        cxx) TOOL_PATH="$TOOLCHAIN_BIN_DIR/clang++" ;;
        *)   TOOL_PATH="$TOOLCHAIN_BIN_DIR/$1"
    esac
    die_if_file_is_not_executable "$TOOL_PATH"
    echo "$TOOL_PATH"
}

list_supported_versions() {
    if [ -z "$1" ] ; then
        for PLATFORM in $(list_supported_platforms)
        do
            printf "%-16s : $(list_supported_versions "$PLATFORM")\n" "$PLATFORM"
        done
    else
        case $1 in
            iPhoneOS|iPhoneSimulator)   echo "8.0 8.1 8.2 8.3 8.4 9.0 9.1 9.2 9.3 10.0 10.1 10.2 10.3 11.0 11.1 11.2 11.3 11.4 12.0 12.1 12.2 12.3 12.4 13.0 13.1 13.2 13.3 13.4 13.5";;
            WatchOS|WatchSimulator)     echo "2.0 2.1 2.2 3.0 3.1 3.2 4.0 4.1 4.2 4.3 5.0 5.1 5.2 5.3 6.0 6.1 6.2";;
            AppleTVOS|AppleTVSimulator) echo "9.0 9.1 9.2 10.0 10.1 10.2 11.0 11.1 11.2 11.3 11.4 12.0 12.1 12.3 12.4 13.0 13.1 13.2 13.3";;
            MacOSX)                     echo "10.6 10.7 10.8 10.9 10.10 10.11 10.12 10.13 10.14 10.15";;
            *)     die "$1 : platform isn't supported."
        esac
    fi
}

get_supported_min_version() {
    if [ -z "$1" ] ; then
        for PLATFORM in $(list_supported_platforms)
        do
            printf "%-16s : %s\n" "$PLATFORM" $(get_supported_min_version "$PLATFORM")
        done
    else
        list_supported_versions "$1" | awk '{print $1}'
    fi
}

echo_tool_of_chain() {
    TOOL="$TOOLCHAIN_BIN_DIR/$1"
    die_if_file_is_not_executable "$TOOL"
    echo "$TOOL"
}

__create_framework_of_packages() {
    die_if_package_list_is_not_specified "$1"
    
    for PACKAGE in $@
    do
        __create_framework_for_a_package "$PACKAGE"
    done
}

__create_framework_for_a_package() {
    die_if_package_is_not_installed "$1"

    unset -f create_framework

    ___load_formula_of_a_package "$1"
    
    if command -v create_framework > /dev/null ; then
        create_framework
    else
        die "create_framework function is not declared in formula $MY_FORMULA_DIR/$1.sh"
    fi
}

parse_arguments() {
    # https://stackoverflow.com/questions/18476490/what-is-purpose-of-target-arch-variable-in-makefiles
    unset TARGET_ARCH

    unset USER_SPECIFIED_PACKAGE_LIST

    unset PLATFORM_MIN_VERSION

    unset RULE

    unset DRYRUN
    unset XTRACE
    unset VERBOSE

    unset KEEP_WORKING_DIR

    ACTION="$1"
    
    shift 1
    
    while [ -n "$1" ]
    do
        case $1 in
            --rule=*)
                RULE=$(getvalue "$1")
                [ -z "$RULE" ] && die "--rule=VALUE argument's value must not be empty."
                ;;
            --verbose|-v)
                VERBOSE=true
                ;;
            --xtrace|-x)
                XTRACE=true
                set -x
                ;;
            --dry-run)
                DRYRUN=true
                ;;
            --keep-working-dir)
                KEEP_WORKING_DIR=true
                ;;
            [a-z]*)
                if [ -z "$USER_SPECIFIED_PACKAGE_LIST" ] ; then
                    USER_SPECIFIED_PACKAGE_LIST="$1"
                else
                    USER_SPECIFIED_PACKAGE_LIST="$USER_SPECIFIED_PACKAGE_LIST $1"
                fi
                ;;
            *)  die "$1 is a invalid argument."
        esac
        shift
    done

    [ -z "$RULE" ] && RULE=default
    
    resolve_a_rule "$RULE"
}

init() {
    # MY represents this software's
    MY_NAME=ipkg
    MY_VERSION=0.1.0
    MY_HOME_PAGE="https://github.com/leleliu008/$MY_NAME"

    if [ -z "$IPKG_FORMULA_REPO_URL" ] ; then
        MY_FORMULA_REPO_URL="https://github.com/leleliu008/$MY_NAME-formula.git"
    else
        MY_FORMULA_REPO_URL="$IPKG_FORMULA_REPO_URL"
    fi

    if [ -z "$IPKG_HOME_DIR" ] ; then
        MY_HOME_DIR="$HOME/.$MY_NAME"
    else
        MY_HOME_DIR="$IPKG_HOME_DIR"
    fi

    MY_FORMULA_DIR="$MY_HOME_DIR/formula"
    MY_INSTALL_DIR="$MY_HOME_DIR/pkg"
    MY_CACHED_DIR="$MY_HOME_DIR/downloads"
    MY_BOTTLE_DIR="$MY_HOME_DIR/bottles"
    MY_BACKUP_DIR="$MY_HOME_DIR/backup"
    MY_PATCH_DIR="$MY_HOME_DIR/patches"

    if [ ! -d "$MY_HOME_DIR/rules" ] ; then
        mkdir -p "$MY_HOME_DIR/rules"
    fi
    if [ ! -f "$MY_HOME_DIR/rules/default" ] ; then
        cat > "$MY_HOME_DIR/rules/default" <<EOF
iPhoneOS         : 8.0  : all
iPhoneSimulator  : 8.0  : all
EOF
    fi

    if command -v date > /dev/null ; then
        TIMESTAMP_UNIX="$(date +%s)"
    else
        die "command not found: date. please make sure it in PATH."
    fi
}

help() {
    cat << EOF
Usage: $MY_NAME <ACTION> [ARGUMENT...]
ACTION:
    help    | --help    | -h    --show help information.
    version | --version | -V    --print version of $MY_NAME and Android NDK.
    
    list rules             --list the rules.
    list versions          --list the supported versions of platforms.
    list platforms         --list the supported platforms.
    list available         --list the available packages.
    list installed         --list the installed packages.
    list outdated          --list the outdated packages.

    is available PACKAGE  --is PACKAGE available?
    is installed PACKAGE  --is PACKAGE installed?
    is outdated  PACKAGE  --is PACKAGE outdated?
    
    search KEYWORD        --search packages.
    
    rule create RULE      --create a new rule.
    rule delete RULE      --delete a exist rule.
    rule rename R1 R2     --rename a exist rule to new name.
    rule view RULE        --view the specified rule.
    rule edit RULE        --edit the specified rule.
    rule list             --equipment to list rules.

    formula create PACKAGE   --create a new formula.
    formula delete PACKAGE   --delete a exist formula.
    formula rename P1 P2     --rename a exist formula to new name.
    formula view PACKAGE     --view the formula of a package.
    formula edit PACKAGE     --edit the formula of a package.
    formula list             --equipment to list available

    tree PACKAGE          --list contents of a installed package directory in a tree-like format.
    pack PACKAGE          --pack a installed package.
    fetch PACKAGE         --download formula resources of a package to the cache.
    prefix PACKAGE        --show the installation direcotory of a formula or the $MY_NAME home.
    homepage PACKAGE      --visit the homepage of a formula or the $MY_NAME project.
    
    install   PACKAGE... [--create-framework --rule=default -v -x]    --install packages.
    reinstall PACKAGE... [--create-framework --rule=default -v -x]    --reinstall packages.
    upgrade   PACKAGE... [--create-framework --rule=default -v -x]    --upgrade packages.

    uninstall PACKAGE...                --uninstall packages.
    info      PACKAGE...                --print the information of packages.
    
    create-framework PACKAGE...         --create framework for packages.
    
    logs PACKAGE PLATFORM/ARCH          --print the logs of a installed package.
    
    min-version [PLATFORM]              --print the supported min-version of platforms.
    
    cleanup          --cleanup the unused cache.
    update           --update the formula repository.
EOF
    if [ -z "$1" ] ; then
        exit
    else
        exit "$1"
    fi
}

main() {
    if [ "$(uname -s)" != 'Darwin' ] ; then
        die "this software can only run on macOS."
    fi

    init
     
    case $1 in
        --help|help|-h) 
            help
            ;;
        --version|version|-V)
            echo "$MY_NAME  $MY_VERSION"
            check_prerequisites
            echo "Xcode $XCODE_VERSION"
            ;;
        list)
            shift
            case $1 in
                platforms) shift; list_supported_platforms "$@" ;;
                versions)  shift; list_supported_versions  "$@" ;;
                archs)     shift; list_supported_archs     "$@" ;;
                abis)
                    shift
                    if [ -z "$1" ] ; then
                        __list_supported_abis
                    else
                        __list_abis_of_a_installed_package "$1"
                    fi
                    ;;
                rules)     shift; __list_rules ;;
                available) shift; __list_available_packages ;;
                installed) shift; __list_installed_packages ;;
                outdated)  shift; __list__outdated_packages ;;
                *) help 1
            esac
            ;;
        min-version) shift; get_supported_min_version "$1" ;;
        search)  shift; __search_packages "$*" ;;
        formula) shift
            case $1 in
                create) shift; __create_a_formula "$@" ;;
                delete) shift; __delete_a_formula "$@" ;;
                rename) shift; __rename_a_formula "$@" ;;
                view)   shift; ____view_a_formula "$@" ;;
                edit)   shift; ____edit_a_formula "$@" ;;
                list)   shift; __list_available_packages ;;
                   *)   help 1
            esac
            ;;
        rule)
            shift
            case $1 in
                create) shift; __create_a_rule "$@" ;;
                delete) shift; __delete_a_rule "$@" ;;
                rename) shift; __rename_a_rule "$@" ;;
                view)   shift; ____view_a_rule "$@" ;;
                edit)   shift; ____edit_a_rule "$@" ;;
                list)   shift; __list_rules ;;
                   *)   help 1
            esac
            ;;
        update)  __update_formula_repository ;;
        cleanup) __cleanup ;;
        
        install)   ____install_packages "$@" ;;
        reinstall) __reinstall_packages "$@" ;;
        uninstall) __uninstall_packages "$@" ;;
        upgrade)   ____upgrade_packages "$@" ;;

        homepage) shift; __show_webpage_of_a_package    "$@" ;;
        prefix)   shift; __show_prefix_of_a_package     "$@" ;;
        fetch)    shift; __fetch_resources_of_a_package "$@" ;;
        logs)     shift; __show_logs_of_a_package       "$@" ;;
        pack)     shift; __pack_bottle_of_a_package     "$@" ;;
        tree)     shift; __tree_installed_of_a_package  "$@" ;;
        info)     shift; __show_infomation_of_packages  "$@" ;;
        create-framework)
                  shift; __create_framework_of_packages "$@" ;;
        is)
            shift
            case $1 in
                available) shift; is_package_available "$@" ;;
                installed) shift; is_package_installed "$@" ;;
                outdated)  shift; is_package__outdated "$@" ;;
                *) help 1
            esac
            ;;
        *) help 1
    esac
}

main "$@"